This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
button/
  option.go
checkbox/
  option.go
checkboxgroup/
  option.go
  value.go
columns/
  option.go
dateinput/
  option.go
datetimeinput/
  option.go
form/
  option.go
internal/
  conv/
    conv.go
    path.go
  errdefs/
    errdefs.go
  logger/
    logger.go
  options/
    button.go
    checkbox.go
    checkboxgroup.go
    columns.go
    dateinput.go
    datetimeinput.go
    form.go
    markdown.go
    multiselect.go
    numberinput.go
    radio.go
    selectbox.go
    table.go
    textarea.go
    textinput.go
    timeinput.go
  pb/
    exception/
      v1/
        exception.pb.go
    page/
      v1/
        page.pb.go
    redis/
      v1/
        redis.pb.go
    websocket/
      v1/
        message.pb.go
    widget/
      v1/
        widget.pb.go
  session/
    state/
      button.go
      checkbox.go
      checkboxgroup.go
      columnitem.go
      columns.go
      dateinput.go
      datetimeinput.go
      form.go
      markdown.go
      multiselect.go
      numberinput.go
      radio.go
      selectbox.go
      table.go
      textarea.go
      textinput.go
      timeinput.go
      widget.go
    session_test.go
    session.go
    state.go
  websocket/
    mock/
      websocket.go
    types.go
    websocket_test.go
    websocket.go
markdown/
  option.go
multiselect/
  option.go
  value.go
numberinput/
  option.go
radio/
  option.go
  value.go
selectbox/
  option.go
  value.go
table/
  option.go
  value.go
textarea/
  option.go
textinput/
  option.go
timeinput/
  option.go
.gitignore
.golangci.yml
button_test.go
button.go
checkbox_test.go
checkbox.go
checkboxgroup_test.go
checkboxgroup.go
CODE_OF_CONDUCT.md
columns_test.go
columns.go
config.go
dateinput_test.go
dateinput.go
datetimeinput_test.go
datetimeinput.go
form_test.go
form.go
go.mod
LICENSE
markdown_test.go
markdown.go
MIRROR_README.md
multiselect_test.go
multiselect.go
numberinput_test.go
numberinput.go
page.go
radio_test.go
radio.go
README.md
router_test.go
router.go
runtime_test.go
runtime.go
SECURITY.md
selectbox_test.go
selectbox.go
sourcetool_test.go
sourcetool.go
table_test.go
table.go
textarea_test.go
textarea.go
textinput_test.go
textinput.go
timeinput_test.go
timeinput.go
uibuilder_test.go
uibuilder.go
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="button/option.go">
package button

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.ButtonOptions)
}

type disabledOption bool

func (d disabledOption) Apply(opts *options.ButtonOptions) {
	opts.Disabled = bool(d)
}

func WithDisabled(disabled bool) Option {
	return disabledOption(disabled)
}
</file>

<file path="checkbox/option.go">
package checkbox

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.CheckboxOptions)
}

type defaultValueOption bool

func (d defaultValueOption) Apply(opts *options.CheckboxOptions) {
	opts.DefaultValue = bool(d)
}

func WithDefaultValue(defaultValue bool) Option {
	return defaultValueOption(defaultValue)
}

type requiredOption bool

func (r requiredOption) Apply(opts *options.CheckboxOptions) {
	opts.Required = bool(r)
}

func WithRequired(required bool) Option {
	return requiredOption(required)
}

type disabledOption bool

func (d disabledOption) Apply(opts *options.CheckboxOptions) {
	opts.Disabled = bool(d)
}

func WithDisabled(disabled bool) Option {
	return disabledOption(disabled)
}
</file>

<file path="checkboxgroup/option.go">
package checkboxgroup

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.CheckboxGroupOptions)
}

type optionsOption []string

func (o optionsOption) Apply(opts *options.CheckboxGroupOptions) {
	opts.Options = []string(o)
}

func WithOptions(options ...string) Option {
	return optionsOption(options)
}

type defaultValueOption []string

func (d defaultValueOption) Apply(opts *options.CheckboxGroupOptions) {
	opts.DefaultValue = []string(d)
}

func WithDefaultValue(defaultValue ...string) Option {
	return defaultValueOption(defaultValue)
}

type requiredOption bool

func (r requiredOption) Apply(opts *options.CheckboxGroupOptions) {
	opts.Required = bool(r)
}

func WithRequired(required bool) Option {
	return requiredOption(required)
}

type disabledOption bool

func (d disabledOption) Apply(opts *options.CheckboxGroupOptions) {
	opts.Disabled = bool(d)
}

func WithDisabled(disabled bool) Option {
	return disabledOption(disabled)
}

type formatFuncOption func(string, int) string

func (f formatFuncOption) Apply(opts *options.CheckboxGroupOptions) {
	opts.FormatFunc = func(s string, i int) string {
		return f(s, i)
	}
}

func WithFormatFunc(formatFunc func(string, int) string) Option {
	return formatFuncOption(formatFunc)
}
</file>

<file path="checkboxgroup/value.go">
package checkboxgroup

type Value struct {
	Values  []string
	Indexes []int
}
</file>

<file path="columns/option.go">
package columns

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.ColumnsOptions)
}

type weightOption []int

func (w weightOption) Apply(opts *options.ColumnsOptions) {
	opts.Weight = []int(w)
}

func WithWeight(weight ...int) Option {
	return weightOption(weight)
}
</file>

<file path="dateinput/option.go">
package dateinput

import (
	"time"

	"github.com/trysourcetool/sourcetool-go/internal/options"
)

type Option interface {
	Apply(*options.DateInputOptions)
}

type placeholderOption string

func (p placeholderOption) Apply(opts *options.DateInputOptions) {
	opts.Placeholder = string(p)
}

func WithPlaceholder(placeholder string) Option {
	return placeholderOption(placeholder)
}

type defaultValueOption time.Time

func (d defaultValueOption) Apply(opts *options.DateInputOptions) {
	opts.DefaultValue = (*time.Time)(&d)
}

func WithDefaultValue(value time.Time) Option {
	return defaultValueOption(value)
}

type requiredOption bool

func (r requiredOption) Apply(opts *options.DateInputOptions) {
	opts.Required = bool(r)
}

func WithRequired(required bool) Option {
	return requiredOption(required)
}

type disabledOption bool

func (d disabledOption) Apply(opts *options.DateInputOptions) {
	opts.Disabled = bool(d)
}

func WithDisabled(disabled bool) Option {
	return disabledOption(disabled)
}

type formatOption string

func (f formatOption) Apply(opts *options.DateInputOptions) {
	opts.Format = string(f)
}

func WithFormat(format string) Option {
	return formatOption(format)
}

type maxValueOption time.Time

func (m maxValueOption) Apply(opts *options.DateInputOptions) {
	opts.MaxValue = (*time.Time)(&m)
}

func WithMaxValue(value time.Time) Option {
	return maxValueOption(value)
}

type minValueOption time.Time

func (m minValueOption) Apply(opts *options.DateInputOptions) {
	opts.MinValue = (*time.Time)(&m)
}

func WithMinValue(value time.Time) Option {
	return minValueOption(value)
}

type locationOption time.Location

func (l locationOption) Apply(opts *options.DateInputOptions) {
	opts.Location = (*time.Location)(&l)
}

func WithLocation(location time.Location) Option {
	return locationOption(location)
}
</file>

<file path="datetimeinput/option.go">
package datetimeinput

import (
	"time"

	"github.com/trysourcetool/sourcetool-go/internal/options"
)

type Option interface {
	Apply(*options.DateTimeInputOptions)
}

type placeholderOption string

func (p placeholderOption) Apply(opts *options.DateTimeInputOptions) {
	opts.Placeholder = string(p)
}

func WithPlaceholder(placeholder string) Option {
	return placeholderOption(placeholder)
}

type defaultValueOption time.Time

func (d defaultValueOption) Apply(opts *options.DateTimeInputOptions) {
	opts.DefaultValue = (*time.Time)(&d)
}

func WithDefaultValue(value time.Time) Option {
	return defaultValueOption(value)
}

type requiredOption bool

func (r requiredOption) Apply(opts *options.DateTimeInputOptions) {
	opts.Required = bool(r)
}

func WithRequired(required bool) Option {
	return requiredOption(required)
}

type disabledOption bool

func (d disabledOption) Apply(opts *options.DateTimeInputOptions) {
	opts.Disabled = bool(d)
}

func WithDisabled(disabled bool) Option {
	return disabledOption(disabled)
}

type formatOption string

func (f formatOption) Apply(opts *options.DateTimeInputOptions) {
	opts.Format = string(f)
}

func WithFormat(format string) Option {
	return formatOption(format)
}

type maxValueOption time.Time

func (m maxValueOption) Apply(opts *options.DateTimeInputOptions) {
	opts.MaxValue = (*time.Time)(&m)
}

func WithMaxValue(value time.Time) Option {
	return maxValueOption(value)
}

type minValueOption time.Time

func (m minValueOption) Apply(opts *options.DateTimeInputOptions) {
	opts.MinValue = (*time.Time)(&m)
}

func WithMinValue(value time.Time) Option {
	return minValueOption(value)
}

type locationOption time.Location

func (l locationOption) Apply(opts *options.DateTimeInputOptions) {
	opts.Location = (*time.Location)(&l)
}

func WithLocation(location time.Location) Option {
	return locationOption(location)
}
</file>

<file path="form/option.go">
package form

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.FormOptions)
}

type buttonDisabledOption bool

func (b buttonDisabledOption) Apply(opts *options.FormOptions) {
	opts.ButtonDisabled = bool(b)
}

func WithButtonDisabled(buttonDisabled bool) Option {
	return buttonDisabledOption(buttonDisabled)
}

type clearOnSubmitOption bool

func (c clearOnSubmitOption) Apply(opts *options.FormOptions) {
	opts.ClearOnSubmit = bool(c)
}

func WithClearOnSubmit(clearOnSubmit bool) Option {
	return clearOnSubmitOption(clearOnSubmit)
}
</file>

<file path="internal/conv/conv.go">
package conv

import (
	"github.com/samber/lo"
)

func SafeValue[T comparable](in *T) T {
	if in == nil {
		return lo.Empty[T]()
	}
	return *in
}

func NilValue[T comparable](in T) *T {
	return &in
}
</file>

<file path="internal/conv/path.go">
package conv

func PathToInt32Slice(path []int) []int32 {
	result := make([]int32, len(path))
	for i, v := range path {
		result[i] = int32(v)
	}
	return result
}
</file>

<file path="internal/errdefs/errdefs.go">
package errdefs

import (
	"fmt"
	"runtime"
	"strings"
)

var (
	ErrInternal         = Exception("internal_server_error")
	ErrInvalidParameter = Exception("invalid_parameter")
	ErrSessionNotFound  = Exception("session_not_found")
	ErrPageNotFound     = Exception("page_not_found")
	ErrRunPage          = Exception("run_page_error")
)

type Meta []any

type Error struct {
	Title   string
	Message string
	Meta    map[string]any
	Frames  stackTrace
}

type ExceptionFunc func(error, ...any) error

func Exception(title string) ExceptionFunc {
	return func(err error, vals ...any) error {
		e := &Error{
			Title:   title,
			Message: err.Error(),
			Frames:  newFrame(callers()),
		}

		for _, any := range vals {
			switch any := any.(type) {
			case Meta:
				e.Meta = appendMeta(e.Meta, any...)
			}
		}

		x, ok := err.(*Error)
		if ok {
			e.Frames = x.Frames
		}

		return e
	}
}

func appendMeta(meta map[string]any, keyvals ...any) map[string]any {
	if meta == nil {
		meta = make(map[string]any)
	}
	var k string
	for n, v := range keyvals {
		if n%2 == 0 {
			k = fmt.Sprint(v)
		} else {
			meta[k] = v
		}
	}
	return meta
}

func (e *Error) Error() string {
	if e.Message == "" {
		return e.Title
	}

	return e.Message
}

func (e *Error) StackTrace() []string {
	if len(e.Frames) == 0 {
		return []string{}
	}
	strs := make([]string, len(e.Frames))
	for i, f := range e.Frames {
		strs[i] = f.String()
	}
	return strs
}

type frame struct {
	file           string
	lineNumber     int
	name           string
	programCounter uintptr
}

type stackTrace []*frame

func newFrame(pcs []uintptr) stackTrace {
	frames := []*frame{}

	for _, pc := range pcs {
		frame := &frame{programCounter: pc}
		fn := runtime.FuncForPC(pc)
		if fn == nil {
			return frames
		}
		frame.name = trimPkgName(fn)

		frame.file, frame.lineNumber = fn.FileLine(pc - 1)
		frames = append(frames, frame)
	}

	return frames
}

func (f *frame) String() string {
	return fmt.Sprintf("%s:%d %s", f.file, f.lineNumber, f.name)
}

func trimPkgName(fn *runtime.Func) string {
	name := fn.Name()
	if ld := strings.LastIndex(name, "."); ld >= 0 {
		name = name[ld+1:]
	}

	return name
}

func callers() []uintptr {
	const depth = 32
	var pcs [depth]uintptr
	n := runtime.Callers(3, pcs[:])

	return pcs[0 : n-2]
}
</file>

<file path="internal/logger/logger.go">
package logger

import (
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

var Log *zap.Logger

func Init() error {
	config := zap.NewProductionConfig()
	config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
	config.DisableStacktrace = true

	logger, err := config.Build()
	if err != nil {
		return err
	}

	Log = logger
	return nil
}

func Sync() error {
	return Log.Sync()
}
</file>

<file path="internal/options/button.go">
package options

type ButtonOptions struct {
	Label    string
	Disabled bool
}
</file>

<file path="internal/options/checkbox.go">
package options

type CheckboxOptions struct {
	Label        string
	DefaultValue bool
	Required     bool
	Disabled     bool
}
</file>

<file path="internal/options/checkboxgroup.go">
package options

type CheckboxGroupOptions struct {
	Label        string
	Options      []string
	DefaultValue []string
	Required     bool
	Disabled     bool
	FormatFunc   func(string, int) string
}
</file>

<file path="internal/options/columns.go">
package options

type ColumnsOptions struct {
	Columns int
	Weight  []int
}
</file>

<file path="internal/options/dateinput.go">
package options

import "time"

type DateInputOptions struct {
	Label        string
	Placeholder  string
	DefaultValue *time.Time
	Required     bool
	Disabled     bool
	Format       string
	MaxValue     *time.Time
	MinValue     *time.Time
	Location     *time.Location
}
</file>

<file path="internal/options/datetimeinput.go">
package options

import "time"

type DateTimeInputOptions struct {
	Label        string
	Placeholder  string
	DefaultValue *time.Time
	Required     bool
	Disabled     bool
	Format       string
	MaxValue     *time.Time
	MinValue     *time.Time
	Location     *time.Location
}
</file>

<file path="internal/options/form.go">
package options

type FormOptions struct {
	ButtonLabel    string
	ButtonDisabled bool
	ClearOnSubmit  bool
}
</file>

<file path="internal/options/markdown.go">
package options

type MarkdownOptions struct {
	Body string
}
</file>

<file path="internal/options/multiselect.go">
package options

type MultiSelectOptions struct {
	Label        string
	Options      []string
	Placeholder  string
	DefaultValue []string
	Required     bool
	Disabled     bool
	FormatFunc   func(string, int) string
}
</file>

<file path="internal/options/numberinput.go">
package options

type NumberInputOptions struct {
	Label        string
	Placeholder  string
	DefaultValue *float64
	Required     bool
	Disabled     bool
	MaxValue     *float64
	MinValue     *float64
}
</file>

<file path="internal/options/radio.go">
package options

type RadioOptions struct {
	Label        string
	Options      []string
	DefaultValue *string
	Required     bool
	Disabled     bool
	FormatFunc   func(string, int) string
}
</file>

<file path="internal/options/selectbox.go">
package options

type SelectboxOptions struct {
	Label        string
	Options      []string
	Placeholder  string
	DefaultValue *string
	Required     bool
	Disabled     bool
	FormatFunc   func(string, int) string
}
</file>

<file path="internal/options/table.go">
package options

type TableOptions struct {
	Header       string
	Description  string
	Height       *int32
	ColumnOrder  []string
	OnSelect     string
	RowSelection string
}
</file>

<file path="internal/options/textarea.go">
package options

type TextAreaOptions struct {
	Label        string
	Placeholder  string
	DefaultValue *string
	Required     bool
	Disabled     bool
	MaxLength    *int32
	MinLength    *int32
	MaxLines     *int32
	MinLines     *int32
	AutoResize   bool
}
</file>

<file path="internal/options/textinput.go">
package options

type TextInputOptions struct {
	Label        string
	Placeholder  string
	DefaultValue *string
	Required     bool
	Disabled     bool
	MaxLength    *int32
	MinLength    *int32
}
</file>

<file path="internal/options/timeinput.go">
package options

import "time"

type TimeInputOptions struct {
	Label        string
	Placeholder  string
	DefaultValue *time.Time
	Required     bool
	Disabled     bool
	Location     *time.Location
}
</file>

<file path="internal/pb/exception/v1/exception.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: exception/v1/exception.proto

package exceptionv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Exception struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Title         string                 `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	StackTrace    []string               `protobuf:"bytes,3,rep,name=stack_trace,json=stackTrace,proto3" json:"stack_trace,omitempty"`
	SessionId     string                 `protobuf:"bytes,4,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Exception) Reset() {
	*x = Exception{}
	mi := &file_exception_v1_exception_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Exception) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Exception) ProtoMessage() {}

func (x *Exception) ProtoReflect() protoreflect.Message {
	mi := &file_exception_v1_exception_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Exception.ProtoReflect.Descriptor instead.
func (*Exception) Descriptor() ([]byte, []int) {
	return file_exception_v1_exception_proto_rawDescGZIP(), []int{0}
}

func (x *Exception) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *Exception) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *Exception) GetStackTrace() []string {
	if x != nil {
		return x.StackTrace
	}
	return nil
}

func (x *Exception) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

var File_exception_v1_exception_proto protoreflect.FileDescriptor

const file_exception_v1_exception_proto_rawDesc = "" +
	"\n" +
	"\x1cexception/v1/exception.proto\x12\fexception.v1\"{\n" +
	"\tException\x12\x14\n" +
	"\x05title\x18\x01 \x01(\tR\x05title\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x1f\n" +
	"\vstack_trace\x18\x03 \x03(\tR\n" +
	"stackTrace\x12\x1d\n" +
	"\n" +
	"session_id\x18\x04 \x01(\tR\tsessionIdB\xc2\x01\n" +
	"\x10com.exception.v1B\x0eExceptionProtoP\x01ZKgithub.com/trysourcetool/sourcetool-go/internal/pb/exception/v1;exceptionv1\xa2\x02\x03EXX\xaa\x02\fException.V1\xca\x02\rException_\\V1\xe2\x02\x19Exception_\\V1\\GPBMetadata\xea\x02\rException::V1b\x06proto3"

var (
	file_exception_v1_exception_proto_rawDescOnce sync.Once
	file_exception_v1_exception_proto_rawDescData []byte
)

func file_exception_v1_exception_proto_rawDescGZIP() []byte {
	file_exception_v1_exception_proto_rawDescOnce.Do(func() {
		file_exception_v1_exception_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_exception_v1_exception_proto_rawDesc), len(file_exception_v1_exception_proto_rawDesc)))
	})
	return file_exception_v1_exception_proto_rawDescData
}

var file_exception_v1_exception_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_exception_v1_exception_proto_goTypes = []any{
	(*Exception)(nil), // 0: exception.v1.Exception
}
var file_exception_v1_exception_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_exception_v1_exception_proto_init() }
func file_exception_v1_exception_proto_init() {
	if File_exception_v1_exception_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_exception_v1_exception_proto_rawDesc), len(file_exception_v1_exception_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_exception_v1_exception_proto_goTypes,
		DependencyIndexes: file_exception_v1_exception_proto_depIdxs,
		MessageInfos:      file_exception_v1_exception_proto_msgTypes,
	}.Build()
	File_exception_v1_exception_proto = out.File
	file_exception_v1_exception_proto_goTypes = nil
	file_exception_v1_exception_proto_depIdxs = nil
}
</file>

<file path="internal/pb/page/v1/page.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: page/v1/page.proto

package pagev1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Page struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Route         string                 `protobuf:"bytes,3,opt,name=route,proto3" json:"route,omitempty"`
	Path          []int32                `protobuf:"varint,4,rep,packed,name=path,proto3" json:"path,omitempty"`
	Groups        []string               `protobuf:"bytes,5,rep,name=groups,proto3" json:"groups,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Page) Reset() {
	*x = Page{}
	mi := &file_page_v1_page_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Page) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Page) ProtoMessage() {}

func (x *Page) ProtoReflect() protoreflect.Message {
	mi := &file_page_v1_page_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Page.ProtoReflect.Descriptor instead.
func (*Page) Descriptor() ([]byte, []int) {
	return file_page_v1_page_proto_rawDescGZIP(), []int{0}
}

func (x *Page) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Page) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Page) GetRoute() string {
	if x != nil {
		return x.Route
	}
	return ""
}

func (x *Page) GetPath() []int32 {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *Page) GetGroups() []string {
	if x != nil {
		return x.Groups
	}
	return nil
}

var File_page_v1_page_proto protoreflect.FileDescriptor

const file_page_v1_page_proto_rawDesc = "" +
	"\n" +
	"\x12page/v1/page.proto\x12\apage.v1\"l\n" +
	"\x04Page\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05route\x18\x03 \x01(\tR\x05route\x12\x12\n" +
	"\x04path\x18\x04 \x03(\x05R\x04path\x12\x16\n" +
	"\x06groups\x18\x05 \x03(\tR\x06groupsB\x98\x01\n" +
	"\vcom.page.v1B\tPageProtoP\x01ZAgithub.com/trysourcetool/sourcetool-go/internal/pb/page/v1;pagev1\xa2\x02\x03PXX\xaa\x02\aPage.V1\xca\x02\aPage\\V1\xe2\x02\x13Page\\V1\\GPBMetadata\xea\x02\bPage::V1b\x06proto3"

var (
	file_page_v1_page_proto_rawDescOnce sync.Once
	file_page_v1_page_proto_rawDescData []byte
)

func file_page_v1_page_proto_rawDescGZIP() []byte {
	file_page_v1_page_proto_rawDescOnce.Do(func() {
		file_page_v1_page_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_page_v1_page_proto_rawDesc), len(file_page_v1_page_proto_rawDesc)))
	})
	return file_page_v1_page_proto_rawDescData
}

var file_page_v1_page_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_page_v1_page_proto_goTypes = []any{
	(*Page)(nil), // 0: page.v1.Page
}
var file_page_v1_page_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_page_v1_page_proto_init() }
func file_page_v1_page_proto_init() {
	if File_page_v1_page_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_page_v1_page_proto_rawDesc), len(file_page_v1_page_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_page_v1_page_proto_goTypes,
		DependencyIndexes: file_page_v1_page_proto_depIdxs,
		MessageInfos:      file_page_v1_page_proto_msgTypes,
	}.Build()
	File_page_v1_page_proto = out.File
	file_page_v1_page_proto_goTypes = nil
	file_page_v1_page_proto_depIdxs = nil
}
</file>

<file path="internal/pb/redis/v1/redis.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: redis/v1/redis.proto

package redisv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RedisMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Payload       []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RedisMessage) Reset() {
	*x = RedisMessage{}
	mi := &file_redis_v1_redis_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisMessage) ProtoMessage() {}

func (x *RedisMessage) ProtoReflect() protoreflect.Message {
	mi := &file_redis_v1_redis_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisMessage.ProtoReflect.Descriptor instead.
func (*RedisMessage) Descriptor() ([]byte, []int) {
	return file_redis_v1_redis_proto_rawDescGZIP(), []int{0}
}

func (x *RedisMessage) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *RedisMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

var File_redis_v1_redis_proto protoreflect.FileDescriptor

const file_redis_v1_redis_proto_rawDesc = "" +
	"\n" +
	"\x14redis/v1/redis.proto\x12\bredis.v1\"8\n" +
	"\fRedisMessage\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayloadB\xa0\x01\n" +
	"\fcom.redis.v1B\n" +
	"RedisProtoP\x01ZCgithub.com/trysourcetool/sourcetool-go/internal/pb/redis/v1;redisv1\xa2\x02\x03RXX\xaa\x02\bRedis.V1\xca\x02\bRedis\\V1\xe2\x02\x14Redis\\V1\\GPBMetadata\xea\x02\tRedis::V1b\x06proto3"

var (
	file_redis_v1_redis_proto_rawDescOnce sync.Once
	file_redis_v1_redis_proto_rawDescData []byte
)

func file_redis_v1_redis_proto_rawDescGZIP() []byte {
	file_redis_v1_redis_proto_rawDescOnce.Do(func() {
		file_redis_v1_redis_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_redis_v1_redis_proto_rawDesc), len(file_redis_v1_redis_proto_rawDesc)))
	})
	return file_redis_v1_redis_proto_rawDescData
}

var file_redis_v1_redis_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_redis_v1_redis_proto_goTypes = []any{
	(*RedisMessage)(nil), // 0: redis.v1.RedisMessage
}
var file_redis_v1_redis_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_redis_v1_redis_proto_init() }
func file_redis_v1_redis_proto_init() {
	if File_redis_v1_redis_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_redis_v1_redis_proto_rawDesc), len(file_redis_v1_redis_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_redis_v1_redis_proto_goTypes,
		DependencyIndexes: file_redis_v1_redis_proto_depIdxs,
		MessageInfos:      file_redis_v1_redis_proto_msgTypes,
	}.Build()
	File_redis_v1_redis_proto = out.File
	file_redis_v1_redis_proto_goTypes = nil
	file_redis_v1_redis_proto_depIdxs = nil
}
</file>

<file path="internal/pb/websocket/v1/message.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: websocket/v1/message.proto

package websocketv1

import (
	v1 "github.com/trysourcetool/sourcetool-go/internal/pb/exception/v1"
	v11 "github.com/trysourcetool/sourcetool-go/internal/pb/page/v1"
	v12 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ScriptFinished_Status int32

const (
	ScriptFinished_STATUS_UNSPECIFIED ScriptFinished_Status = 0
	ScriptFinished_STATUS_SUCCESS     ScriptFinished_Status = 1
	ScriptFinished_STATUS_FAILURE     ScriptFinished_Status = 2
)

// Enum value maps for ScriptFinished_Status.
var (
	ScriptFinished_Status_name = map[int32]string{
		0: "STATUS_UNSPECIFIED",
		1: "STATUS_SUCCESS",
		2: "STATUS_FAILURE",
	}
	ScriptFinished_Status_value = map[string]int32{
		"STATUS_UNSPECIFIED": 0,
		"STATUS_SUCCESS":     1,
		"STATUS_FAILURE":     2,
	}
)

func (x ScriptFinished_Status) Enum() *ScriptFinished_Status {
	p := new(ScriptFinished_Status)
	*p = x
	return p
}

func (x ScriptFinished_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ScriptFinished_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_websocket_v1_message_proto_enumTypes[0].Descriptor()
}

func (ScriptFinished_Status) Type() protoreflect.EnumType {
	return &file_websocket_v1_message_proto_enumTypes[0]
}

func (x ScriptFinished_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ScriptFinished_Status.Descriptor instead.
func (ScriptFinished_Status) EnumDescriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{8, 0}
}

type Message struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Id    string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to Type:
	//
	//	*Message_Exception
	//	*Message_InitializeHost
	//	*Message_InitializeHostCompleted
	//	*Message_InitializeClient
	//	*Message_InitializeClientCompleted
	//	*Message_RenderWidget
	//	*Message_RerunPage
	//	*Message_CloseSession
	//	*Message_ScriptFinished
	Type          isMessage_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Message) Reset() {
	*x = Message{}
	mi := &file_websocket_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Message) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Message) ProtoMessage() {}

func (x *Message) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Message.ProtoReflect.Descriptor instead.
func (*Message) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{0}
}

func (x *Message) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Message) GetType() isMessage_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *Message) GetException() *v1.Exception {
	if x != nil {
		if x, ok := x.Type.(*Message_Exception); ok {
			return x.Exception
		}
	}
	return nil
}

func (x *Message) GetInitializeHost() *InitializeHost {
	if x != nil {
		if x, ok := x.Type.(*Message_InitializeHost); ok {
			return x.InitializeHost
		}
	}
	return nil
}

func (x *Message) GetInitializeHostCompleted() *InitializeHostCompleted {
	if x != nil {
		if x, ok := x.Type.(*Message_InitializeHostCompleted); ok {
			return x.InitializeHostCompleted
		}
	}
	return nil
}

func (x *Message) GetInitializeClient() *InitializeClient {
	if x != nil {
		if x, ok := x.Type.(*Message_InitializeClient); ok {
			return x.InitializeClient
		}
	}
	return nil
}

func (x *Message) GetInitializeClientCompleted() *InitializeClientCompleted {
	if x != nil {
		if x, ok := x.Type.(*Message_InitializeClientCompleted); ok {
			return x.InitializeClientCompleted
		}
	}
	return nil
}

func (x *Message) GetRenderWidget() *RenderWidget {
	if x != nil {
		if x, ok := x.Type.(*Message_RenderWidget); ok {
			return x.RenderWidget
		}
	}
	return nil
}

func (x *Message) GetRerunPage() *RerunPage {
	if x != nil {
		if x, ok := x.Type.(*Message_RerunPage); ok {
			return x.RerunPage
		}
	}
	return nil
}

func (x *Message) GetCloseSession() *CloseSession {
	if x != nil {
		if x, ok := x.Type.(*Message_CloseSession); ok {
			return x.CloseSession
		}
	}
	return nil
}

func (x *Message) GetScriptFinished() *ScriptFinished {
	if x != nil {
		if x, ok := x.Type.(*Message_ScriptFinished); ok {
			return x.ScriptFinished
		}
	}
	return nil
}

type isMessage_Type interface {
	isMessage_Type()
}

type Message_Exception struct {
	Exception *v1.Exception `protobuf:"bytes,2,opt,name=exception,proto3,oneof"`
}

type Message_InitializeHost struct {
	InitializeHost *InitializeHost `protobuf:"bytes,3,opt,name=initialize_host,json=initializeHost,proto3,oneof"`
}

type Message_InitializeHostCompleted struct {
	InitializeHostCompleted *InitializeHostCompleted `protobuf:"bytes,4,opt,name=initialize_host_completed,json=initializeHostCompleted,proto3,oneof"`
}

type Message_InitializeClient struct {
	InitializeClient *InitializeClient `protobuf:"bytes,5,opt,name=initialize_client,json=initializeClient,proto3,oneof"`
}

type Message_InitializeClientCompleted struct {
	InitializeClientCompleted *InitializeClientCompleted `protobuf:"bytes,6,opt,name=initialize_client_completed,json=initializeClientCompleted,proto3,oneof"`
}

type Message_RenderWidget struct {
	RenderWidget *RenderWidget `protobuf:"bytes,7,opt,name=render_widget,json=renderWidget,proto3,oneof"`
}

type Message_RerunPage struct {
	RerunPage *RerunPage `protobuf:"bytes,8,opt,name=rerun_page,json=rerunPage,proto3,oneof"`
}

type Message_CloseSession struct {
	CloseSession *CloseSession `protobuf:"bytes,9,opt,name=close_session,json=closeSession,proto3,oneof"`
}

type Message_ScriptFinished struct {
	ScriptFinished *ScriptFinished `protobuf:"bytes,10,opt,name=script_finished,json=scriptFinished,proto3,oneof"`
}

func (*Message_Exception) isMessage_Type() {}

func (*Message_InitializeHost) isMessage_Type() {}

func (*Message_InitializeHostCompleted) isMessage_Type() {}

func (*Message_InitializeClient) isMessage_Type() {}

func (*Message_InitializeClientCompleted) isMessage_Type() {}

func (*Message_RenderWidget) isMessage_Type() {}

func (*Message_RerunPage) isMessage_Type() {}

func (*Message_CloseSession) isMessage_Type() {}

func (*Message_ScriptFinished) isMessage_Type() {}

type InitializeHost struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ApiKey        string                 `protobuf:"bytes,1,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty"`
	SdkName       string                 `protobuf:"bytes,2,opt,name=sdk_name,json=sdkName,proto3" json:"sdk_name,omitempty"`
	SdkVersion    string                 `protobuf:"bytes,3,opt,name=sdk_version,json=sdkVersion,proto3" json:"sdk_version,omitempty"`
	Pages         []*v11.Page            `protobuf:"bytes,4,rep,name=pages,proto3" json:"pages,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitializeHost) Reset() {
	*x = InitializeHost{}
	mi := &file_websocket_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitializeHost) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitializeHost) ProtoMessage() {}

func (x *InitializeHost) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitializeHost.ProtoReflect.Descriptor instead.
func (*InitializeHost) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{1}
}

func (x *InitializeHost) GetApiKey() string {
	if x != nil {
		return x.ApiKey
	}
	return ""
}

func (x *InitializeHost) GetSdkName() string {
	if x != nil {
		return x.SdkName
	}
	return ""
}

func (x *InitializeHost) GetSdkVersion() string {
	if x != nil {
		return x.SdkVersion
	}
	return ""
}

func (x *InitializeHost) GetPages() []*v11.Page {
	if x != nil {
		return x.Pages
	}
	return nil
}

type InitializeHostCompleted struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	HostInstanceId string                 `protobuf:"bytes,1,opt,name=host_instance_id,json=hostInstanceId,proto3" json:"host_instance_id,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *InitializeHostCompleted) Reset() {
	*x = InitializeHostCompleted{}
	mi := &file_websocket_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitializeHostCompleted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitializeHostCompleted) ProtoMessage() {}

func (x *InitializeHostCompleted) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitializeHostCompleted.ProtoReflect.Descriptor instead.
func (*InitializeHostCompleted) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{2}
}

func (x *InitializeHostCompleted) GetHostInstanceId() string {
	if x != nil {
		return x.HostInstanceId
	}
	return ""
}

type InitializeClient struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     *string                `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3,oneof" json:"session_id,omitempty"`
	PageId        string                 `protobuf:"bytes,2,opt,name=page_id,json=pageId,proto3" json:"page_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitializeClient) Reset() {
	*x = InitializeClient{}
	mi := &file_websocket_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitializeClient) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitializeClient) ProtoMessage() {}

func (x *InitializeClient) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitializeClient.ProtoReflect.Descriptor instead.
func (*InitializeClient) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{3}
}

func (x *InitializeClient) GetSessionId() string {
	if x != nil && x.SessionId != nil {
		return *x.SessionId
	}
	return ""
}

func (x *InitializeClient) GetPageId() string {
	if x != nil {
		return x.PageId
	}
	return ""
}

type InitializeClientCompleted struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitializeClientCompleted) Reset() {
	*x = InitializeClientCompleted{}
	mi := &file_websocket_v1_message_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitializeClientCompleted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitializeClientCompleted) ProtoMessage() {}

func (x *InitializeClientCompleted) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitializeClientCompleted.ProtoReflect.Descriptor instead.
func (*InitializeClientCompleted) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{4}
}

func (x *InitializeClientCompleted) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type RenderWidget struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	PageId        string                 `protobuf:"bytes,2,opt,name=page_id,json=pageId,proto3" json:"page_id,omitempty"`
	Path          []int32                `protobuf:"varint,3,rep,packed,name=path,proto3" json:"path,omitempty"`
	Widget        *v12.Widget            `protobuf:"bytes,4,opt,name=widget,proto3" json:"widget,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RenderWidget) Reset() {
	*x = RenderWidget{}
	mi := &file_websocket_v1_message_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenderWidget) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenderWidget) ProtoMessage() {}

func (x *RenderWidget) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenderWidget.ProtoReflect.Descriptor instead.
func (*RenderWidget) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{5}
}

func (x *RenderWidget) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *RenderWidget) GetPageId() string {
	if x != nil {
		return x.PageId
	}
	return ""
}

func (x *RenderWidget) GetPath() []int32 {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *RenderWidget) GetWidget() *v12.Widget {
	if x != nil {
		return x.Widget
	}
	return nil
}

type RerunPage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	PageId        string                 `protobuf:"bytes,2,opt,name=page_id,json=pageId,proto3" json:"page_id,omitempty"`
	States        []*v12.Widget          `protobuf:"bytes,3,rep,name=states,proto3" json:"states,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RerunPage) Reset() {
	*x = RerunPage{}
	mi := &file_websocket_v1_message_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RerunPage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RerunPage) ProtoMessage() {}

func (x *RerunPage) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RerunPage.ProtoReflect.Descriptor instead.
func (*RerunPage) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{6}
}

func (x *RerunPage) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *RerunPage) GetPageId() string {
	if x != nil {
		return x.PageId
	}
	return ""
}

func (x *RerunPage) GetStates() []*v12.Widget {
	if x != nil {
		return x.States
	}
	return nil
}

type CloseSession struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CloseSession) Reset() {
	*x = CloseSession{}
	mi := &file_websocket_v1_message_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloseSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloseSession) ProtoMessage() {}

func (x *CloseSession) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloseSession.ProtoReflect.Descriptor instead.
func (*CloseSession) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{7}
}

func (x *CloseSession) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type ScriptFinished struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Status        ScriptFinished_Status  `protobuf:"varint,2,opt,name=status,proto3,enum=websocket.v1.ScriptFinished_Status" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScriptFinished) Reset() {
	*x = ScriptFinished{}
	mi := &file_websocket_v1_message_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScriptFinished) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScriptFinished) ProtoMessage() {}

func (x *ScriptFinished) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScriptFinished.ProtoReflect.Descriptor instead.
func (*ScriptFinished) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{8}
}

func (x *ScriptFinished) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *ScriptFinished) GetStatus() ScriptFinished_Status {
	if x != nil {
		return x.Status
	}
	return ScriptFinished_STATUS_UNSPECIFIED
}

var File_websocket_v1_message_proto protoreflect.FileDescriptor

const file_websocket_v1_message_proto_rawDesc = "" +
	"\n" +
	"\x1awebsocket/v1/message.proto\x12\fwebsocket.v1\x1a\x1cexception/v1/exception.proto\x1a\x12page/v1/page.proto\x1a\x16widget/v1/widget.proto\"\xcb\x05\n" +
	"\aMessage\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x127\n" +
	"\texception\x18\x02 \x01(\v2\x17.exception.v1.ExceptionH\x00R\texception\x12G\n" +
	"\x0finitialize_host\x18\x03 \x01(\v2\x1c.websocket.v1.InitializeHostH\x00R\x0einitializeHost\x12c\n" +
	"\x19initialize_host_completed\x18\x04 \x01(\v2%.websocket.v1.InitializeHostCompletedH\x00R\x17initializeHostCompleted\x12M\n" +
	"\x11initialize_client\x18\x05 \x01(\v2\x1e.websocket.v1.InitializeClientH\x00R\x10initializeClient\x12i\n" +
	"\x1binitialize_client_completed\x18\x06 \x01(\v2'.websocket.v1.InitializeClientCompletedH\x00R\x19initializeClientCompleted\x12A\n" +
	"\rrender_widget\x18\a \x01(\v2\x1a.websocket.v1.RenderWidgetH\x00R\frenderWidget\x128\n" +
	"\n" +
	"rerun_page\x18\b \x01(\v2\x17.websocket.v1.RerunPageH\x00R\trerunPage\x12A\n" +
	"\rclose_session\x18\t \x01(\v2\x1a.websocket.v1.CloseSessionH\x00R\fcloseSession\x12G\n" +
	"\x0fscript_finished\x18\n" +
	" \x01(\v2\x1c.websocket.v1.ScriptFinishedH\x00R\x0escriptFinishedB\x06\n" +
	"\x04type\"\x8a\x01\n" +
	"\x0eInitializeHost\x12\x17\n" +
	"\aapi_key\x18\x01 \x01(\tR\x06apiKey\x12\x19\n" +
	"\bsdk_name\x18\x02 \x01(\tR\asdkName\x12\x1f\n" +
	"\vsdk_version\x18\x03 \x01(\tR\n" +
	"sdkVersion\x12#\n" +
	"\x05pages\x18\x04 \x03(\v2\r.page.v1.PageR\x05pages\"C\n" +
	"\x17InitializeHostCompleted\x12(\n" +
	"\x10host_instance_id\x18\x01 \x01(\tR\x0ehostInstanceId\"^\n" +
	"\x10InitializeClient\x12\"\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tH\x00R\tsessionId\x88\x01\x01\x12\x17\n" +
	"\apage_id\x18\x02 \x01(\tR\x06pageIdB\r\n" +
	"\v_session_id\":\n" +
	"\x19InitializeClientCompleted\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\"\x85\x01\n" +
	"\fRenderWidget\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x17\n" +
	"\apage_id\x18\x02 \x01(\tR\x06pageId\x12\x12\n" +
	"\x04path\x18\x03 \x03(\x05R\x04path\x12)\n" +
	"\x06widget\x18\x04 \x01(\v2\x11.widget.v1.WidgetR\x06widget\"n\n" +
	"\tRerunPage\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x17\n" +
	"\apage_id\x18\x02 \x01(\tR\x06pageId\x12)\n" +
	"\x06states\x18\x03 \x03(\v2\x11.widget.v1.WidgetR\x06states\"-\n" +
	"\fCloseSession\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\"\xb6\x01\n" +
	"\x0eScriptFinished\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12;\n" +
	"\x06status\x18\x02 \x01(\x0e2#.websocket.v1.ScriptFinished.StatusR\x06status\"H\n" +
	"\x06Status\x12\x16\n" +
	"\x12STATUS_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eSTATUS_SUCCESS\x10\x01\x12\x12\n" +
	"\x0eSTATUS_FAILURE\x10\x02B\xbe\x01\n" +
	"\x10com.websocket.v1B\fMessageProtoP\x01ZKgithub.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1;websocketv1\xa2\x02\x03WXX\xaa\x02\fWebsocket.V1\xca\x02\fWebsocket\\V1\xe2\x02\x18Websocket\\V1\\GPBMetadata\xea\x02\rWebsocket::V1b\x06proto3"

var (
	file_websocket_v1_message_proto_rawDescOnce sync.Once
	file_websocket_v1_message_proto_rawDescData []byte
)

func file_websocket_v1_message_proto_rawDescGZIP() []byte {
	file_websocket_v1_message_proto_rawDescOnce.Do(func() {
		file_websocket_v1_message_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_websocket_v1_message_proto_rawDesc), len(file_websocket_v1_message_proto_rawDesc)))
	})
	return file_websocket_v1_message_proto_rawDescData
}

var file_websocket_v1_message_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_websocket_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_websocket_v1_message_proto_goTypes = []any{
	(ScriptFinished_Status)(0),        // 0: websocket.v1.ScriptFinished.Status
	(*Message)(nil),                   // 1: websocket.v1.Message
	(*InitializeHost)(nil),            // 2: websocket.v1.InitializeHost
	(*InitializeHostCompleted)(nil),   // 3: websocket.v1.InitializeHostCompleted
	(*InitializeClient)(nil),          // 4: websocket.v1.InitializeClient
	(*InitializeClientCompleted)(nil), // 5: websocket.v1.InitializeClientCompleted
	(*RenderWidget)(nil),              // 6: websocket.v1.RenderWidget
	(*RerunPage)(nil),                 // 7: websocket.v1.RerunPage
	(*CloseSession)(nil),              // 8: websocket.v1.CloseSession
	(*ScriptFinished)(nil),            // 9: websocket.v1.ScriptFinished
	(*v1.Exception)(nil),              // 10: exception.v1.Exception
	(*v11.Page)(nil),                  // 11: page.v1.Page
	(*v12.Widget)(nil),                // 12: widget.v1.Widget
}
var file_websocket_v1_message_proto_depIdxs = []int32{
	10, // 0: websocket.v1.Message.exception:type_name -> exception.v1.Exception
	2,  // 1: websocket.v1.Message.initialize_host:type_name -> websocket.v1.InitializeHost
	3,  // 2: websocket.v1.Message.initialize_host_completed:type_name -> websocket.v1.InitializeHostCompleted
	4,  // 3: websocket.v1.Message.initialize_client:type_name -> websocket.v1.InitializeClient
	5,  // 4: websocket.v1.Message.initialize_client_completed:type_name -> websocket.v1.InitializeClientCompleted
	6,  // 5: websocket.v1.Message.render_widget:type_name -> websocket.v1.RenderWidget
	7,  // 6: websocket.v1.Message.rerun_page:type_name -> websocket.v1.RerunPage
	8,  // 7: websocket.v1.Message.close_session:type_name -> websocket.v1.CloseSession
	9,  // 8: websocket.v1.Message.script_finished:type_name -> websocket.v1.ScriptFinished
	11, // 9: websocket.v1.InitializeHost.pages:type_name -> page.v1.Page
	12, // 10: websocket.v1.RenderWidget.widget:type_name -> widget.v1.Widget
	12, // 11: websocket.v1.RerunPage.states:type_name -> widget.v1.Widget
	0,  // 12: websocket.v1.ScriptFinished.status:type_name -> websocket.v1.ScriptFinished.Status
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_websocket_v1_message_proto_init() }
func file_websocket_v1_message_proto_init() {
	if File_websocket_v1_message_proto != nil {
		return
	}
	file_websocket_v1_message_proto_msgTypes[0].OneofWrappers = []any{
		(*Message_Exception)(nil),
		(*Message_InitializeHost)(nil),
		(*Message_InitializeHostCompleted)(nil),
		(*Message_InitializeClient)(nil),
		(*Message_InitializeClientCompleted)(nil),
		(*Message_RenderWidget)(nil),
		(*Message_RerunPage)(nil),
		(*Message_CloseSession)(nil),
		(*Message_ScriptFinished)(nil),
	}
	file_websocket_v1_message_proto_msgTypes[3].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_websocket_v1_message_proto_rawDesc), len(file_websocket_v1_message_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_websocket_v1_message_proto_goTypes,
		DependencyIndexes: file_websocket_v1_message_proto_depIdxs,
		EnumInfos:         file_websocket_v1_message_proto_enumTypes,
		MessageInfos:      file_websocket_v1_message_proto_msgTypes,
	}.Build()
	File_websocket_v1_message_proto = out.File
	file_websocket_v1_message_proto_goTypes = nil
	file_websocket_v1_message_proto_depIdxs = nil
}
</file>

<file path="internal/pb/widget/v1/widget.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: widget/v1/widget.proto

package widgetv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Button struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         bool                   `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Disabled      bool                   `protobuf:"varint,3,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Button) Reset() {
	*x = Button{}
	mi := &file_widget_v1_widget_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Button) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Button) ProtoMessage() {}

func (x *Button) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Button.ProtoReflect.Descriptor instead.
func (*Button) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{0}
}

func (x *Button) GetValue() bool {
	if x != nil {
		return x.Value
	}
	return false
}

func (x *Button) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *Button) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type Checkbox struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         bool                   `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	DefaultValue  bool                   `protobuf:"varint,3,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,4,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,5,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Checkbox) Reset() {
	*x = Checkbox{}
	mi := &file_widget_v1_widget_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Checkbox) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Checkbox) ProtoMessage() {}

func (x *Checkbox) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Checkbox.ProtoReflect.Descriptor instead.
func (*Checkbox) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{1}
}

func (x *Checkbox) GetValue() bool {
	if x != nil {
		return x.Value
	}
	return false
}

func (x *Checkbox) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *Checkbox) GetDefaultValue() bool {
	if x != nil {
		return x.DefaultValue
	}
	return false
}

func (x *Checkbox) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *Checkbox) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type CheckboxGroup struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         []int32                `protobuf:"varint,1,rep,packed,name=value,proto3" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Options       []string               `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
	DefaultValue  []int32                `protobuf:"varint,4,rep,packed,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckboxGroup) Reset() {
	*x = CheckboxGroup{}
	mi := &file_widget_v1_widget_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckboxGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckboxGroup) ProtoMessage() {}

func (x *CheckboxGroup) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckboxGroup.ProtoReflect.Descriptor instead.
func (*CheckboxGroup) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{2}
}

func (x *CheckboxGroup) GetValue() []int32 {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *CheckboxGroup) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *CheckboxGroup) GetOptions() []string {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *CheckboxGroup) GetDefaultValue() []int32 {
	if x != nil {
		return x.DefaultValue
	}
	return nil
}

func (x *CheckboxGroup) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *CheckboxGroup) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type ColumnItem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Weight        float64                `protobuf:"fixed64,1,opt,name=weight,proto3" json:"weight,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ColumnItem) Reset() {
	*x = ColumnItem{}
	mi := &file_widget_v1_widget_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ColumnItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ColumnItem) ProtoMessage() {}

func (x *ColumnItem) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ColumnItem.ProtoReflect.Descriptor instead.
func (*ColumnItem) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{3}
}

func (x *ColumnItem) GetWeight() float64 {
	if x != nil {
		return x.Weight
	}
	return 0
}

type Columns struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Columns       int32                  `protobuf:"varint,1,opt,name=columns,proto3" json:"columns,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Columns) Reset() {
	*x = Columns{}
	mi := &file_widget_v1_widget_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Columns) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Columns) ProtoMessage() {}

func (x *Columns) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Columns.ProtoReflect.Descriptor instead.
func (*Columns) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{4}
}

func (x *Columns) GetColumns() int32 {
	if x != nil {
		return x.Columns
	}
	return 0
}

type DateInput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *string                `protobuf:"bytes,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Placeholder   string                 `protobuf:"bytes,3,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *string                `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	Format        string                 `protobuf:"bytes,7,opt,name=format,proto3" json:"format,omitempty"`
	MaxValue      string                 `protobuf:"bytes,8,opt,name=max_value,json=maxValue,proto3" json:"max_value,omitempty"`
	MinValue      string                 `protobuf:"bytes,9,opt,name=min_value,json=minValue,proto3" json:"min_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DateInput) Reset() {
	*x = DateInput{}
	mi := &file_widget_v1_widget_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DateInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DateInput) ProtoMessage() {}

func (x *DateInput) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DateInput.ProtoReflect.Descriptor instead.
func (*DateInput) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{5}
}

func (x *DateInput) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

func (x *DateInput) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *DateInput) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *DateInput) GetDefaultValue() string {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return ""
}

func (x *DateInput) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *DateInput) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *DateInput) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *DateInput) GetMaxValue() string {
	if x != nil {
		return x.MaxValue
	}
	return ""
}

func (x *DateInput) GetMinValue() string {
	if x != nil {
		return x.MinValue
	}
	return ""
}

type DateTimeInput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *string                `protobuf:"bytes,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Placeholder   string                 `protobuf:"bytes,3,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *string                `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	Format        string                 `protobuf:"bytes,7,opt,name=format,proto3" json:"format,omitempty"`
	MaxValue      string                 `protobuf:"bytes,8,opt,name=max_value,json=maxValue,proto3" json:"max_value,omitempty"`
	MinValue      string                 `protobuf:"bytes,9,opt,name=min_value,json=minValue,proto3" json:"min_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DateTimeInput) Reset() {
	*x = DateTimeInput{}
	mi := &file_widget_v1_widget_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DateTimeInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DateTimeInput) ProtoMessage() {}

func (x *DateTimeInput) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DateTimeInput.ProtoReflect.Descriptor instead.
func (*DateTimeInput) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{6}
}

func (x *DateTimeInput) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

func (x *DateTimeInput) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *DateTimeInput) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *DateTimeInput) GetDefaultValue() string {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return ""
}

func (x *DateTimeInput) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *DateTimeInput) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *DateTimeInput) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *DateTimeInput) GetMaxValue() string {
	if x != nil {
		return x.MaxValue
	}
	return ""
}

func (x *DateTimeInput) GetMinValue() string {
	if x != nil {
		return x.MinValue
	}
	return ""
}

type Form struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Value          bool                   `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	ButtonLabel    string                 `protobuf:"bytes,2,opt,name=button_label,json=buttonLabel,proto3" json:"button_label,omitempty"`
	ButtonDisabled bool                   `protobuf:"varint,3,opt,name=button_disabled,json=buttonDisabled,proto3" json:"button_disabled,omitempty"`
	ClearOnSubmit  bool                   `protobuf:"varint,4,opt,name=clear_on_submit,json=clearOnSubmit,proto3" json:"clear_on_submit,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Form) Reset() {
	*x = Form{}
	mi := &file_widget_v1_widget_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Form) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Form) ProtoMessage() {}

func (x *Form) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Form.ProtoReflect.Descriptor instead.
func (*Form) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{7}
}

func (x *Form) GetValue() bool {
	if x != nil {
		return x.Value
	}
	return false
}

func (x *Form) GetButtonLabel() string {
	if x != nil {
		return x.ButtonLabel
	}
	return ""
}

func (x *Form) GetButtonDisabled() bool {
	if x != nil {
		return x.ButtonDisabled
	}
	return false
}

func (x *Form) GetClearOnSubmit() bool {
	if x != nil {
		return x.ClearOnSubmit
	}
	return false
}

type Markdown struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Body          string                 `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Markdown) Reset() {
	*x = Markdown{}
	mi := &file_widget_v1_widget_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Markdown) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Markdown) ProtoMessage() {}

func (x *Markdown) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Markdown.ProtoReflect.Descriptor instead.
func (*Markdown) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{8}
}

func (x *Markdown) GetBody() string {
	if x != nil {
		return x.Body
	}
	return ""
}

type MultiSelect struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         []int32                `protobuf:"varint,1,rep,packed,name=value,proto3" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Options       []string               `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
	Placeholder   string                 `protobuf:"bytes,4,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  []int32                `protobuf:"varint,5,rep,packed,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,6,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,7,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiSelect) Reset() {
	*x = MultiSelect{}
	mi := &file_widget_v1_widget_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiSelect) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiSelect) ProtoMessage() {}

func (x *MultiSelect) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiSelect.ProtoReflect.Descriptor instead.
func (*MultiSelect) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{9}
}

func (x *MultiSelect) GetValue() []int32 {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *MultiSelect) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *MultiSelect) GetOptions() []string {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *MultiSelect) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *MultiSelect) GetDefaultValue() []int32 {
	if x != nil {
		return x.DefaultValue
	}
	return nil
}

func (x *MultiSelect) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *MultiSelect) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type NumberInput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *float64               `protobuf:"fixed64,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Placeholder   string                 `protobuf:"bytes,3,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *float64               `protobuf:"fixed64,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	MaxValue      *float64               `protobuf:"fixed64,7,opt,name=max_value,json=maxValue,proto3,oneof" json:"max_value,omitempty"`
	MinValue      *float64               `protobuf:"fixed64,8,opt,name=min_value,json=minValue,proto3,oneof" json:"min_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NumberInput) Reset() {
	*x = NumberInput{}
	mi := &file_widget_v1_widget_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NumberInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NumberInput) ProtoMessage() {}

func (x *NumberInput) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NumberInput.ProtoReflect.Descriptor instead.
func (*NumberInput) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{10}
}

func (x *NumberInput) GetValue() float64 {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return 0
}

func (x *NumberInput) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *NumberInput) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *NumberInput) GetDefaultValue() float64 {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return 0
}

func (x *NumberInput) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *NumberInput) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *NumberInput) GetMaxValue() float64 {
	if x != nil && x.MaxValue != nil {
		return *x.MaxValue
	}
	return 0
}

func (x *NumberInput) GetMinValue() float64 {
	if x != nil && x.MinValue != nil {
		return *x.MinValue
	}
	return 0
}

type Radio struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *int32                 `protobuf:"varint,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Options       []string               `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
	DefaultValue  *int32                 `protobuf:"varint,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Radio) Reset() {
	*x = Radio{}
	mi := &file_widget_v1_widget_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Radio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Radio) ProtoMessage() {}

func (x *Radio) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Radio.ProtoReflect.Descriptor instead.
func (*Radio) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{11}
}

func (x *Radio) GetValue() int32 {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return 0
}

func (x *Radio) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *Radio) GetOptions() []string {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *Radio) GetDefaultValue() int32 {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return 0
}

func (x *Radio) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *Radio) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type Selectbox struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *int32                 `protobuf:"varint,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Options       []string               `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
	Placeholder   string                 `protobuf:"bytes,4,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *int32                 `protobuf:"varint,5,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,6,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,7,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Selectbox) Reset() {
	*x = Selectbox{}
	mi := &file_widget_v1_widget_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Selectbox) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Selectbox) ProtoMessage() {}

func (x *Selectbox) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Selectbox.ProtoReflect.Descriptor instead.
func (*Selectbox) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{12}
}

func (x *Selectbox) GetValue() int32 {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return 0
}

func (x *Selectbox) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *Selectbox) GetOptions() []string {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *Selectbox) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *Selectbox) GetDefaultValue() int32 {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return 0
}

func (x *Selectbox) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *Selectbox) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type Table struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Data          []byte                 `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Value         *TableValue            `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Header        string                 `protobuf:"bytes,3,opt,name=header,proto3" json:"header,omitempty"`
	Description   string                 `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Height        *int32                 `protobuf:"varint,5,opt,name=height,proto3,oneof" json:"height,omitempty"`
	ColumnOrder   []string               `protobuf:"bytes,6,rep,name=column_order,json=columnOrder,proto3" json:"column_order,omitempty"`
	OnSelect      string                 `protobuf:"bytes,7,opt,name=on_select,json=onSelect,proto3" json:"on_select,omitempty"`
	RowSelection  string                 `protobuf:"bytes,8,opt,name=row_selection,json=rowSelection,proto3" json:"row_selection,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Table) Reset() {
	*x = Table{}
	mi := &file_widget_v1_widget_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Table) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Table) ProtoMessage() {}

func (x *Table) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Table.ProtoReflect.Descriptor instead.
func (*Table) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{13}
}

func (x *Table) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *Table) GetValue() *TableValue {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *Table) GetHeader() string {
	if x != nil {
		return x.Header
	}
	return ""
}

func (x *Table) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Table) GetHeight() int32 {
	if x != nil && x.Height != nil {
		return *x.Height
	}
	return 0
}

func (x *Table) GetColumnOrder() []string {
	if x != nil {
		return x.ColumnOrder
	}
	return nil
}

func (x *Table) GetOnSelect() string {
	if x != nil {
		return x.OnSelect
	}
	return ""
}

func (x *Table) GetRowSelection() string {
	if x != nil {
		return x.RowSelection
	}
	return ""
}

type TableValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Selection     *TableValueSelection   `protobuf:"bytes,1,opt,name=selection,proto3,oneof" json:"selection,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TableValue) Reset() {
	*x = TableValue{}
	mi := &file_widget_v1_widget_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TableValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TableValue) ProtoMessage() {}

func (x *TableValue) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TableValue.ProtoReflect.Descriptor instead.
func (*TableValue) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{14}
}

func (x *TableValue) GetSelection() *TableValueSelection {
	if x != nil {
		return x.Selection
	}
	return nil
}

type TableValueSelection struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Row           int32                  `protobuf:"varint,1,opt,name=row,proto3" json:"row,omitempty"`
	Rows          []int32                `protobuf:"varint,2,rep,packed,name=rows,proto3" json:"rows,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TableValueSelection) Reset() {
	*x = TableValueSelection{}
	mi := &file_widget_v1_widget_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TableValueSelection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TableValueSelection) ProtoMessage() {}

func (x *TableValueSelection) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TableValueSelection.ProtoReflect.Descriptor instead.
func (*TableValueSelection) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{15}
}

func (x *TableValueSelection) GetRow() int32 {
	if x != nil {
		return x.Row
	}
	return 0
}

func (x *TableValueSelection) GetRows() []int32 {
	if x != nil {
		return x.Rows
	}
	return nil
}

type TextArea struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *string                `protobuf:"bytes,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Placeholder   string                 `protobuf:"bytes,3,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *string                `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	MaxLength     *int32                 `protobuf:"varint,7,opt,name=max_length,json=maxLength,proto3,oneof" json:"max_length,omitempty"`
	MinLength     *int32                 `protobuf:"varint,8,opt,name=min_length,json=minLength,proto3,oneof" json:"min_length,omitempty"`
	MaxLines      *int32                 `protobuf:"varint,9,opt,name=max_lines,json=maxLines,proto3,oneof" json:"max_lines,omitempty"`
	MinLines      *int32                 `protobuf:"varint,10,opt,name=min_lines,json=minLines,proto3,oneof" json:"min_lines,omitempty"`
	AutoResize    bool                   `protobuf:"varint,11,opt,name=auto_resize,json=autoResize,proto3" json:"auto_resize,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TextArea) Reset() {
	*x = TextArea{}
	mi := &file_widget_v1_widget_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TextArea) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TextArea) ProtoMessage() {}

func (x *TextArea) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TextArea.ProtoReflect.Descriptor instead.
func (*TextArea) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{16}
}

func (x *TextArea) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

func (x *TextArea) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *TextArea) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *TextArea) GetDefaultValue() string {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return ""
}

func (x *TextArea) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *TextArea) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *TextArea) GetMaxLength() int32 {
	if x != nil && x.MaxLength != nil {
		return *x.MaxLength
	}
	return 0
}

func (x *TextArea) GetMinLength() int32 {
	if x != nil && x.MinLength != nil {
		return *x.MinLength
	}
	return 0
}

func (x *TextArea) GetMaxLines() int32 {
	if x != nil && x.MaxLines != nil {
		return *x.MaxLines
	}
	return 0
}

func (x *TextArea) GetMinLines() int32 {
	if x != nil && x.MinLines != nil {
		return *x.MinLines
	}
	return 0
}

func (x *TextArea) GetAutoResize() bool {
	if x != nil {
		return x.AutoResize
	}
	return false
}

type TextInput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *string                `protobuf:"bytes,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Placeholder   string                 `protobuf:"bytes,3,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *string                `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	MaxLength     *int32                 `protobuf:"varint,7,opt,name=max_length,json=maxLength,proto3,oneof" json:"max_length,omitempty"`
	MinLength     *int32                 `protobuf:"varint,8,opt,name=min_length,json=minLength,proto3,oneof" json:"min_length,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TextInput) Reset() {
	*x = TextInput{}
	mi := &file_widget_v1_widget_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TextInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TextInput) ProtoMessage() {}

func (x *TextInput) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TextInput.ProtoReflect.Descriptor instead.
func (*TextInput) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{17}
}

func (x *TextInput) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

func (x *TextInput) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *TextInput) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *TextInput) GetDefaultValue() string {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return ""
}

func (x *TextInput) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *TextInput) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *TextInput) GetMaxLength() int32 {
	if x != nil && x.MaxLength != nil {
		return *x.MaxLength
	}
	return 0
}

func (x *TextInput) GetMinLength() int32 {
	if x != nil && x.MinLength != nil {
		return *x.MinLength
	}
	return 0
}

type TimeInput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *string                `protobuf:"bytes,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Placeholder   string                 `protobuf:"bytes,3,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *string                `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TimeInput) Reset() {
	*x = TimeInput{}
	mi := &file_widget_v1_widget_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeInput) ProtoMessage() {}

func (x *TimeInput) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimeInput.ProtoReflect.Descriptor instead.
func (*TimeInput) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{18}
}

func (x *TimeInput) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

func (x *TimeInput) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *TimeInput) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *TimeInput) GetDefaultValue() string {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return ""
}

func (x *TimeInput) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *TimeInput) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type Widget struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Id    string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to Type:
	//
	//	*Widget_Button
	//	*Widget_Checkbox
	//	*Widget_CheckboxGroup
	//	*Widget_ColumnItem
	//	*Widget_Columns
	//	*Widget_DateInput
	//	*Widget_DateTimeInput
	//	*Widget_Form
	//	*Widget_Markdown
	//	*Widget_MultiSelect
	//	*Widget_NumberInput
	//	*Widget_Radio
	//	*Widget_Selectbox
	//	*Widget_Table
	//	*Widget_TextArea
	//	*Widget_TextInput
	//	*Widget_TimeInput
	Type          isWidget_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Widget) Reset() {
	*x = Widget{}
	mi := &file_widget_v1_widget_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Widget) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Widget) ProtoMessage() {}

func (x *Widget) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Widget.ProtoReflect.Descriptor instead.
func (*Widget) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{19}
}

func (x *Widget) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Widget) GetType() isWidget_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *Widget) GetButton() *Button {
	if x != nil {
		if x, ok := x.Type.(*Widget_Button); ok {
			return x.Button
		}
	}
	return nil
}

func (x *Widget) GetCheckbox() *Checkbox {
	if x != nil {
		if x, ok := x.Type.(*Widget_Checkbox); ok {
			return x.Checkbox
		}
	}
	return nil
}

func (x *Widget) GetCheckboxGroup() *CheckboxGroup {
	if x != nil {
		if x, ok := x.Type.(*Widget_CheckboxGroup); ok {
			return x.CheckboxGroup
		}
	}
	return nil
}

func (x *Widget) GetColumnItem() *ColumnItem {
	if x != nil {
		if x, ok := x.Type.(*Widget_ColumnItem); ok {
			return x.ColumnItem
		}
	}
	return nil
}

func (x *Widget) GetColumns() *Columns {
	if x != nil {
		if x, ok := x.Type.(*Widget_Columns); ok {
			return x.Columns
		}
	}
	return nil
}

func (x *Widget) GetDateInput() *DateInput {
	if x != nil {
		if x, ok := x.Type.(*Widget_DateInput); ok {
			return x.DateInput
		}
	}
	return nil
}

func (x *Widget) GetDateTimeInput() *DateTimeInput {
	if x != nil {
		if x, ok := x.Type.(*Widget_DateTimeInput); ok {
			return x.DateTimeInput
		}
	}
	return nil
}

func (x *Widget) GetForm() *Form {
	if x != nil {
		if x, ok := x.Type.(*Widget_Form); ok {
			return x.Form
		}
	}
	return nil
}

func (x *Widget) GetMarkdown() *Markdown {
	if x != nil {
		if x, ok := x.Type.(*Widget_Markdown); ok {
			return x.Markdown
		}
	}
	return nil
}

func (x *Widget) GetMultiSelect() *MultiSelect {
	if x != nil {
		if x, ok := x.Type.(*Widget_MultiSelect); ok {
			return x.MultiSelect
		}
	}
	return nil
}

func (x *Widget) GetNumberInput() *NumberInput {
	if x != nil {
		if x, ok := x.Type.(*Widget_NumberInput); ok {
			return x.NumberInput
		}
	}
	return nil
}

func (x *Widget) GetRadio() *Radio {
	if x != nil {
		if x, ok := x.Type.(*Widget_Radio); ok {
			return x.Radio
		}
	}
	return nil
}

func (x *Widget) GetSelectbox() *Selectbox {
	if x != nil {
		if x, ok := x.Type.(*Widget_Selectbox); ok {
			return x.Selectbox
		}
	}
	return nil
}

func (x *Widget) GetTable() *Table {
	if x != nil {
		if x, ok := x.Type.(*Widget_Table); ok {
			return x.Table
		}
	}
	return nil
}

func (x *Widget) GetTextArea() *TextArea {
	if x != nil {
		if x, ok := x.Type.(*Widget_TextArea); ok {
			return x.TextArea
		}
	}
	return nil
}

func (x *Widget) GetTextInput() *TextInput {
	if x != nil {
		if x, ok := x.Type.(*Widget_TextInput); ok {
			return x.TextInput
		}
	}
	return nil
}

func (x *Widget) GetTimeInput() *TimeInput {
	if x != nil {
		if x, ok := x.Type.(*Widget_TimeInput); ok {
			return x.TimeInput
		}
	}
	return nil
}

type isWidget_Type interface {
	isWidget_Type()
}

type Widget_Button struct {
	Button *Button `protobuf:"bytes,2,opt,name=button,proto3,oneof"`
}

type Widget_Checkbox struct {
	Checkbox *Checkbox `protobuf:"bytes,3,opt,name=checkbox,proto3,oneof"`
}

type Widget_CheckboxGroup struct {
	CheckboxGroup *CheckboxGroup `protobuf:"bytes,4,opt,name=checkbox_group,json=checkboxGroup,proto3,oneof"`
}

type Widget_ColumnItem struct {
	ColumnItem *ColumnItem `protobuf:"bytes,5,opt,name=column_item,json=columnItem,proto3,oneof"`
}

type Widget_Columns struct {
	Columns *Columns `protobuf:"bytes,6,opt,name=columns,proto3,oneof"`
}

type Widget_DateInput struct {
	DateInput *DateInput `protobuf:"bytes,7,opt,name=date_input,json=dateInput,proto3,oneof"`
}

type Widget_DateTimeInput struct {
	DateTimeInput *DateTimeInput `protobuf:"bytes,8,opt,name=date_time_input,json=dateTimeInput,proto3,oneof"`
}

type Widget_Form struct {
	Form *Form `protobuf:"bytes,9,opt,name=form,proto3,oneof"`
}

type Widget_Markdown struct {
	Markdown *Markdown `protobuf:"bytes,10,opt,name=markdown,proto3,oneof"`
}

type Widget_MultiSelect struct {
	MultiSelect *MultiSelect `protobuf:"bytes,11,opt,name=multi_select,json=multiSelect,proto3,oneof"`
}

type Widget_NumberInput struct {
	NumberInput *NumberInput `protobuf:"bytes,12,opt,name=number_input,json=numberInput,proto3,oneof"`
}

type Widget_Radio struct {
	Radio *Radio `protobuf:"bytes,13,opt,name=radio,proto3,oneof"`
}

type Widget_Selectbox struct {
	Selectbox *Selectbox `protobuf:"bytes,14,opt,name=selectbox,proto3,oneof"`
}

type Widget_Table struct {
	Table *Table `protobuf:"bytes,15,opt,name=table,proto3,oneof"`
}

type Widget_TextArea struct {
	TextArea *TextArea `protobuf:"bytes,16,opt,name=text_area,json=textArea,proto3,oneof"`
}

type Widget_TextInput struct {
	TextInput *TextInput `protobuf:"bytes,17,opt,name=text_input,json=textInput,proto3,oneof"`
}

type Widget_TimeInput struct {
	TimeInput *TimeInput `protobuf:"bytes,18,opt,name=time_input,json=timeInput,proto3,oneof"`
}

func (*Widget_Button) isWidget_Type() {}

func (*Widget_Checkbox) isWidget_Type() {}

func (*Widget_CheckboxGroup) isWidget_Type() {}

func (*Widget_ColumnItem) isWidget_Type() {}

func (*Widget_Columns) isWidget_Type() {}

func (*Widget_DateInput) isWidget_Type() {}

func (*Widget_DateTimeInput) isWidget_Type() {}

func (*Widget_Form) isWidget_Type() {}

func (*Widget_Markdown) isWidget_Type() {}

func (*Widget_MultiSelect) isWidget_Type() {}

func (*Widget_NumberInput) isWidget_Type() {}

func (*Widget_Radio) isWidget_Type() {}

func (*Widget_Selectbox) isWidget_Type() {}

func (*Widget_Table) isWidget_Type() {}

func (*Widget_TextArea) isWidget_Type() {}

func (*Widget_TextInput) isWidget_Type() {}

func (*Widget_TimeInput) isWidget_Type() {}

var File_widget_v1_widget_proto protoreflect.FileDescriptor

const file_widget_v1_widget_proto_rawDesc = "" +
	"\n" +
	"\x16widget/v1/widget.proto\x12\twidget.v1\"P\n" +
	"\x06Button\x12\x14\n" +
	"\x05value\x18\x01 \x01(\bR\x05value\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12\x1a\n" +
	"\bdisabled\x18\x03 \x01(\bR\bdisabled\"\x93\x01\n" +
	"\bCheckbox\x12\x14\n" +
	"\x05value\x18\x01 \x01(\bR\x05value\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12#\n" +
	"\rdefault_value\x18\x03 \x01(\bR\fdefaultValue\x12\x1a\n" +
	"\brequired\x18\x04 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x05 \x01(\bR\bdisabled\"\xb2\x01\n" +
	"\rCheckboxGroup\x12\x14\n" +
	"\x05value\x18\x01 \x03(\x05R\x05value\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12\x18\n" +
	"\aoptions\x18\x03 \x03(\tR\aoptions\x12#\n" +
	"\rdefault_value\x18\x04 \x03(\x05R\fdefaultValue\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabled\"$\n" +
	"\n" +
	"ColumnItem\x12\x16\n" +
	"\x06weight\x18\x01 \x01(\x01R\x06weight\"#\n" +
	"\aColumns\x12\x18\n" +
	"\acolumns\x18\x01 \x01(\x05R\acolumns\"\xae\x02\n" +
	"\tDateInput\x12\x19\n" +
	"\x05value\x18\x01 \x01(\tH\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12 \n" +
	"\vplaceholder\x18\x03 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\tH\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabled\x12\x16\n" +
	"\x06format\x18\a \x01(\tR\x06format\x12\x1b\n" +
	"\tmax_value\x18\b \x01(\tR\bmaxValue\x12\x1b\n" +
	"\tmin_value\x18\t \x01(\tR\bminValueB\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_value\"\xb2\x02\n" +
	"\rDateTimeInput\x12\x19\n" +
	"\x05value\x18\x01 \x01(\tH\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12 \n" +
	"\vplaceholder\x18\x03 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\tH\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabled\x12\x16\n" +
	"\x06format\x18\a \x01(\tR\x06format\x12\x1b\n" +
	"\tmax_value\x18\b \x01(\tR\bmaxValue\x12\x1b\n" +
	"\tmin_value\x18\t \x01(\tR\bminValueB\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_value\"\x90\x01\n" +
	"\x04Form\x12\x14\n" +
	"\x05value\x18\x01 \x01(\bR\x05value\x12!\n" +
	"\fbutton_label\x18\x02 \x01(\tR\vbuttonLabel\x12'\n" +
	"\x0fbutton_disabled\x18\x03 \x01(\bR\x0ebuttonDisabled\x12&\n" +
	"\x0fclear_on_submit\x18\x04 \x01(\bR\rclearOnSubmit\"\x1e\n" +
	"\bMarkdown\x12\x12\n" +
	"\x04body\x18\x01 \x01(\tR\x04body\"\xd2\x01\n" +
	"\vMultiSelect\x12\x14\n" +
	"\x05value\x18\x01 \x03(\x05R\x05value\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12\x18\n" +
	"\aoptions\x18\x03 \x03(\tR\aoptions\x12 \n" +
	"\vplaceholder\x18\x04 \x01(\tR\vplaceholder\x12#\n" +
	"\rdefault_value\x18\x05 \x03(\x05R\fdefaultValue\x12\x1a\n" +
	"\brequired\x18\x06 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\a \x01(\bR\bdisabled\"\xbe\x02\n" +
	"\vNumberInput\x12\x19\n" +
	"\x05value\x18\x01 \x01(\x01H\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12 \n" +
	"\vplaceholder\x18\x03 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\x01H\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabled\x12 \n" +
	"\tmax_value\x18\a \x01(\x01H\x02R\bmaxValue\x88\x01\x01\x12 \n" +
	"\tmin_value\x18\b \x01(\x01H\x03R\bminValue\x88\x01\x01B\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_valueB\f\n" +
	"\n" +
	"_max_valueB\f\n" +
	"\n" +
	"_min_value\"\xd0\x01\n" +
	"\x05Radio\x12\x19\n" +
	"\x05value\x18\x01 \x01(\x05H\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12\x18\n" +
	"\aoptions\x18\x03 \x03(\tR\aoptions\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\x05H\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabledB\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_value\"\xf6\x01\n" +
	"\tSelectbox\x12\x19\n" +
	"\x05value\x18\x01 \x01(\x05H\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12\x18\n" +
	"\aoptions\x18\x03 \x03(\tR\aoptions\x12 \n" +
	"\vplaceholder\x18\x04 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x05 \x01(\x05H\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x06 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\a \x01(\bR\bdisabledB\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_value\"\x8f\x02\n" +
	"\x05Table\x12\x12\n" +
	"\x04data\x18\x01 \x01(\fR\x04data\x12+\n" +
	"\x05value\x18\x02 \x01(\v2\x15.widget.v1.TableValueR\x05value\x12\x16\n" +
	"\x06header\x18\x03 \x01(\tR\x06header\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription\x12\x1b\n" +
	"\x06height\x18\x05 \x01(\x05H\x00R\x06height\x88\x01\x01\x12!\n" +
	"\fcolumn_order\x18\x06 \x03(\tR\vcolumnOrder\x12\x1b\n" +
	"\ton_select\x18\a \x01(\tR\bonSelect\x12#\n" +
	"\rrow_selection\x18\b \x01(\tR\frowSelectionB\t\n" +
	"\a_height\"]\n" +
	"\n" +
	"TableValue\x12A\n" +
	"\tselection\x18\x01 \x01(\v2\x1e.widget.v1.TableValueSelectionH\x00R\tselection\x88\x01\x01B\f\n" +
	"\n" +
	"_selection\";\n" +
	"\x13TableValueSelection\x12\x10\n" +
	"\x03row\x18\x01 \x01(\x05R\x03row\x12\x12\n" +
	"\x04rows\x18\x02 \x03(\x05R\x04rows\"\xc2\x03\n" +
	"\bTextArea\x12\x19\n" +
	"\x05value\x18\x01 \x01(\tH\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12 \n" +
	"\vplaceholder\x18\x03 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\tH\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabled\x12\"\n" +
	"\n" +
	"max_length\x18\a \x01(\x05H\x02R\tmaxLength\x88\x01\x01\x12\"\n" +
	"\n" +
	"min_length\x18\b \x01(\x05H\x03R\tminLength\x88\x01\x01\x12 \n" +
	"\tmax_lines\x18\t \x01(\x05H\x04R\bmaxLines\x88\x01\x01\x12 \n" +
	"\tmin_lines\x18\n" +
	" \x01(\x05H\x05R\bminLines\x88\x01\x01\x12\x1f\n" +
	"\vauto_resize\x18\v \x01(\bR\n" +
	"autoResizeB\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_valueB\r\n" +
	"\v_max_lengthB\r\n" +
	"\v_min_lengthB\f\n" +
	"\n" +
	"_max_linesB\f\n" +
	"\n" +
	"_min_lines\"\xc2\x02\n" +
	"\tTextInput\x12\x19\n" +
	"\x05value\x18\x01 \x01(\tH\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12 \n" +
	"\vplaceholder\x18\x03 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\tH\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabled\x12\"\n" +
	"\n" +
	"max_length\x18\a \x01(\x05H\x02R\tmaxLength\x88\x01\x01\x12\"\n" +
	"\n" +
	"min_length\x18\b \x01(\x05H\x03R\tminLength\x88\x01\x01B\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_valueB\r\n" +
	"\v_max_lengthB\r\n" +
	"\v_min_length\"\xdc\x01\n" +
	"\tTimeInput\x12\x19\n" +
	"\x05value\x18\x01 \x01(\tH\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12 \n" +
	"\vplaceholder\x18\x03 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\tH\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabledB\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_value\"\xa8\a\n" +
	"\x06Widget\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12+\n" +
	"\x06button\x18\x02 \x01(\v2\x11.widget.v1.ButtonH\x00R\x06button\x121\n" +
	"\bcheckbox\x18\x03 \x01(\v2\x13.widget.v1.CheckboxH\x00R\bcheckbox\x12A\n" +
	"\x0echeckbox_group\x18\x04 \x01(\v2\x18.widget.v1.CheckboxGroupH\x00R\rcheckboxGroup\x128\n" +
	"\vcolumn_item\x18\x05 \x01(\v2\x15.widget.v1.ColumnItemH\x00R\n" +
	"columnItem\x12.\n" +
	"\acolumns\x18\x06 \x01(\v2\x12.widget.v1.ColumnsH\x00R\acolumns\x125\n" +
	"\n" +
	"date_input\x18\a \x01(\v2\x14.widget.v1.DateInputH\x00R\tdateInput\x12B\n" +
	"\x0fdate_time_input\x18\b \x01(\v2\x18.widget.v1.DateTimeInputH\x00R\rdateTimeInput\x12%\n" +
	"\x04form\x18\t \x01(\v2\x0f.widget.v1.FormH\x00R\x04form\x121\n" +
	"\bmarkdown\x18\n" +
	" \x01(\v2\x13.widget.v1.MarkdownH\x00R\bmarkdown\x12;\n" +
	"\fmulti_select\x18\v \x01(\v2\x16.widget.v1.MultiSelectH\x00R\vmultiSelect\x12;\n" +
	"\fnumber_input\x18\f \x01(\v2\x16.widget.v1.NumberInputH\x00R\vnumberInput\x12(\n" +
	"\x05radio\x18\r \x01(\v2\x10.widget.v1.RadioH\x00R\x05radio\x124\n" +
	"\tselectbox\x18\x0e \x01(\v2\x14.widget.v1.SelectboxH\x00R\tselectbox\x12(\n" +
	"\x05table\x18\x0f \x01(\v2\x10.widget.v1.TableH\x00R\x05table\x122\n" +
	"\ttext_area\x18\x10 \x01(\v2\x13.widget.v1.TextAreaH\x00R\btextArea\x125\n" +
	"\n" +
	"text_input\x18\x11 \x01(\v2\x14.widget.v1.TextInputH\x00R\ttextInput\x125\n" +
	"\n" +
	"time_input\x18\x12 \x01(\v2\x14.widget.v1.TimeInputH\x00R\ttimeInputB\x06\n" +
	"\x04typeB\xa8\x01\n" +
	"\rcom.widget.v1B\vWidgetProtoP\x01ZEgithub.com/trysourcetool/sourcetool-go/internal/pb/widget/v1;widgetv1\xa2\x02\x03WXX\xaa\x02\tWidget.V1\xca\x02\tWidget\\V1\xe2\x02\x15Widget\\V1\\GPBMetadata\xea\x02\n" +
	"Widget::V1b\x06proto3"

var (
	file_widget_v1_widget_proto_rawDescOnce sync.Once
	file_widget_v1_widget_proto_rawDescData []byte
)

func file_widget_v1_widget_proto_rawDescGZIP() []byte {
	file_widget_v1_widget_proto_rawDescOnce.Do(func() {
		file_widget_v1_widget_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_widget_v1_widget_proto_rawDesc), len(file_widget_v1_widget_proto_rawDesc)))
	})
	return file_widget_v1_widget_proto_rawDescData
}

var file_widget_v1_widget_proto_msgTypes = make([]protoimpl.MessageInfo, 20)
var file_widget_v1_widget_proto_goTypes = []any{
	(*Button)(nil),              // 0: widget.v1.Button
	(*Checkbox)(nil),            // 1: widget.v1.Checkbox
	(*CheckboxGroup)(nil),       // 2: widget.v1.CheckboxGroup
	(*ColumnItem)(nil),          // 3: widget.v1.ColumnItem
	(*Columns)(nil),             // 4: widget.v1.Columns
	(*DateInput)(nil),           // 5: widget.v1.DateInput
	(*DateTimeInput)(nil),       // 6: widget.v1.DateTimeInput
	(*Form)(nil),                // 7: widget.v1.Form
	(*Markdown)(nil),            // 8: widget.v1.Markdown
	(*MultiSelect)(nil),         // 9: widget.v1.MultiSelect
	(*NumberInput)(nil),         // 10: widget.v1.NumberInput
	(*Radio)(nil),               // 11: widget.v1.Radio
	(*Selectbox)(nil),           // 12: widget.v1.Selectbox
	(*Table)(nil),               // 13: widget.v1.Table
	(*TableValue)(nil),          // 14: widget.v1.TableValue
	(*TableValueSelection)(nil), // 15: widget.v1.TableValueSelection
	(*TextArea)(nil),            // 16: widget.v1.TextArea
	(*TextInput)(nil),           // 17: widget.v1.TextInput
	(*TimeInput)(nil),           // 18: widget.v1.TimeInput
	(*Widget)(nil),              // 19: widget.v1.Widget
}
var file_widget_v1_widget_proto_depIdxs = []int32{
	14, // 0: widget.v1.Table.value:type_name -> widget.v1.TableValue
	15, // 1: widget.v1.TableValue.selection:type_name -> widget.v1.TableValueSelection
	0,  // 2: widget.v1.Widget.button:type_name -> widget.v1.Button
	1,  // 3: widget.v1.Widget.checkbox:type_name -> widget.v1.Checkbox
	2,  // 4: widget.v1.Widget.checkbox_group:type_name -> widget.v1.CheckboxGroup
	3,  // 5: widget.v1.Widget.column_item:type_name -> widget.v1.ColumnItem
	4,  // 6: widget.v1.Widget.columns:type_name -> widget.v1.Columns
	5,  // 7: widget.v1.Widget.date_input:type_name -> widget.v1.DateInput
	6,  // 8: widget.v1.Widget.date_time_input:type_name -> widget.v1.DateTimeInput
	7,  // 9: widget.v1.Widget.form:type_name -> widget.v1.Form
	8,  // 10: widget.v1.Widget.markdown:type_name -> widget.v1.Markdown
	9,  // 11: widget.v1.Widget.multi_select:type_name -> widget.v1.MultiSelect
	10, // 12: widget.v1.Widget.number_input:type_name -> widget.v1.NumberInput
	11, // 13: widget.v1.Widget.radio:type_name -> widget.v1.Radio
	12, // 14: widget.v1.Widget.selectbox:type_name -> widget.v1.Selectbox
	13, // 15: widget.v1.Widget.table:type_name -> widget.v1.Table
	16, // 16: widget.v1.Widget.text_area:type_name -> widget.v1.TextArea
	17, // 17: widget.v1.Widget.text_input:type_name -> widget.v1.TextInput
	18, // 18: widget.v1.Widget.time_input:type_name -> widget.v1.TimeInput
	19, // [19:19] is the sub-list for method output_type
	19, // [19:19] is the sub-list for method input_type
	19, // [19:19] is the sub-list for extension type_name
	19, // [19:19] is the sub-list for extension extendee
	0,  // [0:19] is the sub-list for field type_name
}

func init() { file_widget_v1_widget_proto_init() }
func file_widget_v1_widget_proto_init() {
	if File_widget_v1_widget_proto != nil {
		return
	}
	file_widget_v1_widget_proto_msgTypes[5].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[6].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[10].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[11].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[12].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[13].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[14].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[16].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[17].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[18].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[19].OneofWrappers = []any{
		(*Widget_Button)(nil),
		(*Widget_Checkbox)(nil),
		(*Widget_CheckboxGroup)(nil),
		(*Widget_ColumnItem)(nil),
		(*Widget_Columns)(nil),
		(*Widget_DateInput)(nil),
		(*Widget_DateTimeInput)(nil),
		(*Widget_Form)(nil),
		(*Widget_Markdown)(nil),
		(*Widget_MultiSelect)(nil),
		(*Widget_NumberInput)(nil),
		(*Widget_Radio)(nil),
		(*Widget_Selectbox)(nil),
		(*Widget_Table)(nil),
		(*Widget_TextArea)(nil),
		(*Widget_TextInput)(nil),
		(*Widget_TimeInput)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_widget_v1_widget_proto_rawDesc), len(file_widget_v1_widget_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   20,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_widget_v1_widget_proto_goTypes,
		DependencyIndexes: file_widget_v1_widget_proto_depIdxs,
		MessageInfos:      file_widget_v1_widget_proto_msgTypes,
	}.Build()
	File_widget_v1_widget_proto = out.File
	file_widget_v1_widget_proto_goTypes = nil
	file_widget_v1_widget_proto_depIdxs = nil
}
</file>

<file path="internal/session/state/button.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeButton WidgetType = "button"

type ButtonState struct {
	ID       uuid.UUID
	Value    bool
	Label    string
	Disabled bool
}

func (s *ButtonState) IsWidgetState()      {}
func (s *ButtonState) GetType() WidgetType { return WidgetTypeButton }
</file>

<file path="internal/session/state/checkbox.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeCheckbox WidgetType = "checkbox"

type CheckboxState struct {
	ID           uuid.UUID
	Label        string
	Value        bool
	DefaultValue bool
	Required     bool
	Disabled     bool
}

func (s *CheckboxState) IsWidgetState()      {}
func (s *CheckboxState) GetType() WidgetType { return WidgetTypeCheckbox }
</file>

<file path="internal/session/state/checkboxgroup.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeCheckboxGroup WidgetType = "checkboxGroup"

type CheckboxGroupState struct {
	ID           uuid.UUID
	Label        string
	Value        []int32
	Options      []string
	DefaultValue []int32
	Required     bool
	Disabled     bool
}

func (s *CheckboxGroupState) IsWidgetState()      {}
func (s *CheckboxGroupState) GetType() WidgetType { return WidgetTypeCheckboxGroup }
</file>

<file path="internal/session/state/columnitem.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeColumnItem WidgetType = "columnItem"

type ColumnItemState struct {
	ID     uuid.UUID
	Weight float64
}

func (s *ColumnItemState) IsWidgetState()      {}
func (s *ColumnItemState) GetType() WidgetType { return WidgetTypeColumnItem }
</file>

<file path="internal/session/state/columns.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeColumns WidgetType = "columns"

type ColumnsState struct {
	ID      uuid.UUID
	Columns int
}

func (s *ColumnsState) IsWidgetState()      {}
func (s *ColumnsState) GetType() WidgetType { return WidgetTypeColumns }
</file>

<file path="internal/session/state/dateinput.go">
package state

import (
	"time"

	"github.com/gofrs/uuid/v5"
)

const WidgetTypeDateInput WidgetType = "dateInput"

type DateInputState struct {
	ID           uuid.UUID
	Value        *time.Time
	Label        string
	Placeholder  string
	DefaultValue *time.Time
	Required     bool
	Disabled     bool
	Format       string
	MaxValue     *time.Time
	MinValue     *time.Time
	Location     *time.Location
}

func (s *DateInputState) IsWidgetState()      {}
func (s *DateInputState) GetType() WidgetType { return WidgetTypeDateInput }
</file>

<file path="internal/session/state/datetimeinput.go">
package state

import (
	"time"

	"github.com/gofrs/uuid/v5"
)

const WidgetTypeDateTimeInput WidgetType = "dateTimeInput"

type DateTimeInputState struct {
	ID           uuid.UUID
	Value        *time.Time
	Label        string
	Placeholder  string
	DefaultValue *time.Time
	Required     bool
	Disabled     bool
	Format       string
	MaxValue     *time.Time
	MinValue     *time.Time
	Location     *time.Location
}

func (s *DateTimeInputState) IsWidgetState()      {}
func (s *DateTimeInputState) GetType() WidgetType { return WidgetTypeDateTimeInput }
</file>

<file path="internal/session/state/form.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeForm WidgetType = "form"

type FormState struct {
	ID             uuid.UUID
	Value          bool
	ButtonLabel    string
	ButtonDisabled bool
	ClearOnSubmit  bool
}

func (s *FormState) IsWidgetState()      {}
func (s *FormState) GetType() WidgetType { return WidgetTypeForm }
</file>

<file path="internal/session/state/markdown.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeMarkdown WidgetType = "markdown"

type MarkdownState struct {
	ID   uuid.UUID
	Body string
}

func (s *MarkdownState) IsWidgetState()      {}
func (s *MarkdownState) GetType() WidgetType { return WidgetTypeMarkdown }
</file>

<file path="internal/session/state/multiselect.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeMultiSelect WidgetType = "multiSelect"

type MultiSelectState struct {
	ID           uuid.UUID
	Label        string
	Value        []int32
	Options      []string
	Placeholder  string
	DefaultValue []int32
	Required     bool
	Disabled     bool
}

func (s *MultiSelectState) IsWidgetState()      {}
func (s *MultiSelectState) GetType() WidgetType { return WidgetTypeMultiSelect }
</file>

<file path="internal/session/state/numberinput.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeNumberInput WidgetType = "numberInput"

type NumberInputState struct {
	ID           uuid.UUID
	Value        *float64
	Label        string
	Placeholder  string
	DefaultValue *float64
	Required     bool
	Disabled     bool
	MaxValue     *float64
	MinValue     *float64
}

func (s *NumberInputState) IsWidgetState()      {}
func (s *NumberInputState) GetType() WidgetType { return WidgetTypeNumberInput }
</file>

<file path="internal/session/state/radio.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeRadio WidgetType = "radio"

type RadioState struct {
	ID           uuid.UUID
	Label        string
	Value        *int32
	Options      []string
	DefaultValue *int32
	Required     bool
	Disabled     bool
}

func (s *RadioState) IsWidgetState()      {}
func (s *RadioState) GetType() WidgetType { return WidgetTypeRadio }
</file>

<file path="internal/session/state/selectbox.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeSelectbox WidgetType = "selectbox"

type SelectboxState struct {
	ID           uuid.UUID
	Label        string
	Value        *int32
	Options      []string
	Placeholder  string
	DefaultValue *int32
	Required     bool
	Disabled     bool
}

func (s *SelectboxState) IsWidgetState()      {}
func (s *SelectboxState) GetType() WidgetType { return WidgetTypeSelectbox }
</file>

<file path="internal/session/state/table.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeTable WidgetType = "table"

type TableState struct {
	ID           uuid.UUID
	Data         any
	Value        TableStateValue
	Header       string
	Description  string
	Height       *int32
	ColumnOrder  []string
	OnSelect     string
	RowSelection string
}

type TableStateValue struct {
	Selection *TableStateValueSelection
}

type TableStateValueSelection struct {
	Row  int32
	Rows []int32
}

func (s *TableState) IsWidgetState()      {}
func (s *TableState) GetType() WidgetType { return WidgetTypeTable }
</file>

<file path="internal/session/state/textarea.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeTextArea WidgetType = "textArea"

type TextAreaState struct {
	ID           uuid.UUID
	Value        *string
	Label        string
	Placeholder  string
	DefaultValue *string
	Required     bool
	Disabled     bool
	MaxLength    *int32
	MinLength    *int32
	MaxLines     *int32
	MinLines     *int32
	AutoResize   bool
}

func (s *TextAreaState) IsWidgetState()      {}
func (s *TextAreaState) GetType() WidgetType { return WidgetTypeTextArea }
</file>

<file path="internal/session/state/textinput.go">
package state

import "github.com/gofrs/uuid/v5"

const WidgetTypeTextInput WidgetType = "textInput"

type TextInputState struct {
	ID           uuid.UUID
	Value        *string
	Label        string
	Placeholder  string
	DefaultValue *string
	Required     bool
	Disabled     bool
	MaxLength    *int32
	MinLength    *int32
}

func (s *TextInputState) IsWidgetState()      {}
func (s *TextInputState) GetType() WidgetType { return WidgetTypeTextInput }
</file>

<file path="internal/session/state/timeinput.go">
package state

import (
	"time"

	"github.com/gofrs/uuid/v5"
)

const WidgetTypeTimeInput WidgetType = "timeInput"

type TimeInputState struct {
	ID           uuid.UUID
	Value        *time.Time
	Label        string
	Placeholder  string
	DefaultValue *time.Time
	Required     bool
	Disabled     bool
	Location     *time.Location
}

func (s *TimeInputState) IsWidgetState()      {}
func (s *TimeInputState) GetType() WidgetType { return WidgetTypeTimeInput }
</file>

<file path="internal/session/state/widget.go">
package state

type WidgetType string

func (w WidgetType) String() string {
	return string(w)
}
</file>

<file path="internal/session/session_test.go">
package session

import (
	"sync"
	"testing"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/session/state"
)

func TestSession_New(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())

	session := New(id, pageID)

	if session.ID != id {
		t.Errorf("session.ID = %v, want %v", session.ID, id)
	}
	if session.PageID != pageID {
		t.Errorf("session.PageID = %v, want %v", session.PageID, pageID)
	}
	if session.State == nil {
		t.Error("session.State is nil")
	}
}

func TestSessionManager_GetSetDelete(t *testing.T) {
	manager := NewSessionManager()
	id := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	session := New(id, pageID)

	// Test SetSession
	manager.SetSession(session)

	// Test GetSession
	got := manager.GetSession(id)
	if got != session {
		t.Errorf("GetSession(%v) = %v, want %v", id, got, session)
	}

	// Test DisconnectSession
	manager.DisconnectSession(id)
	got = manager.GetSession(id)
	if got != nil {
		t.Errorf("GetSession(%v) after delete = %v, want nil", id, got)
	}
}

func TestSessionManager_ConcurrentAccess(t *testing.T) {
	manager := NewSessionManager()
	var wg sync.WaitGroup
	numGoroutines := 10

	for i := 0; i < numGoroutines; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			id := uuid.Must(uuid.NewV4())
			pageID := uuid.Must(uuid.NewV4())
			session := New(id, pageID)

			manager.SetSession(session)
			got := manager.GetSession(id)
			if got != session {
				t.Errorf("GetSession(%v) = %v, want %v", id, got, session)
			}
			manager.DisconnectSession(id)
		}()
	}

	wg.Wait()
}

func TestState_SetGet(t *testing.T) {
	s := newState()
	id := uuid.Must(uuid.NewV4())

	radioState := &state.RadioState{
		ID:      id,
		Label:   "Test Radio",
		Options: []string{"Option 1", "Option 2"},
	}

	// Test Set and Get
	s.Set(id, radioState)
	got := s.Get(id)

	if got == nil {
		t.Fatal("Get() returned nil")
	}
	if got.GetType() != state.WidgetTypeRadio {
		t.Errorf("got.GetType() = %v, want %v", got.GetType(), state.WidgetTypeRadio)
	}
}

func TestState_ResetStates(t *testing.T) {
	s := newState()
	id := uuid.Must(uuid.NewV4())

	radioState := &state.RadioState{
		ID:      id,
		Label:   "Test Radio",
		Options: []string{"Option 1", "Option 2"},
	}

	s.Set(id, radioState)
	s.ResetStates()

	if got := s.Get(id); got != nil {
		t.Errorf("Get(%v) after reset = %v, want nil", id, got)
	}
}

func TestState_ResetButtons(t *testing.T) {
	s := newState()
	buttonID := uuid.Must(uuid.NewV4())
	formID := uuid.Must(uuid.NewV4())

	// Set initial states
	buttonState := &state.ButtonState{
		ID:    buttonID,
		Value: true,
	}
	formState := &state.FormState{
		ID:    formID,
		Value: true,
	}

	s.Set(buttonID, buttonState)
	s.Set(formID, formState)

	// Reset buttons
	s.ResetButtons()

	// Check button state
	if got := s.GetButton(buttonID); got.Value {
		t.Error("button value after reset = true, want false")
	}

	// Check form state
	if got := s.GetForm(formID); got.Value {
		t.Error("form value after reset = true, want false")
	}
}

func TestState_SetStates(t *testing.T) {
	s := newState()
	id1 := uuid.Must(uuid.NewV4())
	id2 := uuid.Must(uuid.NewV4())

	states := map[uuid.UUID]WidgetState{
		id1: &state.RadioState{
			ID:      id1,
			Label:   "Radio 1",
			Options: []string{"Option 1", "Option 2"},
		},
		id2: &state.RadioState{
			ID:      id2,
			Label:   "Radio 2",
			Options: []string{"Option 3", "Option 4"},
		},
	}

	s.SetStates(states)

	// Verify both states were set
	for id := range states {
		if got := s.Get(id); got == nil {
			t.Errorf("Get(%v) = nil, want non-nil", id)
		}
	}
}

func TestState_ConcurrentAccess(t *testing.T) {
	s := newState()
	var wg sync.WaitGroup
	numGoroutines := 10

	for i := 0; i < numGoroutines; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			id := uuid.Must(uuid.NewV4())

			radioState := &state.RadioState{
				ID:      id,
				Label:   "Test Radio",
				Options: []string{"Option 1", "Option 2"},
			}

			s.Set(id, radioState)
			got := s.Get(id)
			if got == nil {
				t.Errorf("Get(%v) = nil, want non-nil", id)
			}
		}()
	}

	wg.Wait()
}
</file>

<file path="internal/session/session.go">
package session

import (
	"sync"
	"time"

	"github.com/gofrs/uuid/v5"
)

const (
	// TTL for disconnected sessions.
	disconnectedSessionTTL = 2 * time.Minute
	// Maximum number of disconnected sessions to keep.
	maxDisconnectedSessions = 128
)

type disconnectedSession struct {
	session        *Session
	disconnectedAt time.Time
}

type Session struct {
	ID     uuid.UUID
	PageID uuid.UUID
	State  *State
}

func New(id, pageID uuid.UUID) *Session {
	return &Session{
		ID:     id,
		PageID: pageID,
		State:  newState(),
	}
}

type SessionManager struct {
	activeSessions       map[uuid.UUID]*Session
	disconnectedSessions map[uuid.UUID]*disconnectedSession
	mu                   sync.RWMutex
}

func NewSessionManager() *SessionManager {
	return &SessionManager{
		activeSessions:       make(map[uuid.UUID]*Session),
		disconnectedSessions: make(map[uuid.UUID]*disconnectedSession),
	}
}

func (s *SessionManager) removeOldestDisconnectedSession() {
	if len(s.disconnectedSessions) == 0 {
		return
	}

	var oldestID uuid.UUID
	var oldestTime time.Time

	for id, ds := range s.disconnectedSessions {
		if oldestTime.IsZero() || ds.disconnectedAt.Before(oldestTime) {
			oldestID = id
			oldestTime = ds.disconnectedAt
		}
	}

	delete(s.disconnectedSessions, oldestID)
}

func (s *SessionManager) GetSession(id uuid.UUID) *Session {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.activeSessions[id]
}

func (s *SessionManager) SetSession(session *Session) {
	s.mu.Lock()
	defer s.mu.Unlock()

	if ds, ok := s.disconnectedSessions[session.ID]; ok {
		session.State = ds.session.State
		delete(s.disconnectedSessions, session.ID)
	}

	s.activeSessions[session.ID] = session
}

func (s *SessionManager) DisconnectSession(id uuid.UUID) {
	s.mu.Lock()
	defer s.mu.Unlock()

	if session, ok := s.activeSessions[id]; ok {
		if len(s.disconnectedSessions) >= maxDisconnectedSessions {
			s.removeOldestDisconnectedSession()
		}

		s.disconnectedSessions[id] = &disconnectedSession{
			session:        session,
			disconnectedAt: time.Now(),
		}
		delete(s.activeSessions, id)

		go func(sessionID uuid.UUID) {
			time.Sleep(disconnectedSessionTTL)
			s.mu.Lock()
			delete(s.disconnectedSessions, sessionID)
			s.mu.Unlock()
		}(id)
	}
}
</file>

<file path="internal/session/state.go">
package session

import (
	"sync"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/session/state"
)

type WidgetState interface {
	IsWidgetState()
	GetType() state.WidgetType
}

type StateData map[uuid.UUID]WidgetState

type State struct {
	// data map[uuid.UUID]any // ui ID -> options state
	data StateData
	mu   sync.RWMutex
}

func newState() *State {
	return &State{
		data: make(map[uuid.UUID]WidgetState),
	}
}

func (s *State) Get(id uuid.UUID) WidgetState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	state, ok := s.data[id]
	if !ok {
		return nil
	}

	return state
}

func (s *State) GetTextInput(id uuid.UUID) *state.TextInputState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.TextInputState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetNumberInput(id uuid.UUID) *state.NumberInputState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.NumberInputState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetDateInput(id uuid.UUID) *state.DateInputState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.DateInputState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetDateTimeInput(id uuid.UUID) *state.DateTimeInputState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.DateTimeInputState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetTimeInput(id uuid.UUID) *state.TimeInputState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.TimeInputState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetSelectbox(id uuid.UUID) *state.SelectboxState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.SelectboxState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetMultiSelect(id uuid.UUID) *state.MultiSelectState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.MultiSelectState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetCheckbox(id uuid.UUID) *state.CheckboxState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.CheckboxState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetCheckboxGroup(id uuid.UUID) *state.CheckboxGroupState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.CheckboxGroupState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetRadio(id uuid.UUID) *state.RadioState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.RadioState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetTextArea(id uuid.UUID) *state.TextAreaState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.TextAreaState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetTable(id uuid.UUID) *state.TableState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.TableState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetButton(id uuid.UUID) *state.ButtonState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.ButtonState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetColumns(id uuid.UUID) *state.ColumnsState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.ColumnsState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetMarkdown(id uuid.UUID) *state.MarkdownState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.MarkdownState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) GetForm(id uuid.UUID) *state.FormState {
	s.mu.RLock()
	defer s.mu.RUnlock()

	st, ok := s.data[id]
	if !ok {
		return nil
	}

	v, ok := st.(*state.FormState)
	if !ok {
		return nil
	}

	return v
}

func (s *State) ResetStates() {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.data = make(map[uuid.UUID]WidgetState)
}

func (s *State) ResetButtons() {
	s.mu.Lock()
	defer s.mu.Unlock()
	for id, st := range s.data {
		switch st.GetType() {
		case state.WidgetTypeButton:
			buttonState, ok := st.(*state.ButtonState)
			if ok {
				buttonState.Value = false
				s.data[id] = buttonState
			}
		case state.WidgetTypeForm:
			formState, ok := st.(*state.FormState)
			if ok {
				formState.Value = false
				s.data[id] = formState
			}
		}
	}
}

func (s *State) Set(id uuid.UUID, state WidgetState) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.data[id] = state
}

func (s *State) SetStates(states map[uuid.UUID]WidgetState) {
	s.mu.Lock()
	defer s.mu.Unlock()
	for id, state := range states {
		s.data[id] = state
	}
}
</file>

<file path="internal/websocket/mock/websocket.go">
package mock

import (
	"sync"

	"google.golang.org/protobuf/proto"

	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	"github.com/trysourcetool/sourcetool-go/internal/websocket"
)

type client struct {
	handler    websocket.MessageHandlerFunc
	messages   []*websocketv1.Message
	messagesMu sync.RWMutex
	done       chan error
}

func NewClient() *client {
	return &client{
		messages: make([]*websocketv1.Message, 0),
		done:     make(chan error, 1),
	}
}

func (c *client) RegisterHandler(handler websocket.MessageHandlerFunc) {
	c.handler = handler
}

func (c *client) Enqueue(id string, payload proto.Message) {
	msg, err := websocket.NewMessage(id, payload)
	if err != nil {
		return
	}

	c.messagesMu.Lock()
	c.messages = append(c.messages, msg)
	c.messagesMu.Unlock()

	if c.handler != nil {
		c.handler(msg)
	}
}

func (c *client) EnqueueWithResponse(id string, payload proto.Message) (*websocketv1.Message, error) {
	msg, err := websocket.NewMessage(id, payload)
	if err != nil {
		return nil, err
	}

	c.messagesMu.Lock()
	c.messages = append(c.messages, msg)
	c.messagesMu.Unlock()

	return msg, nil
}

func (c *client) Messages() []*websocketv1.Message {
	c.messagesMu.RLock()
	defer c.messagesMu.RUnlock()
	return c.messages
}

func (c *client) Close() error {
	c.done <- nil
	return nil
}

func (c *client) Wait() error {
	return <-c.done
}
</file>

<file path="internal/websocket/types.go">
package websocket

import (
	"fmt"

	"google.golang.org/protobuf/proto"

	exceptionv1 "github.com/trysourcetool/sourcetool-go/internal/pb/exception/v1"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
)

type MessageHandlerFunc func(*websocketv1.Message) error

func unmarshalMessage(data []byte) (*websocketv1.Message, error) {
	var msg websocketv1.Message
	if err := proto.Unmarshal(data, &msg); err != nil {
		return nil, err
	}
	return &msg, nil
}

func marshalMessage(msg *websocketv1.Message) ([]byte, error) {
	return proto.Marshal(msg)
}

func NewMessage(id string, payload proto.Message) (*websocketv1.Message, error) {
	msg := &websocketv1.Message{
		Id: id,
	}

	switch p := payload.(type) {
	case *websocketv1.InitializeHost:
		msg.Type = &websocketv1.Message_InitializeHost{InitializeHost: p}
	case *websocketv1.InitializeClient:
		msg.Type = &websocketv1.Message_InitializeClient{InitializeClient: p}
	case *websocketv1.RenderWidget:
		msg.Type = &websocketv1.Message_RenderWidget{RenderWidget: p}
	case *websocketv1.RerunPage:
		msg.Type = &websocketv1.Message_RerunPage{RerunPage: p}
	case *websocketv1.CloseSession:
		msg.Type = &websocketv1.Message_CloseSession{CloseSession: p}
	case *websocketv1.ScriptFinished:
		msg.Type = &websocketv1.Message_ScriptFinished{ScriptFinished: p}
	case *exceptionv1.Exception:
		msg.Type = &websocketv1.Message_Exception{Exception: p}
	default:
		return nil, fmt.Errorf("unsupported message type: %T", payload)
	}

	return msg, nil
}
</file>

<file path="internal/websocket/websocket_test.go">
package websocket

import (
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/gorilla/websocket"

	"github.com/trysourcetool/sourcetool-go/internal/conv"
	"github.com/trysourcetool/sourcetool-go/internal/logger"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
)

func TestMain(m *testing.M) {
	if err := logger.Init(); err != nil {
		os.Exit(1)
	}
	os.Exit(m.Run())
}

var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool { return true },
}

type testServer struct {
	*httptest.Server
	connCh chan *websocket.Conn
}

func newTestServer() *testServer {
	connCh := make(chan *websocket.Conn, 1)
	s := &testServer{
		connCh: connCh,
	}

	s.Server = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Validate API key
		authHeader := r.Header.Get("Authorization")
		if !strings.HasPrefix(authHeader, "Bearer ") {
			http.Error(w, "unauthorized", http.StatusUnauthorized)
			return
		}

		conn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			return
		}

		s.connCh <- conn
	}))

	return s
}

func (s *testServer) WaitForConnection(t *testing.T) *websocket.Conn {
	t.Helper()
	select {
	case conn := <-s.connCh:
		return conn
	case <-time.After(time.Second):
		t.Fatal("timeout waiting for connection")
		return nil
	}
}

func TestNewClient(t *testing.T) {
	s := newTestServer()
	defer s.Close()

	wsURL := "ws" + strings.TrimPrefix(s.URL, "http")
	client, err := NewClient(Config{
		URL:    wsURL,
		APIKey: "test_api_key",
	})
	if err != nil {
		t.Fatalf("failed to create client: %v", err)
	}
	defer client.Close()

	conn := s.WaitForConnection(t)
	if conn == nil {
		t.Fatal("connection not established")
	}
}

func TestClient_MessageHandling(t *testing.T) {
	s := newTestServer()
	defer s.Close()

	wsURL := "ws" + strings.TrimPrefix(s.URL, "http")
	client, err := NewClient(Config{
		URL:    wsURL,
		APIKey: "test_api_key",
	})
	if err != nil {
		t.Fatalf("failed to create client: %v", err)
	}
	defer client.Close()

	conn := s.WaitForConnection(t)
	if conn == nil {
		t.Fatal("connection not established")
	}

	// Test message handler
	receivedCh := make(chan *websocketv1.Message, 1)
	client.RegisterHandler(func(msg *websocketv1.Message) error {
		receivedCh <- msg
		return nil
	})

	// Send test message
	testMsg := &websocketv1.Message{
		Id: "test_id",
		Type: &websocketv1.Message_InitializeClient{
			InitializeClient: &websocketv1.InitializeClient{
				SessionId: conv.NilValue("test_session"),
				PageId:    "test_page",
			},
		},
	}

	data, err := marshalMessage(testMsg)
	if err != nil {
		t.Fatalf("failed to marshal message: %v", err)
	}

	if err := conn.WriteMessage(websocket.TextMessage, data); err != nil {
		t.Fatalf("failed to write message: %v", err)
	}

	// Wait for message reception
	select {
	case msg := <-receivedCh:
		if msg.Id != testMsg.Id {
			t.Errorf("message ID = %v, want %v", msg.Id, testMsg.Id)
		}
		if _, ok := msg.Type.(*websocketv1.Message_InitializeClient); !ok {
			t.Errorf("unexpected message type: %T", msg.Type)
		}
	case <-time.After(time.Second):
		t.Fatal("timeout waiting for message")
	}
}

func TestClient_EnqueueWithResponse(t *testing.T) {
	s := newTestServer()
	defer s.Close()

	wsURL := "ws" + strings.TrimPrefix(s.URL, "http")
	instanceID := uuid.Must(uuid.NewV4())
	client, err := NewClient(Config{
		URL:        wsURL,
		APIKey:     "test_api_key",
		InstanceID: instanceID,
	})
	if err != nil {
		t.Fatalf("failed to create client: %v", err)
	}
	defer client.Close()

	conn := s.WaitForConnection(t)
	if conn == nil {
		t.Fatal("connection not established")
	}

	// Start goroutine to wait for response
	go func() {
		_, data, err := conn.ReadMessage()
		if err != nil {
			t.Errorf("failed to read message: %v", err)
			return
		}

		msg, err := unmarshalMessage(data)
		if err != nil {
			t.Errorf("failed to unmarshal message: %v", err)
			return
		}

		// Send response
		resp := &websocketv1.Message{
			Id: msg.Id,
			Type: &websocketv1.Message_InitializeHostCompleted{
				InitializeHostCompleted: &websocketv1.InitializeHostCompleted{
					HostInstanceId: "test_host_instance_id",
				},
			},
		}

		data, err = marshalMessage(resp)
		if err != nil {
			t.Errorf("failed to marshal response: %v", err)
			return
		}

		if err := conn.WriteMessage(websocket.TextMessage, data); err != nil {
			t.Errorf("failed to write response: %v", err)
		}
	}()

	// Send message and wait for response
	initHost := &websocketv1.InitializeHost{}
	resp, err := client.EnqueueWithResponse("test_id", initHost)
	if err != nil {
		t.Fatalf("failed to get response: %v", err)
	}

	if completed, ok := resp.Type.(*websocketv1.Message_InitializeHostCompleted); !ok {
		t.Errorf("unexpected response type: %T", resp.Type)
	} else if completed.InitializeHostCompleted.HostInstanceId != "test_host_instance_id" {
		t.Errorf("unexpected host instance id: got %s, want test_host_instance_id", completed.InitializeHostCompleted.HostInstanceId)
	}
}

func TestClient_Reconnection(t *testing.T) {
	s := newTestServer()
	defer s.Close()

	reconnected := make(chan struct{})
	wsURL := "ws" + strings.TrimPrefix(s.URL, "http")
	instanceID := uuid.Must(uuid.NewV4())
	client, err := NewClient(Config{
		URL:            wsURL,
		APIKey:         "test_api_key",
		InstanceID:     instanceID,
		PingInterval:   100 * time.Millisecond,
		ReconnectDelay: 100 * time.Millisecond,
		OnReconnected: func() {
			reconnected <- struct{}{}
		},
	})
	if err != nil {
		t.Fatalf("failed to create client: %v", err)
	}
	defer client.Close()

	// Verify initial connection
	conn := s.WaitForConnection(t)
	if conn == nil {
		t.Fatal("initial connection not established")
	}

	// Disconnect connection
	conn.Close()

	// Wait for reconnection
	select {
	case <-reconnected:
		// Reconnection successful
	case <-time.After(time.Second):
		t.Fatal("timeout waiting for reconnection")
	}

	// Verify new connection
	conn = s.WaitForConnection(t)
	if conn == nil {
		t.Fatal("reconnection not established")
	}
}
</file>

<file path="internal/websocket/websocket.go">
package websocket

import (
	"context"
	"crypto/rand"
	"fmt"
	"math/big"
	"net/http"
	"sync"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/gorilla/websocket"
	"go.uber.org/zap"
	"google.golang.org/protobuf/proto"

	"github.com/trysourcetool/sourcetool-go/internal/logger"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
)

const (
	// Time constraints.
	minPingInterval   = 100 * time.Millisecond
	maxPingInterval   = 30 * time.Second
	minReconnectDelay = 100 * time.Millisecond

	// Queue constraints.
	minQueueSize = 50
	maxQueueSize = 1000

	// Default values.
	defaultPingInterval   = time.Second
	defaultReconnectDelay = time.Second
	defaultQueueSize      = 250

	// Reconnection constants.
	initialReconnectDelay = 500 * time.Millisecond
	maxReconnectDelay     = 30 * time.Second
	// 4s * 2^13 ≈ 1 hour.
	maxReconnectAttempts = 26 // Approximately 1 hour of reconnection attempts

	// Message sending constants.
	maxMessageRetries = 3
	messageRetryDelay = 100 * time.Millisecond
	shutdownTimeout   = 5 * time.Second
)

func validateConfig(config Config) error {
	// Minimum values
	if config.PingInterval < minPingInterval {
		return fmt.Errorf("ping interval must be at least %v", minPingInterval)
	}
	if config.ReconnectDelay < minReconnectDelay {
		return fmt.Errorf("reconnect delay must be at least %v", minReconnectDelay)
	}
	if config.QueueSize < minQueueSize {
		return fmt.Errorf("queue size must be at least %d", minQueueSize)
	}

	// Maximum values
	if config.PingInterval > maxPingInterval {
		return fmt.Errorf("ping interval must not exceed %v", maxPingInterval)
	}
	if config.QueueSize > maxQueueSize {
		return fmt.Errorf("queue size must not exceed %d", maxQueueSize)
	}

	return nil
}

func setConfigDefaults(config *Config) {
	if config.PingInterval == 0 {
		config.PingInterval = defaultPingInterval
	}
	if config.ReconnectDelay == 0 {
		config.ReconnectDelay = defaultReconnectDelay
	}
	if config.QueueSize == 0 {
		config.QueueSize = defaultQueueSize
	}
}

type Client interface {
	RegisterHandler(MessageHandlerFunc)
	Enqueue(string, proto.Message)
	EnqueueWithResponse(string, proto.Message) (*websocketv1.Message, error)
	Close() error
	Wait() error
}

type Config struct {
	URL            string
	APIKey         string
	InstanceID     uuid.UUID
	PingInterval   time.Duration
	ReconnectDelay time.Duration
	QueueSize      int
	OnReconnecting func()
	OnReconnected  func()
}

type client struct {
	config Config
	dialer *websocket.Dialer

	conn   *websocket.Conn
	connMu sync.RWMutex

	messageQueue chan *websocketv1.Message
	done         chan error

	responses map[string]chan *websocketv1.Message
	respMu    sync.RWMutex

	handler   MessageHandlerFunc
	handlerMu sync.RWMutex

	// Goroutine management
	stop chan struct{}
	wg   sync.WaitGroup

	// Shutdown state
	shutdownOnce sync.Once
}

func NewClient(config Config) (Client, error) {
	// Set defaults for zero values
	setConfigDefaults(&config)

	// Validate configuration
	if err := validateConfig(config); err != nil {
		return nil, fmt.Errorf("invalid configuration: %w", err)
	}

	c := &client{
		config:       config,
		messageQueue: make(chan *websocketv1.Message, config.QueueSize),
		done:         make(chan error, 1),
		dialer:       websocket.DefaultDialer,
		responses:    make(map[string]chan *websocketv1.Message),
		stop:         make(chan struct{}),
	}

	if err := c.connect(); err != nil {
		return nil, err
	}

	c.wg.Add(3)
	go c.pingPongLoop()
	go c.readMessages()
	go c.sendEnqueuedMessagesLoop()

	return c, nil
}

func (c *client) RegisterHandler(handler MessageHandlerFunc) {
	c.handlerMu.Lock()
	defer c.handlerMu.Unlock()
	c.handler = handler
}

func (c *client) handleMessage(msg *websocketv1.Message) error {
	// Handle responses
	c.respMu.RLock()
	respChan, exists := c.responses[msg.Id]
	c.respMu.RUnlock()

	if exists {
		respChan <- msg
		return nil
	}

	// Handle calls
	c.handlerMu.RLock()
	handler := c.handler
	c.handlerMu.RUnlock()

	if handler == nil {
		return fmt.Errorf("no message handler registered")
	}

	return handler(msg)
}

func (c *client) connect() error {
	header := http.Header{}
	header.Set("Authorization", fmt.Sprintf("Bearer %s", c.config.APIKey))
	header.Set("X-Instance-Id", c.config.InstanceID.String())

	conn, _, err := c.dialer.Dial(c.config.URL, header)
	if err != nil {
		return err
	}

	conn.SetPongHandler(func(string) error {
		return conn.SetReadDeadline(time.Now().Add(c.config.PingInterval * 2))
	})

	c.connMu.Lock()
	c.conn = conn
	c.connMu.Unlock()

	return nil
}

func (c *client) reconnect() error {
	if c.config.OnReconnecting != nil {
		c.config.OnReconnecting()
	}

	attempt := 0
	lastSuccessTime := time.Now()

	for {
		// Calculate delay with exponential backoff, but cap it
		delay := min(initialReconnectDelay*time.Duration(1<<uint(attempt)), maxReconnectDelay)

		// Add some jitter to prevent thundering herd
		// Use crypto/rand for better randomness
		maxJitter := int64(delay / 4)
		if maxJitter > 0 {
			jitterBig, err := rand.Int(rand.Reader, big.NewInt(maxJitter))
			if err == nil {
				delay += time.Duration(jitterBig.Int64())
			}
		}

		// Log reconnection attempt with more context
		logger.Log.Info("attempting to reconnect",
			zap.Int("attempt", attempt+1),
			zap.Duration("delay", delay),
			zap.String("instance_id", c.config.InstanceID.String()),
			zap.Time("last_success", lastSuccessTime),
			zap.Duration("time_since_last_success", time.Since(lastSuccessTime)))

		// Try to connect
		err := c.connect()
		if err == nil {
			logger.Log.Info("reconnection successful",
				zap.Int("attempts", attempt+1),
				zap.String("instance_id", c.config.InstanceID.String()),
				zap.Duration("total_downtime", time.Since(lastSuccessTime)))

			if c.config.OnReconnected != nil {
				c.config.OnReconnected()
			}
			return nil
		}

		attempt++

		// Check if we should stop trying
		if attempt >= maxReconnectAttempts {
			// If less than an hour has passed since the last successful connection, stop trying
			if time.Since(lastSuccessTime) < time.Hour {
				logger.Log.Error("max reconnection attempts reached within an hour",
					zap.Error(err),
					zap.String("instance_id", c.config.InstanceID.String()),
					zap.Duration("total_downtime", time.Since(lastSuccessTime)))
				return fmt.Errorf("failed to reconnect after %d attempts within an hour: %w", maxReconnectAttempts, err)
			}

			// If more than an hour has passed, continue reconnection attempts
			logger.Log.Warn("continuing reconnection attempts after an hour",
				zap.Error(err),
				zap.String("instance_id", c.config.InstanceID.String()),
				zap.Duration("total_downtime", time.Since(lastSuccessTime)))
			attempt = 0 // Reset counter
			continue
		}

		// Wait before next attempt
		select {
		case <-c.stop:
			logger.Log.Info("reconnection canceled during shutdown",
				zap.String("instance_id", c.config.InstanceID.String()),
				zap.Duration("total_downtime", time.Since(lastSuccessTime)))
			return nil
		case <-time.After(delay):
			continue
		}
	}
}

func (c *client) pingPongLoop() {
	defer c.wg.Done() // Signal completion on exit
	ticker := time.NewTicker(c.config.PingInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			c.connMu.RLock()
			conn := c.conn
			c.connMu.RUnlock()

			if conn == nil {
				return
			}

			if err := conn.WriteControl(websocket.PingMessage, []byte{}, time.Now().Add(10*time.Second)); err != nil {
				logger.Log.Error("ping failed", zap.Error(err))
				c.connMu.Lock()
				if c.conn == conn {
					conn.Close()
					c.conn = nil
				}
				c.connMu.Unlock()

				go func() {
					if err := c.reconnect(); err != nil {
						logger.Log.Error("reconnection failed", zap.Error(err))
					}
				}()
				return
			}
		case <-c.stop:
			logger.Log.Debug("pingPongLoop stopping")
			return
		}
	}
}

func (c *client) readMessages() {
	defer c.wg.Done()
	for {
		select {
		case <-c.stop:
			logger.Log.Debug("readMessages stopping")
			return
		default:
			var data []byte
			c.connMu.RLock()
			conn := c.conn
			c.connMu.RUnlock()

			if conn == nil {
				select {
				case <-c.stop:
					logger.Log.Debug("readMessages stopping (conn nil)")
					return
				case <-time.After(100 * time.Millisecond):
					continue
				}
			}

			_, data, err := conn.ReadMessage()
			if err != nil {
				select {
				case <-c.stop:
					logger.Log.Debug("readMessages stopping (read error during shutdown)")
					return
				default:
					if websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) {
						logger.Log.Info("connection closed normally",
							zap.String("instance_id", c.config.InstanceID.String()))
						return
					}

					logger.Log.Warn("read error, initiating reconnection",
						zap.Error(err),
						zap.String("instance_id", c.config.InstanceID.String()))

					c.connMu.Lock()
					if c.conn == conn {
						conn.Close()
						c.conn = nil
					}
					c.connMu.Unlock()

					// Start reconnection in a separate goroutine
					go func() {
						if err := c.reconnect(); err != nil {
							logger.Log.Error("reconnection failed",
								zap.Error(err),
								zap.String("instance_id", c.config.InstanceID.String()))
						}
					}()
					continue
				}
			}

			msg, err := unmarshalMessage(data)
			if err != nil {
				logger.Log.Error("error unmarshaling message",
					zap.Error(err),
					zap.String("instance_id", c.config.InstanceID.String()))
				continue
			}

			if err := c.handleMessage(msg); err != nil {
				logger.Log.Error("error handling message",
					zap.Error(err),
					zap.String("instance_id", c.config.InstanceID.String()))
			}
		}
	}
}

func (c *client) sendEnqueuedMessagesLoop() {
	defer c.wg.Done()

	const batchInterval = 10 * time.Millisecond
	var messageBuffer []*websocketv1.Message
	var retryBuffer []*websocketv1.Message

	for {
		select {
		case <-c.stop:
			logger.Log.Debug("sendEnqueuedMessagesLoop stopping")
			if err := c.sendRemainingMessages(messageBuffer, retryBuffer); err != nil {
				logger.Log.Error("failed to send remaining messages during shutdown",
					zap.Error(err),
					zap.String("instance_id", c.config.InstanceID.String()))
			}
			return
		case msg, ok := <-c.messageQueue:
			if !ok {
				logger.Log.Debug("sendEnqueuedMessagesLoop stopping (queue closed)")
				if err := c.sendRemainingMessages(messageBuffer, retryBuffer); err != nil {
					logger.Log.Error("failed to send remaining messages on queue close",
						zap.Error(err),
						zap.String("instance_id", c.config.InstanceID.String()))
				}
				return
			}
			messageBuffer = append(messageBuffer, msg)
		default:
			if len(messageBuffer) > 0 {
				c.connMu.RLock()
				conn := c.conn
				c.connMu.RUnlock()

				if conn == nil {
					time.Sleep(time.Second)
					continue
				}

				var remainingMessages []*websocketv1.Message
				for _, msg := range messageBuffer {
					if err := c.sendWithRetry(msg); err != nil {
						remainingMessages = append(remainingMessages, msg)
						logger.Log.Error("error sending message after retries",
							zap.Error(err),
							zap.String("message_id", msg.Id),
							zap.String("instance_id", c.config.InstanceID.String()))
						break
					}
					time.Sleep(time.Millisecond)
				}

				messageBuffer = remainingMessages

				if len(remainingMessages) == 0 {
					time.Sleep(batchInterval)
				}
			}
		}
	}
}

func (c *client) sendWithRetry(msg *websocketv1.Message) error {
	var lastErr error
	for attempt := range maxMessageRetries {
		if attempt > 0 {
			delay := messageRetryDelay * time.Duration(1<<uint(attempt-1))
			logger.Log.Debug("retrying message send",
				zap.Int("attempt", attempt+1),
				zap.Duration("delay", delay),
				zap.String("message_id", msg.Id),
				zap.String("instance_id", c.config.InstanceID.String()))
			time.Sleep(delay)
		}

		if err := c.send(msg); err != nil {
			lastErr = err
			logger.Log.Warn("message send failed",
				zap.Error(err),
				zap.Int("attempt", attempt+1),
				zap.String("message_id", msg.Id),
				zap.String("instance_id", c.config.InstanceID.String()))
			continue
		}

		return nil
	}

	return fmt.Errorf("failed to send message after %d attempts: %w", maxMessageRetries, lastErr)
}

func (c *client) sendRemainingMessages(messageBuffer, retryBuffer []*websocketv1.Message) error {
	if len(messageBuffer) == 0 && len(retryBuffer) == 0 {
		return nil
	}

	logger.Log.Info("sending remaining messages before shutdown",
		zap.Int("message_count", len(messageBuffer)+len(retryBuffer)),
		zap.String("instance_id", c.config.InstanceID.String()))

	// Create a context with timeout for shutdown
	ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
	defer cancel()

	// Create a channel to signal completion
	done := make(chan error, 1)
	go func() {
		var err error
		for _, msg := range append(messageBuffer, retryBuffer...) {
			if err = c.sendWithRetry(msg); err != nil {
				break
			}
			time.Sleep(time.Millisecond)
		}
		done <- err
	}()

	// Wait for completion or timeout
	select {
	case err := <-done:
		if err != nil {
			return fmt.Errorf("failed to send remaining messages: %w", err)
		}
		return nil
	case <-ctx.Done():
		return fmt.Errorf("timeout while sending remaining messages: %w", ctx.Err())
	}
}

func (c *client) send(msg *websocketv1.Message) error {
	data, err := marshalMessage(msg)
	if err != nil {
		return fmt.Errorf("error marshaling message: %w", err)
	}
	return c.conn.WriteMessage(websocket.BinaryMessage, data)
}

func (c *client) Enqueue(id string, payload proto.Message) {
	msg, err := NewMessage(id, payload)
	if err != nil {
		logger.Log.Error("error creating message", zap.Error(err))
		return
	}
	c.messageQueue <- msg
}

func (c *client) EnqueueWithResponse(id string, payload proto.Message) (*websocketv1.Message, error) {
	respChan := make(chan *websocketv1.Message, 1)
	c.respMu.Lock()
	c.responses[id] = respChan
	c.respMu.Unlock()

	defer func() {
		c.respMu.Lock()
		delete(c.responses, id)
		c.respMu.Unlock()
	}()

	c.Enqueue(id, payload)

	select {
	case resp := <-respChan:
		return resp, nil
	case <-time.After(30 * time.Second):
		return nil, fmt.Errorf("timeout waiting for response")
	}
}

func (c *client) Wait() error {
	return <-c.done
}

func (c *client) Close() error {
	var closeErr error
	c.shutdownOnce.Do(func() {
		logger.Log.Info("initiating client shutdown",
			zap.String("instance_id", c.config.InstanceID.String()))

		// 1. Signal all goroutines to stop
		close(c.stop)

		// 2. Close the message queue to prevent new messages
		close(c.messageQueue)

		// 3. Wait for goroutines to finish with timeout
		shutdownCtx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
		defer cancel()

		shutdownDone := make(chan struct{})
		go func() {
			c.wg.Wait()
			close(shutdownDone)
		}()

		select {
		case <-shutdownDone:
			logger.Log.Debug("all goroutines stopped successfully")
		case <-shutdownCtx.Done():
			logger.Log.Warn("timeout waiting for goroutines to stop",
				zap.String("instance_id", c.config.InstanceID.String()))
		}

		// 4. Close the WebSocket connection
		c.connMu.Lock()
		if c.conn != nil {
			// Try to send a close message
			err := c.conn.WriteMessage(
				websocket.CloseMessage,
				websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""),
			)
			if err != nil && !websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) {
				logger.Log.Warn("error sending close message",
					zap.Error(err),
					zap.String("instance_id", c.config.InstanceID.String()))
			}

			// Close the underlying connection
			if err := c.conn.Close(); err != nil {
				logger.Log.Error("error closing websocket connection",
					zap.Error(err),
					zap.String("instance_id", c.config.InstanceID.String()))
				closeErr = fmt.Errorf("failed to close websocket connection: %w", err)
			}
			c.conn = nil
		}
		c.connMu.Unlock()

		// 5. Clean up response channels
		c.respMu.Lock()
		for id, ch := range c.responses {
			close(ch)
			delete(c.responses, id)
		}
		c.responses = make(map[string]chan *websocketv1.Message)
		c.respMu.Unlock()

		// 6. Signal that the client is fully closed
		select {
		case c.done <- nil:
		default:
		}

		logger.Log.Info("client shutdown completed",
			zap.String("instance_id", c.config.InstanceID.String()))
	})

	return closeErr
}
</file>

<file path="markdown/option.go">
package markdown

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.MarkdownOptions)
}
</file>

<file path="multiselect/option.go">
package multiselect

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.MultiSelectOptions)
}

type optionsOption []string

func (o optionsOption) Apply(opts *options.MultiSelectOptions) {
	opts.Options = []string(o)
}

func WithOptions(options ...string) Option {
	return optionsOption(options)
}

type placeholderOption string

func (p placeholderOption) Apply(opts *options.MultiSelectOptions) {
	opts.Placeholder = string(p)
}

func WithPlaceholder(placeholder string) Option {
	return placeholderOption(placeholder)
}

type defaultValueOption []string

func (d defaultValueOption) Apply(opts *options.MultiSelectOptions) {
	opts.DefaultValue = []string(d)
}

func WithDefaultValue(defaultValue ...string) Option {
	return defaultValueOption(defaultValue)
}

type requiredOption bool

func (r requiredOption) Apply(opts *options.MultiSelectOptions) {
	opts.Required = bool(r)
}

func WithRequired(required bool) Option {
	return requiredOption(required)
}

type disabledOption bool

func (d disabledOption) Apply(opts *options.MultiSelectOptions) {
	opts.Disabled = bool(d)
}

func WithDisabled(disabled bool) Option {
	return disabledOption(disabled)
}

type formatFuncOption func(string, int) string

func (f formatFuncOption) Apply(opts *options.MultiSelectOptions) {
	opts.FormatFunc = f
}

func WithFormatFunc(formatFunc func(string, int) string) Option {
	return formatFuncOption(formatFunc)
}
</file>

<file path="multiselect/value.go">
package multiselect

type Value struct {
	Values  []string
	Indexes []int
}
</file>

<file path="numberinput/option.go">
package numberinput

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.NumberInputOptions)
}

type placeholderOption string

func (p placeholderOption) Apply(opts *options.NumberInputOptions) {
	opts.Placeholder = string(p)
}

func WithPlaceholder(placeholder string) Option {
	return placeholderOption(placeholder)
}

type defaultValueOption float64

func (d defaultValueOption) Apply(opts *options.NumberInputOptions) {
	opts.DefaultValue = (*float64)(&d)
}

func WithDefaultValue(value float64) Option {
	return defaultValueOption(value)
}

type requiredOption bool

func (r requiredOption) Apply(opts *options.NumberInputOptions) {
	opts.Required = bool(r)
}

func WithRequired(required bool) Option {
	return requiredOption(required)
}

type disabledOption bool

func (d disabledOption) Apply(opts *options.NumberInputOptions) {
	opts.Disabled = bool(d)
}

func WithDisabled(disabled bool) Option {
	return disabledOption(disabled)
}

type maxValueOption float64

func (m maxValueOption) Apply(opts *options.NumberInputOptions) {
	opts.MaxValue = (*float64)(&m)
}

func WithMaxValue(value float64) Option {
	return maxValueOption(value)
}

type minValueOption float64

func (m minValueOption) Apply(opts *options.NumberInputOptions) {
	opts.MinValue = (*float64)(&m)
}

func WithMinValue(value float64) Option {
	return minValueOption(value)
}
</file>

<file path="radio/option.go">
package radio

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.RadioOptions)
}

type optionsOption []string

func (o optionsOption) Apply(opts *options.RadioOptions) {
	opts.Options = []string(o)
}

func WithOptions(options ...string) Option {
	return optionsOption(options)
}

type defaultValueOption string

func (d defaultValueOption) Apply(opts *options.RadioOptions) {
	opts.DefaultValue = (*string)(&d)
}

func WithDefaultValue(defaultValue string) Option {
	return defaultValueOption(defaultValue)
}

type requiredOption bool

func (r requiredOption) Apply(opts *options.RadioOptions) {
	opts.Required = bool(r)
}

func WithRequired(required bool) Option {
	return requiredOption(required)
}

type disabledOption bool

func (d disabledOption) Apply(opts *options.RadioOptions) {
	opts.Disabled = bool(d)
}

func WithDisabled(disabled bool) Option {
	return disabledOption(disabled)
}

type formatFuncOption func(string, int) string

func (f formatFuncOption) Apply(opts *options.RadioOptions) {
	opts.FormatFunc = func(s string, i int) string {
		return f(s, i)
	}
}

func WithFormatFunc(formatFunc func(string, int) string) Option {
	return formatFuncOption(formatFunc)
}
</file>

<file path="radio/value.go">
package radio

type Value struct {
	Value string
	Index int
}
</file>

<file path="selectbox/option.go">
package selectbox

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.SelectboxOptions)
}

type optionsOption []string

func (o optionsOption) Apply(opts *options.SelectboxOptions) {
	opts.Options = []string(o)
}

func WithOptions(options ...string) Option {
	return optionsOption(options)
}

type placeholderOption string

func (p placeholderOption) Apply(opts *options.SelectboxOptions) {
	opts.Placeholder = string(p)
}

func WithPlaceholder(placeholder string) Option {
	return placeholderOption(placeholder)
}

type defaultValueOption string

func (d defaultValueOption) Apply(opts *options.SelectboxOptions) {
	opts.DefaultValue = (*string)(&d)
}

func WithDefaultValue(defaultValue string) Option {
	return defaultValueOption(defaultValue)
}

type requiredOption bool

func (r requiredOption) Apply(opts *options.SelectboxOptions) {
	opts.Required = bool(r)
}

func WithRequired(required bool) Option {
	return requiredOption(required)
}

type disabledOption bool

func (d disabledOption) Apply(opts *options.SelectboxOptions) {
	opts.Disabled = bool(d)
}

func WithDisabled(disabled bool) Option {
	return disabledOption(disabled)
}

type formatFuncOption func(string, int) string

func (f formatFuncOption) Apply(opts *options.SelectboxOptions) {
	opts.FormatFunc = f
}

func WithFormatFunc(formatFunc func(string, int) string) Option {
	return formatFuncOption(formatFunc)
}
</file>

<file path="selectbox/value.go">
package selectbox

type Value struct {
	Value string
	Index int
}
</file>

<file path="table/option.go">
package table

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.TableOptions)
}

type headerOption string

func (h headerOption) Apply(opts *options.TableOptions) {
	opts.Header = string(h)
}

func WithHeader(header string) Option {
	return headerOption(header)
}

type descriptionOption string

func (d descriptionOption) Apply(opts *options.TableOptions) {
	opts.Description = string(d)
}

func WithDescription(description string) Option {
	return descriptionOption(description)
}

type heightOption int32

func (h heightOption) Apply(opts *options.TableOptions) {
	opts.Height = (*int32)(&h)
}

func WithHeight(height int32) Option {
	return heightOption(height)
}

type columnOrderOption []string

func (c columnOrderOption) Apply(opts *options.TableOptions) {
	opts.ColumnOrder = []string(c)
}

func WithColumnOrder(order ...string) Option {
	return columnOrderOption(order)
}

type onSelectOption OnSelect

func (o onSelectOption) Apply(opts *options.TableOptions) {
	opts.OnSelect = OnSelect(o).String()
}

func WithOnSelect(behavior OnSelect) Option {
	return onSelectOption(behavior)
}

type rowSelectionOption RowSelection

func (r rowSelectionOption) Apply(opts *options.TableOptions) {
	opts.RowSelection = RowSelection(r).String()
}

func WithRowSelection(mode RowSelection) Option {
	return rowSelectionOption(mode)
}
</file>

<file path="table/value.go">
package table

type Value struct {
	Selection *Selection
}

type Selection struct {
	Row  int
	Rows []int
}

type OnSelect string

const (
	OnSelectIgnore OnSelect = "ignore"
	OnSelectRerun  OnSelect = "rerun"
)

func (o OnSelect) String() string {
	return string(o)
}

type RowSelection string

const (
	RowSelectionSingle   RowSelection = "single"
	RowSelectionMultiple RowSelection = "multiple"
)

func (r RowSelection) String() string {
	return string(r)
}
</file>

<file path="textarea/option.go">
package textarea

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.TextAreaOptions)
}

type placeholderOption string

func (p placeholderOption) Apply(opts *options.TextAreaOptions) {
	opts.Placeholder = string(p)
}

func WithPlaceholder(placeholder string) Option {
	return placeholderOption(placeholder)
}

type defaultValueOption string

func (d defaultValueOption) Apply(opts *options.TextAreaOptions) {
	opts.DefaultValue = (*string)(&d)
}

func WithDefaultValue(value string) Option {
	return defaultValueOption(value)
}

type requiredOption bool

func (r requiredOption) Apply(opts *options.TextAreaOptions) {
	opts.Required = bool(r)
}

func WithRequired(required bool) Option {
	return requiredOption(required)
}

type disabledOption bool

func (d disabledOption) Apply(opts *options.TextAreaOptions) {
	opts.Disabled = bool(d)
}

func WithDisabled(disabled bool) Option {
	return disabledOption(disabled)
}

type maxLengthOption int32

func (m maxLengthOption) Apply(opts *options.TextAreaOptions) {
	opts.MaxLength = (*int32)(&m)
}

func WithMaxLength(length int32) Option {
	return maxLengthOption(length)
}

type minLengthOption int32

func (m minLengthOption) Apply(opts *options.TextAreaOptions) {
	opts.MinLength = (*int32)(&m)
}

func WithMinLength(length int32) Option {
	return minLengthOption(length)
}

type maxLinesOption int32

func (m maxLinesOption) Apply(opts *options.TextAreaOptions) {
	opts.MaxLines = (*int32)(&m)
}

func WithMaxLines(lines int32) Option {
	return maxLinesOption(lines)
}

type minLinesOption int32

func (m minLinesOption) Apply(opts *options.TextAreaOptions) {
	opts.MinLines = (*int32)(&m)
}

func WithMinLines(lines int32) Option {
	return minLinesOption(lines)
}

type autoResizeOption bool

func (a autoResizeOption) Apply(opts *options.TextAreaOptions) {
	opts.AutoResize = bool(a)
}

func WithAutoResize(autoResize bool) Option {
	return autoResizeOption(autoResize)
}
</file>

<file path="textinput/option.go">
package textinput

import "github.com/trysourcetool/sourcetool-go/internal/options"

type Option interface {
	Apply(*options.TextInputOptions)
}

type placeholderOption string

func (p placeholderOption) Apply(opts *options.TextInputOptions) {
	opts.Placeholder = string(p)
}

func WithPlaceholder(placeholder string) Option {
	return placeholderOption(placeholder)
}

type defaultValueOption string

func (d defaultValueOption) Apply(opts *options.TextInputOptions) {
	opts.DefaultValue = (*string)(&d)
}

func WithDefaultValue(value string) Option {
	return defaultValueOption(value)
}

type requiredOption bool

func (r requiredOption) Apply(opts *options.TextInputOptions) {
	opts.Required = bool(r)
}

func WithRequired(required bool) Option {
	return requiredOption(required)
}

type disabledOption bool

func (d disabledOption) Apply(opts *options.TextInputOptions) {
	opts.Disabled = bool(d)
}

func WithDisabled(disabled bool) Option {
	return disabledOption(disabled)
}

type maxLengthOption int32

func (m maxLengthOption) Apply(opts *options.TextInputOptions) {
	opts.MaxLength = (*int32)(&m)
}

func WithMaxLength(length int32) Option {
	return maxLengthOption(length)
}

type minLengthOption int32

func (m minLengthOption) Apply(opts *options.TextInputOptions) {
	opts.MinLength = (*int32)(&m)
}

func WithMinLength(length int32) Option {
	return minLengthOption(length)
}
</file>

<file path="timeinput/option.go">
package timeinput

import (
	"time"

	"github.com/trysourcetool/sourcetool-go/internal/options"
)

type Option interface {
	Apply(*options.TimeInputOptions)
}

type placeholderOption string

func (p placeholderOption) Apply(opts *options.TimeInputOptions) {
	opts.Placeholder = string(p)
}

func WithPlaceholder(placeholder string) Option {
	return placeholderOption(placeholder)
}

type defaultValueOption time.Time

func (d defaultValueOption) Apply(opts *options.TimeInputOptions) {
	opts.DefaultValue = (*time.Time)(&d)
}

func WithDefaultValue(value time.Time) Option {
	return defaultValueOption(value)
}

type requiredOption bool

func (r requiredOption) Apply(opts *options.TimeInputOptions) {
	opts.Required = bool(r)
}

func WithRequired(required bool) Option {
	return requiredOption(required)
}

type disabledOption bool

func (d disabledOption) Apply(opts *options.TimeInputOptions) {
	opts.Disabled = bool(d)
}

func WithDisabled(disabled bool) Option {
	return disabledOption(disabled)
}

type locationOption time.Location

func (l locationOption) Apply(opts *options.TimeInputOptions) {
	opts.Location = (*time.Location)(&l)
}

func WithLocation(location time.Location) Option {
	return locationOption(location)
}
</file>

<file path=".golangci.yml">
run:
  timeout: 5m
  issues:
    exclude-dirs:
      - testdata
    exclude-files:
      - config/config.go

linters:
  enable:
    - asciicheck
    - copyloopvar
    - gci
    - godot
    - gofmt
    - gofumpt
    - goimports
    - gomodguard
    - goprintffuncname
    - gosimple
    - gosec
    - govet
    - ineffassign
    - misspell
    - nakedret
    - nolintlint
    - sqlclosecheck
    - staticcheck
    - typecheck
    - unconvert
    - unused
    - whitespace
  disable:
    - depguard
    - errcheck
    - funlen
    - err113
    - gochecknoglobals
    - gocognit
    - goconst
    - gocyclo
    - godox
    - lll
    - nestif
    - nlreturn
    - noctx
    - testpackage
    - wsl

linters-settings:
  gofumpt:
    extra-rules: true
  misspell:
    locale: US
  gci:
    sections:
      - standard
      - default
      - prefix(github.com/trysourcetool/sourcetool-go)
  gosec:
    excludes:
      - G115 # Suppress integer overflow conversion warnings
</file>

<file path="button_test.go">
package sourcetool

import (
	"context"
	"testing"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/button"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
)

func TestConvertStateToButtonProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())

	buttonState := &state.ButtonState{
		ID:       id,
		Label:    "Test Button",
		Value:    true,
		Disabled: true,
	}

	data := convertStateToButtonProto(buttonState)

	if data == nil {
		t.Fatal("convertStateToButtonProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", data.Label, buttonState.Label},
		{"Value", data.Value, buttonState.Value},
		{"Disabled", data.Disabled, buttonState.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertButtonProtoToState(t *testing.T) {
	data := &widgetv1.Button{
		Label:    "Test Button",
		Value:    true,
		Disabled: true,
	}

	state := convertButtonProtoToState(uuid.Must(uuid.NewV4()), data)

	if state == nil {
		t.Fatal("convertButtonProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, data.Label},
		{"Value", state.Value, data.Value},
		{"Disabled", state.Disabled, data.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestButton(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test Button"

	value := builder.Button(label,
		button.WithDisabled(true),
	)

	if value {
		t.Error("Button value = true, want false")
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeButton, []int{0})
	state := sess.State.GetButton(widgetID)
	if state == nil {
		t.Fatal("Button state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, label},
		{"Value", state.Value, false},
		{"Disabled", state.Disabled, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestButton_DefaultState(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test Button"

	builder.Button(label)

	widgetID := builder.generatePageID(state.WidgetTypeButton, []int{0})
	state := sess.State.GetButton(widgetID)
	if state == nil {
		t.Fatal("Button state not found")
	}

	if state.Value {
		t.Error("Default Value = true, want false")
	}
	if state.Disabled {
		t.Error("Default Disabled = true, want false")
	}
}
</file>

<file path="button.go">
package sourcetool

import (
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/button"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
)

func (b *uiBuilder) Button(label string, opts ...button.Option) bool {
	buttonOpts := &options.ButtonOptions{
		Label:    label,
		Disabled: false,
	}

	for _, o := range opts {
		o.Apply(buttonOpts)
	}

	sess := b.session
	if sess == nil {
		return false
	}
	page := b.page
	if page == nil {
		return false
	}
	cursor := b.cursor
	if cursor == nil {
		return false
	}
	path := cursor.getPath()

	widgetID := b.generatePageID(state.WidgetTypeButton, path)
	buttonState := sess.State.GetButton(widgetID)
	if buttonState == nil {
		buttonState = &state.ButtonState{
			ID:    widgetID,
			Value: false,
		}
	}
	buttonState.Label = buttonOpts.Label
	buttonState.Disabled = buttonOpts.Disabled
	sess.State.Set(widgetID, buttonState)

	button := convertStateToButtonProto(buttonState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_Button{
				Button: button,
			},
		},
	})

	cursor.next()

	return buttonState.Value
}

func convertStateToButtonProto(state *state.ButtonState) *widgetv1.Button {
	return &widgetv1.Button{
		Value:    state.Value,
		Label:    state.Label,
		Disabled: state.Disabled,
	}
}

func convertButtonProtoToState(id uuid.UUID, data *widgetv1.Button) *state.ButtonState {
	if data == nil {
		return nil
	}
	return &state.ButtonState{
		ID:       id,
		Value:    data.Value,
		Label:    data.Label,
		Disabled: data.Disabled,
	}
}
</file>

<file path="checkbox_test.go">
package sourcetool

import (
	"context"
	"testing"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/checkbox"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
)

func TestConvertStateToCheckboxProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())

	checkboxState := &state.CheckboxState{
		ID:           id,
		Label:        "Test Checkbox",
		Value:        true,
		DefaultValue: false,
		Required:     true,
		Disabled:     false,
	}

	data := convertStateToCheckboxProto(checkboxState)

	if data == nil {
		t.Fatal("convertStateToCheckboxProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", data.Label, checkboxState.Label},
		{"Value", data.Value, checkboxState.Value},
		{"DefaultValue", data.DefaultValue, checkboxState.DefaultValue},
		{"Required", data.Required, checkboxState.Required},
		{"Disabled", data.Disabled, checkboxState.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertCheckboxProtoToState(t *testing.T) {
	data := &widgetv1.Checkbox{
		Label:        "Test Checkbox",
		Value:        true,
		DefaultValue: false,
		Required:     true,
		Disabled:     false,
	}

	state := convertCheckboxProtoToState(uuid.Must(uuid.NewV4()), data)

	if state == nil {
		t.Fatal("convertCheckboxProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ID", state.ID, state.ID},
		{"Label", state.Label, data.Label},
		{"Value", state.Value, data.Value},
		{"DefaultValue", state.DefaultValue, data.DefaultValue},
		{"Required", state.Required, data.Required},
		{"Disabled", state.Disabled, data.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestCheckbox(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test Checkbox"

	// Create Checkbox component with all options
	value := builder.Checkbox(label,
		checkbox.WithDefaultValue(true),
		checkbox.WithRequired(true),
		checkbox.WithDisabled(true),
	)

	// Verify return value
	if !value {
		t.Error("Checkbox value = false, want true")
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	// Verify state
	widgetID := builder.generatePageID(state.WidgetTypeCheckbox, []int{0})
	state := sess.State.GetCheckbox(widgetID)
	if state == nil {
		t.Fatal("Checkbox state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, label},
		{"Value", state.Value, true},
		{"DefaultValue", state.DefaultValue, true},
		{"Required", state.Required, true},
		{"Disabled", state.Disabled, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}
</file>

<file path="checkbox.go">
package sourcetool

import (
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/checkbox"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
)

func (b *uiBuilder) Checkbox(label string, opts ...checkbox.Option) bool {
	checkboxOpts := &options.CheckboxOptions{
		Label:        label,
		DefaultValue: false,
		Required:     false,
		Disabled:     false,
	}

	for _, o := range opts {
		o.Apply(checkboxOpts)
	}

	sess := b.session
	if sess == nil {
		return false
	}
	page := b.page
	if page == nil {
		return false
	}
	cursor := b.cursor
	if cursor == nil {
		return false
	}
	path := cursor.getPath()

	widgetID := b.generatePageID(state.WidgetTypeCheckbox, path)
	checkboxState := sess.State.GetCheckbox(widgetID)
	if checkboxState == nil {
		checkboxState = &state.CheckboxState{
			ID:    widgetID,
			Value: checkboxOpts.DefaultValue,
		}
	}
	checkboxState.Label = checkboxOpts.Label
	checkboxState.DefaultValue = checkboxOpts.DefaultValue
	checkboxState.Required = checkboxOpts.Required
	checkboxState.Disabled = checkboxOpts.Disabled
	sess.State.Set(widgetID, checkboxState)

	checkboxProto := convertStateToCheckboxProto(checkboxState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_Checkbox{
				Checkbox: checkboxProto,
			},
		},
	})

	cursor.next()

	return checkboxState.Value
}

func convertStateToCheckboxProto(state *state.CheckboxState) *widgetv1.Checkbox {
	if state == nil {
		return nil
	}
	return &widgetv1.Checkbox{
		Value:        state.Value,
		Label:        state.Label,
		DefaultValue: state.DefaultValue,
		Required:     state.Required,
		Disabled:     state.Disabled,
	}
}

func convertCheckboxProtoToState(id uuid.UUID, data *widgetv1.Checkbox) *state.CheckboxState {
	if data == nil {
		return nil
	}
	return &state.CheckboxState{
		ID:           id,
		Value:        data.Value,
		Label:        data.Label,
		DefaultValue: data.DefaultValue,
		Required:     data.Required,
		Disabled:     data.Disabled,
	}
}
</file>

<file path="checkboxgroup_test.go">
package sourcetool

import (
	"context"
	"reflect"
	"testing"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/checkboxgroup"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
)

func TestConvertStateToCheckboxGroupProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	value := []int32{0, 2}
	defaultValue := []int32{0}
	options := []string{"Option 1", "Option 2", "Option 3"}

	checkboxGroupState := &state.CheckboxGroupState{
		ID:           id,
		Label:        "Test CheckboxGroup",
		Value:        value,
		Options:      options,
		DefaultValue: defaultValue,
		Required:     true,
		Disabled:     false,
	}

	data := convertStateToCheckboxGroupProto(checkboxGroupState)

	if data == nil {
		t.Fatal("convertStateToCheckboxGroupProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", data.Label, checkboxGroupState.Label},
		{"Value", data.Value, checkboxGroupState.Value},
		{"Options length", len(data.Options), len(checkboxGroupState.Options)},
		{"DefaultValue", data.DefaultValue, checkboxGroupState.DefaultValue},
		{"Required", data.Required, checkboxGroupState.Required},
		{"Disabled", data.Disabled, checkboxGroupState.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !reflect.DeepEqual(tt.got, tt.want) {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertCheckboxGroupProtoToState(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	value := []int32{0, 2}
	defaultValue := []int32{0}
	options := []string{"Option 1", "Option 2", "Option 3"}

	data := &widgetv1.CheckboxGroup{
		Label:        "Test CheckboxGroup",
		Value:        value,
		Options:      options,
		DefaultValue: defaultValue,
		Required:     true,
		Disabled:     false,
	}

	state := convertCheckboxGroupProtoToState(id, data)

	if state == nil {
		t.Fatal("convertCheckboxGroupProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ID", state.ID, id},
		{"Label", state.Label, data.Label},
		{"Value", state.Value, data.Value},
		{"Options length", len(state.Options), len(data.Options)},
		{"DefaultValue", state.DefaultValue, data.DefaultValue},
		{"Required", state.Required, data.Required},
		{"Disabled", state.Disabled, data.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !reflect.DeepEqual(tt.got, tt.want) {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestCheckboxGroup(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test CheckboxGroup"
	options := []string{"Option 1", "Option 2", "Option 3"}
	defaultValue := []string{"Option 1", "Option 3"}

	value := builder.CheckboxGroup(label,
		checkboxgroup.WithOptions(options...),
		checkboxgroup.WithDefaultValue(defaultValue...),
		checkboxgroup.WithRequired(true),
		checkboxgroup.WithDisabled(true),
	)

	if value == nil {
		t.Fatal("CheckboxGroup returned nil")
	}
	if !reflect.DeepEqual(value.Values, defaultValue) {
		t.Errorf("CheckboxGroup values = %v, want %v", value.Values, defaultValue)
	}
	expectedIndexes := []int{0, 2}
	if !reflect.DeepEqual(value.Indexes, expectedIndexes) {
		t.Errorf("CheckboxGroup indexes = %v, want %v", value.Indexes, expectedIndexes)
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeCheckboxGroup, []int{0})
	state := sess.State.GetCheckboxGroup(widgetID)
	if state == nil {
		t.Fatal("CheckboxGroup state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, label},
		{"Options length", len(state.Options), len(options)},
		{"Required", state.Required, true},
		{"Disabled", state.Disabled, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !reflect.DeepEqual(tt.got, tt.want) {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestCheckboxGroup_WithFormatFunc(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test CheckboxGroup"
	options := []string{"Option 1", "Option 2"}
	formatFunc := func(value string, index int) string {
		return value + " (Custom)"
	}

	builder.CheckboxGroup(label,
		checkboxgroup.WithOptions(options...),
		checkboxgroup.WithFormatFunc(formatFunc),
	)

	widgetID := builder.generatePageID(state.WidgetTypeCheckboxGroup, []int{0})
	state := sess.State.GetCheckboxGroup(widgetID)
	if state == nil {
		t.Fatal("CheckboxGroup state not found")
	}

	expectedOptions := []string{"Option 1 (Custom)", "Option 2 (Custom)"}
	if !reflect.DeepEqual(state.Options, expectedOptions) {
		t.Errorf("Formatted options = %v, want %v", state.Options, expectedOptions)
	}
}
</file>

<file path="checkboxgroup.go">
package sourcetool

import (
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/checkboxgroup"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
)

func (b *uiBuilder) CheckboxGroup(label string, opts ...checkboxgroup.Option) *checkboxgroup.Value {
	checkboxGroupOpts := &options.CheckboxGroupOptions{
		Label:        label,
		DefaultValue: nil,
		Required:     false,
		Disabled:     false,
		FormatFunc:   nil,
	}

	for _, o := range opts {
		o.Apply(checkboxGroupOpts)
	}

	sess := b.session
	if sess == nil {
		return nil
	}
	page := b.page
	if page == nil {
		return nil
	}
	cursor := b.cursor
	if cursor == nil {
		return nil
	}
	path := cursor.getPath()

	var defaultVal []int32
	if len(checkboxGroupOpts.DefaultValue) != 0 {
		for _, o := range checkboxGroupOpts.DefaultValue {
			for i, opt := range checkboxGroupOpts.Options {
				if opt == o {
					defaultVal = append(defaultVal, int32(i))
					break
				}
			}
		}
	}

	widgetID := b.generatePageID(state.WidgetTypeCheckboxGroup, path)
	checkboxGroupState := sess.State.GetCheckboxGroup(widgetID)
	if checkboxGroupState == nil {
		checkboxGroupState = &state.CheckboxGroupState{
			ID:    widgetID,
			Value: defaultVal,
		}
	}
	if checkboxGroupOpts.FormatFunc == nil {
		checkboxGroupOpts.FormatFunc = func(v string, i int) string {
			return v
		}
	}

	displayVals := make([]string, len(checkboxGroupOpts.Options))
	for i, v := range checkboxGroupOpts.Options {
		displayVals[i] = checkboxGroupOpts.FormatFunc(v, i)
	}

	checkboxGroupState.Label = checkboxGroupOpts.Label
	checkboxGroupState.Options = displayVals
	checkboxGroupState.DefaultValue = defaultVal
	checkboxGroupState.Required = checkboxGroupOpts.Required
	checkboxGroupState.Disabled = checkboxGroupOpts.Disabled
	sess.State.Set(widgetID, checkboxGroupState)

	checkboxGroupProto := convertStateToCheckboxGroupProto(checkboxGroupState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_CheckboxGroup{
				CheckboxGroup: checkboxGroupProto,
			},
		},
	})

	cursor.next()

	var value *checkboxgroup.Value
	if checkboxGroupState.Value != nil {
		value = &checkboxgroup.Value{
			Values:  make([]string, len(checkboxGroupState.Value)),
			Indexes: make([]int, len(checkboxGroupState.Value)),
		}
		for i, idx := range checkboxGroupState.Value {
			value.Values[i] = checkboxGroupOpts.Options[idx]
			value.Indexes[i] = int(idx)
		}
	}

	return value
}

func convertStateToCheckboxGroupProto(state *state.CheckboxGroupState) *widgetv1.CheckboxGroup {
	if state == nil {
		return nil
	}
	return &widgetv1.CheckboxGroup{
		Label:        state.Label,
		Value:        state.Value,
		Options:      state.Options,
		DefaultValue: state.DefaultValue,
		Required:     state.Required,
		Disabled:     state.Disabled,
	}
}

func convertCheckboxGroupProtoToState(id uuid.UUID, data *widgetv1.CheckboxGroup) *state.CheckboxGroupState {
	if data == nil {
		return nil
	}
	return &state.CheckboxGroupState{
		ID:           id,
		Label:        data.Label,
		Value:        data.Value,
		Options:      data.Options,
		DefaultValue: data.DefaultValue,
		Required:     data.Required,
		Disabled:     data.Disabled,
	}
}
</file>

<file path="CODE_OF_CONDUCT.md">
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
support@trysourcetool.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.
</file>

<file path="columns_test.go">
package sourcetool

import (
	"context"
	"testing"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/columns"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
)

func TestConvertStateToColumnsProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	columnsState := &state.ColumnsState{
		ID:      id,
		Columns: 3,
	}

	data := convertStateToColumnsProto(columnsState)

	if data == nil {
		t.Fatal("convertStateToColumnsProto returned nil")
	}

	if int(data.Columns) != columnsState.Columns {
		t.Errorf("Columns = %v, want %v", data.Columns, columnsState.Columns)
	}
}

func TestConvertColumnsProtoToState(t *testing.T) {
	data := &widgetv1.Columns{
		Columns: 3,
	}

	state := convertColumnsProtoToState(uuid.Must(uuid.NewV4()), data)

	if state == nil {
		t.Fatal("convertColumnsProtoToState returned nil")
	}

	if state.Columns != int(data.Columns) {
		t.Errorf("Columns = %v, want %v", state.Columns, data.Columns)
	}
}

func TestConvertStateToColumnItemProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	columnItemState := &state.ColumnItemState{
		ID:     id,
		Weight: 0.5,
	}

	data := convertStateToColumnItemProto(columnItemState)

	if data == nil {
		t.Fatal("convertStateToColumnItemProto returned nil")
	}

	if data.Weight != columnItemState.Weight {
		t.Errorf("Weight = %v, want %v", data.Weight, columnItemState.Weight)
	}
}

func TestConvertColumnItemProtoToState(t *testing.T) {
	data := &widgetv1.ColumnItem{
		Weight: 0.5,
	}

	state := convertColumnItemProtoToState(uuid.Must(uuid.NewV4()), data)

	if state == nil {
		t.Fatal("convertColumnItemProtoToState returned nil")
	}

	if state.Weight != data.Weight {
		t.Errorf("Weight = %v, want %v", state.Weight, data.Weight)
	}
}

func TestColumns(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	cols := 3
	builders := builder.Columns(cols)

	if builders == nil {
		t.Fatal("Columns returned nil")
	}
	if len(builders) != cols {
		t.Errorf("Builders length = %v, want %v", len(builders), cols)
	}

	messages := mockWS.Messages()
	expectedMessages := cols + 1 // columns widget + column items
	if len(messages) != expectedMessages {
		t.Errorf("WebSocket messages count = %d, want %d", len(messages), expectedMessages)
	}

	widgetID := builder.generatePageID(state.WidgetTypeColumns, []int{0})
	columnsState := sess.State.GetColumns(widgetID)
	if columnsState == nil {
		t.Fatal("Columns state not found")
	}

	if columnsState.Columns != cols {
		t.Errorf("Columns = %v, want %v", columnsState.Columns, cols)
	}

	for i := 0; i < cols; i++ {
		columnPath := []int{0, i}
		columnID := builder.generatePageID(state.WidgetTypeColumnItem, columnPath)
		columnState := sess.State.Get(columnID)
		if columnState == nil {
			t.Fatalf("Column item state not found for index %d", i)
		}

		expectedWeight := 1.0 / float64(cols)
		columnItemState, ok := columnState.(*state.ColumnItemState)
		if !ok {
			t.Fatalf("Column item state[%d] is not *columnitem.State", i)
		}
		if columnItemState.Weight != expectedWeight {
			t.Errorf("Column item weight[%d] = %v, want %v", i, columnItemState.Weight, expectedWeight)
		}
	}
}

func TestColumns_WithWeight(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	cols := 3
	weights := []int{2, 1, 1}
	totalWeight := 4

	builders := builder.Columns(cols, columns.WithWeight(weights...))

	if builders == nil {
		t.Fatal("Columns returned nil")
	}

	for i := 0; i < cols; i++ {
		columnPath := []int{0, i}
		columnID := builder.generatePageID(state.WidgetTypeColumnItem, columnPath)
		columnState := sess.State.Get(columnID)
		if columnState == nil {
			t.Fatalf("Column item state not found for index %d", i)
		}

		expectedWeight := float64(weights[i]) / float64(totalWeight)
		columnItemState, ok := columnState.(*state.ColumnItemState)
		if !ok {
			t.Fatalf("Column item state[%d] is not *columnitem.State", i)
		}
		if columnItemState.Weight != expectedWeight {
			t.Errorf("Column item weight[%d] = %v, want %v", i, columnItemState.Weight, expectedWeight)
		}
	}
}

func TestColumns_InvalidInput(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	tests := []struct {
		name    string
		cols    int
		weights []int
	}{
		{"Zero columns", 0, nil},
		{"Negative columns", -1, nil},
		{"Invalid weights length", 3, []int{1, 1}},
		{"Zero weights", 3, []int{0, 0, 0}},
		{"Negative weights", 3, []int{-1, 1, 1}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var builders []UIBuilder
			if tt.weights == nil {
				builders = builder.Columns(tt.cols)
			} else {
				builders = builder.Columns(tt.cols, columns.WithWeight(tt.weights...))
			}

			if tt.cols <= 0 && builders != nil {
				t.Error("Expected nil builders for invalid column count")
			}

			if tt.cols > 0 && builders != nil {
				for i := 0; i < tt.cols; i++ {
					columnPath := []int{0, i}
					columnID := builder.generatePageID(state.WidgetTypeColumnItem, columnPath)
					columnState := sess.State.Get(columnID)
					if columnState == nil {
						t.Fatalf("Column item state not found for index %d", i)
					}

					expectedWeight := 1.0 / float64(tt.cols)
					columnItemState, ok := columnState.(*state.ColumnItemState)
					if !ok {
						t.Fatalf("Column item state[%d] is not *columnitem.State", i)
					}
					if columnItemState.Weight != expectedWeight {
						t.Errorf("Column item weight[%d] = %v, want %v", i, columnItemState.Weight, expectedWeight)
					}
				}
			}
		})
	}
}
</file>

<file path="columns.go">
package sourcetool

import (
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/columns"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
)

func (b *uiBuilder) Columns(cols int, opts ...columns.Option) []UIBuilder {
	if cols < 1 {
		return nil
	}

	sess := b.session
	if sess == nil {
		return nil
	}
	page := b.page
	if page == nil {
		return nil
	}
	cursor := b.cursor
	if cursor == nil {
		return nil
	}
	path := cursor.getPath()

	columnsOpts := &options.ColumnsOptions{
		Columns: cols,
	}
	for _, o := range opts {
		o.Apply(columnsOpts)
	}

	widgetID := b.generatePageID(state.WidgetTypeColumns, path)
	weights := columnsOpts.Weight
	if len(weights) == 0 || len(weights) != cols {
		weights = make([]int, cols)
		for i := range weights {
			weights[i] = 1
		}
	}

	for _, w := range weights {
		if w <= 0 {
			weights = make([]int, cols)
			for i := range weights {
				weights[i] = 1
			}
			break
		}
	}

	totalWeight := 0
	for _, w := range weights {
		totalWeight += w
	}

	columnsState := &state.ColumnsState{
		ID:      widgetID,
		Columns: cols,
	}
	sess.State.Set(widgetID, columnsState)

	columns := convertStateToColumnsProto(columnsState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_Columns{
				Columns: columns,
			},
		},
	})

	builders := make([]UIBuilder, cols)
	for i := 0; i < cols; i++ {
		columnCursor := newCursor()
		columnCursor.parentPath = append(path, i)

		columnPath := append(path, i)
		widgetID := b.generatePageID(state.WidgetTypeColumnItem, columnPath)
		columnItemState := &state.ColumnItemState{
			ID:     widgetID,
			Weight: float64(weights[i]) / float64(totalWeight),
		}
		sess.State.Set(widgetID, columnItemState)

		columnItem := convertStateToColumnItemProto(columnItemState)
		b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
			SessionId: sess.ID.String(),
			PageId:    page.id.String(),
			Path:      convertPathToInt32Slice(columnPath),
			Widget: &widgetv1.Widget{
				Id: widgetID.String(),
				Type: &widgetv1.Widget_ColumnItem{
					ColumnItem: columnItem,
				},
			},
		})

		builders[i] = &uiBuilder{
			runtime: b.runtime,
			context: b.context,
			cursor:  columnCursor,
			session: sess,
			page:    page,
		}
	}

	cursor.next()

	return builders
}

func convertStateToColumnsProto(state *state.ColumnsState) *widgetv1.Columns {
	return &widgetv1.Columns{
		Columns: int32(state.Columns),
	}
}

func convertColumnsProtoToState(id uuid.UUID, data *widgetv1.Columns) *state.ColumnsState {
	return &state.ColumnsState{
		ID:      id,
		Columns: int(data.Columns),
	}
}

func convertStateToColumnItemProto(state *state.ColumnItemState) *widgetv1.ColumnItem {
	return &widgetv1.ColumnItem{
		Weight: state.Weight,
	}
}

func convertColumnItemProtoToState(id uuid.UUID, data *widgetv1.ColumnItem) *state.ColumnItemState {
	return &state.ColumnItemState{
		ID:     id,
		Weight: data.Weight,
	}
}
</file>

<file path="config.go">
package sourcetool

type Config struct {
	APIKey   string
	Endpoint string
}
</file>

<file path="dateinput_test.go">
package sourcetool

import (
	"context"
	"testing"
	"time"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/dateinput"
	"github.com/trysourcetool/sourcetool-go/internal/conv"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
)

func TestConvertStateToDateInputProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	now := time.Now()
	maxDate := now.AddDate(1, 0, 0)
	minDate := now.AddDate(-1, 0, 0)

	dateInputState := &state.DateInputState{
		ID:           id,
		Label:        "Test DateInput",
		Value:        &now,
		Placeholder:  "Select date",
		DefaultValue: &now,
		Required:     true,
		Disabled:     false,
		Format:       "YYYY/MM/DD",
		MaxValue:     &maxDate,
		MinValue:     &minDate,
		Location:     time.Local,
	}

	data := convertStateToDateInputProto(dateInputState)

	if data == nil {
		t.Fatal("convertStateToDateInputProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", data.Label, dateInputState.Label},
		{"Value", conv.SafeValue(data.Value), dateInputState.Value.Format(time.DateOnly)},
		{"Placeholder", data.Placeholder, dateInputState.Placeholder},
		{"DefaultValue", conv.SafeValue(data.DefaultValue), dateInputState.DefaultValue.Format(time.DateOnly)},
		{"Required", data.Required, dateInputState.Required},
		{"Disabled", data.Disabled, dateInputState.Disabled},
		{"Format", data.Format, dateInputState.Format},
		{"MaxValue", data.MaxValue, dateInputState.MaxValue.Format(time.DateOnly)},
		{"MinValue", data.MinValue, dateInputState.MinValue.Format(time.DateOnly)},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertDateInputProtoToState(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	now := time.Now()
	dateStr := now.Format(time.DateOnly)
	maxDateStr := now.AddDate(1, 0, 0).Format(time.DateOnly)
	minDateStr := now.AddDate(-1, 0, 0).Format(time.DateOnly)

	data := &widgetv1.DateInput{
		Label:        "Test DateInput",
		Value:        conv.NilValue(dateStr),
		Placeholder:  "Select date",
		DefaultValue: conv.NilValue(dateStr),
		Required:     true,
		Disabled:     false,
		Format:       "YYYY/MM/DD",
		MaxValue:     maxDateStr,
		MinValue:     minDateStr,
	}

	state, err := convertDateInputProtoToState(id, data, time.Local)
	if err != nil {
		t.Fatalf("convertDateInputProtoToState returned error: %v", err)
	}

	if state == nil {
		t.Fatal("convertDateInputProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ID", state.ID, id},
		{"Label", state.Label, data.Label},
		{"Value", state.Value.Format(time.DateOnly), conv.SafeValue(data.Value)},
		{"Placeholder", state.Placeholder, data.Placeholder},
		{"DefaultValue", state.DefaultValue.Format(time.DateOnly), conv.SafeValue(data.DefaultValue)},
		{"Required", state.Required, data.Required},
		{"Disabled", state.Disabled, data.Disabled},
		{"Format", state.Format, data.Format},
		{"MaxValue", state.MaxValue.Format(time.DateOnly), data.MaxValue},
		{"MinValue", state.MinValue.Format(time.DateOnly), data.MinValue},
		{"Location", state.Location, time.Local},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertDateInputProtoToState_InvalidDate(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	data := &widgetv1.DateInput{
		Value: conv.NilValue("invalid-date"),
	}

	_, err := convertDateInputProtoToState(id, data, time.Local)
	if err == nil {
		t.Error("Expected error for invalid date, got nil")
	}
}

func TestDateInput(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test DateInput"
	now := time.Now()
	maxDate := now.AddDate(1, 0, 0)
	minDate := now.AddDate(-1, 0, 0)
	placeholder := "Select date"
	format := "YYYY-MM-DD"
	location := *time.UTC

	value := builder.DateInput(label,
		dateinput.WithDefaultValue(now),
		dateinput.WithPlaceholder(placeholder),
		dateinput.WithRequired(true),
		dateinput.WithDisabled(true),
		dateinput.WithFormat(format),
		dateinput.WithMaxValue(maxDate),
		dateinput.WithMinValue(minDate),
		dateinput.WithLocation(location),
	)

	if value == nil {
		t.Fatal("DateInput returned nil")
	}
	if !value.Equal(now) {
		t.Errorf("DateInput value = %v, want %v", value, now)
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeDateInput, []int{0})
	state := sess.State.GetDateInput(widgetID)
	if state == nil {
		t.Fatal("DateInput state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, label},
		{"Placeholder", state.Placeholder, placeholder},
		{"Required", state.Required, true},
		{"Disabled", state.Disabled, true},
		{"Format", state.Format, format},
		{"Location", state.Location.String(), location.String()},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}

	if !state.Value.Equal(*value) {
		t.Errorf("Value = %v, want %v", state.Value, value)
	}
	if !state.DefaultValue.Equal(now) {
		t.Errorf("DefaultValue = %v, want %v", state.DefaultValue, now)
	}
	if !state.MaxValue.Equal(maxDate) {
		t.Errorf("MaxValue = %v, want %v", state.MaxValue, maxDate)
	}
	if !state.MinValue.Equal(minDate) {
		t.Errorf("MinValue = %v, want %v", state.MinValue, minDate)
	}
}

func TestDateInput_DefaultValues(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test DateInput"

	builder.DateInput(label)

	widgetID := builder.generatePageID(state.WidgetTypeDateInput, []int{0})
	state := sess.State.GetDateInput(widgetID)
	if state == nil {
		t.Fatal("DateInput state not found")
	}

	if state.Format != "YYYY/MM/DD" {
		t.Errorf("Default Format = %v, want YYYY/MM/DD", state.Format)
	}
	if state.Location != time.Local {
		t.Errorf("Default Location = %v, want %v", state.Location, time.Local)
	}
	if state.Required {
		t.Error("Default Required = true, want false")
	}
	if state.Disabled {
		t.Error("Default Disabled = true, want false")
	}
}
</file>

<file path="dateinput.go">
package sourcetool

import (
	"fmt"
	"time"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/dateinput"
	"github.com/trysourcetool/sourcetool-go/internal/conv"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
)

func (b *uiBuilder) DateInput(label string, opts ...dateinput.Option) *time.Time {
	dateInputOpts := &options.DateInputOptions{
		Label:        label,
		Placeholder:  "",
		DefaultValue: nil,
		Required:     false,
		Disabled:     false,
		Format:       "YYYY/MM/DD",
		MaxValue:     nil,
		MinValue:     nil,
		Location:     time.Local,
	}

	for _, o := range opts {
		o.Apply(dateInputOpts)
	}

	sess := b.session
	if sess == nil {
		return nil
	}
	page := b.page
	if page == nil {
		return nil
	}
	cursor := b.cursor
	if cursor == nil {
		return nil
	}
	path := cursor.getPath()

	widgetID := b.generatePageID(state.WidgetTypeDateInput, path)
	dateInputState := sess.State.GetDateInput(widgetID)
	if dateInputState == nil {
		dateInputState = &state.DateInputState{
			ID:    widgetID,
			Value: dateInputOpts.DefaultValue,
		}
	}
	dateInputState.Label = dateInputOpts.Label
	dateInputState.Placeholder = dateInputOpts.Placeholder
	dateInputState.DefaultValue = dateInputOpts.DefaultValue
	dateInputState.Required = dateInputOpts.Required
	dateInputState.Disabled = dateInputOpts.Disabled
	dateInputState.Format = dateInputOpts.Format
	dateInputState.MaxValue = dateInputOpts.MaxValue
	dateInputState.MinValue = dateInputOpts.MinValue
	dateInputState.Location = dateInputOpts.Location
	sess.State.Set(widgetID, dateInputState)

	dateInput := convertStateToDateInputProto(dateInputState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_DateInput{
				DateInput: dateInput,
			},
		},
	})

	cursor.next()

	return dateInputState.Value
}

func convertDateInputProtoToState(id uuid.UUID, data *widgetv1.DateInput, location *time.Location) (*state.DateInputState, error) {
	if data == nil {
		return nil, nil
	}

	parseDate := func(dateStr string) (*time.Time, error) {
		if dateStr == "" {
			return nil, nil
		}
		t, err := time.ParseInLocation(time.DateOnly, dateStr, location)
		if err != nil {
			return nil, fmt.Errorf("failed to parse date %q: %v", dateStr, err)
		}
		return &t, nil
	}

	value, err := parseDate(conv.SafeValue(data.Value))
	if err != nil {
		return nil, err
	}

	defaultValue, err := parseDate(conv.SafeValue(data.DefaultValue))
	if err != nil {
		return nil, err
	}

	maxValue, err := parseDate(data.MaxValue)
	if err != nil {
		return nil, err
	}

	minValue, err := parseDate(data.MinValue)
	if err != nil {
		return nil, err
	}

	return &state.DateInputState{
		ID:           id,
		Value:        value,
		Label:        data.Label,
		DefaultValue: defaultValue,
		Placeholder:  data.Placeholder,
		Required:     data.Required,
		Disabled:     data.Disabled,
		Format:       data.Format,
		MaxValue:     maxValue,
		MinValue:     minValue,
		Location:     location,
	}, nil
}

func convertStateToDateInputProto(state *state.DateInputState) *widgetv1.DateInput {
	if state == nil {
		return nil
	}
	var value, defaultValue, maxValue, minValue string
	if state.Value != nil {
		value = state.Value.Format(time.DateOnly)
	}
	if state.DefaultValue != nil {
		defaultValue = state.DefaultValue.Format(time.DateOnly)
	}
	if state.MaxValue != nil {
		maxValue = state.MaxValue.Format(time.DateOnly)
	}
	if state.MinValue != nil {
		minValue = state.MinValue.Format(time.DateOnly)
	}
	return &widgetv1.DateInput{
		Value:        conv.NilValue(value),
		Label:        state.Label,
		Placeholder:  state.Placeholder,
		DefaultValue: conv.NilValue(defaultValue),
		Required:     state.Required,
		Disabled:     state.Disabled,
		Format:       state.Format,
		MaxValue:     maxValue,
		MinValue:     minValue,
	}
}
</file>

<file path="datetimeinput_test.go">
package sourcetool

import (
	"context"
	"testing"
	"time"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/datetimeinput"
	"github.com/trysourcetool/sourcetool-go/internal/conv"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
)

func TestConvertStateToDateTimeInputProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	now := time.Now()
	maxDate := now.AddDate(1, 0, 0)
	minDate := now.AddDate(-1, 0, 0)

	dateTimeInputState := &state.DateTimeInputState{
		ID:           id,
		Label:        "Test DateTimeInput",
		Value:        &now,
		Placeholder:  "Select date and time",
		DefaultValue: &now,
		Required:     true,
		Disabled:     false,
		Format:       "YYYY/MM/DD HH:MM:SS",
		MaxValue:     &maxDate,
		MinValue:     &minDate,
		Location:     time.Local,
	}

	data := convertStateToDateTimeInputProto(dateTimeInputState)

	if data == nil {
		t.Fatal("convertStateToDateTimeInputProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", data.Label, dateTimeInputState.Label},
		{"Value", conv.SafeValue(data.Value), dateTimeInputState.Value.Format(time.DateTime)},
		{"Placeholder", data.Placeholder, dateTimeInputState.Placeholder},
		{"DefaultValue", conv.SafeValue(data.DefaultValue), dateTimeInputState.DefaultValue.Format(time.DateTime)},
		{"Required", data.Required, dateTimeInputState.Required},
		{"Disabled", data.Disabled, dateTimeInputState.Disabled},
		{"Format", data.Format, dateTimeInputState.Format},
		{"MaxValue", data.MaxValue, dateTimeInputState.MaxValue.Format(time.DateTime)},
		{"MinValue", data.MinValue, dateTimeInputState.MinValue.Format(time.DateTime)},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertDateTimeInputProtoToState(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	now := time.Now()
	dateStr := now.Format(time.DateTime)
	maxDateStr := now.AddDate(1, 0, 0).Format(time.DateTime)
	minDateStr := now.AddDate(-1, 0, 0).Format(time.DateTime)

	data := &widgetv1.DateTimeInput{
		Label:        "Test DateTimeInput",
		Value:        conv.NilValue(dateStr),
		Placeholder:  "Select date and time",
		DefaultValue: conv.NilValue(dateStr),
		Required:     true,
		Disabled:     false,
		Format:       "YYYY/MM/DD HH:MM:SS",
		MaxValue:     maxDateStr,
		MinValue:     minDateStr,
	}

	state, err := convertDateTimeInputProtoToState(id, data, time.Local)
	if err != nil {
		t.Fatalf("convertDateTimeInputProtoToState returned error: %v", err)
	}

	if state == nil {
		t.Fatal("convertDateTimeInputProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ID", state.ID, id},
		{"Label", state.Label, data.Label},
		{"Value", state.Value.Format(time.DateTime), conv.SafeValue(data.Value)},
		{"Placeholder", state.Placeholder, data.Placeholder},
		{"DefaultValue", state.DefaultValue.Format(time.DateTime), conv.SafeValue(data.DefaultValue)},
		{"Required", state.Required, data.Required},
		{"Disabled", state.Disabled, data.Disabled},
		{"Format", state.Format, data.Format},
		{"MaxValue", state.MaxValue.Format(time.DateTime), data.MaxValue},
		{"MinValue", state.MinValue.Format(time.DateTime), data.MinValue},
		{"Location", state.Location.String(), time.Local.String()},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertDateTimeInputProtoToState_InvalidDateTime(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	data := &widgetv1.DateTimeInput{
		Value: conv.NilValue("invalid-datetime"),
	}

	_, err := convertDateTimeInputProtoToState(id, data, time.Local)
	if err == nil {
		t.Error("Expected error for invalid datetime, got nil")
	}
}

func TestDateTimeInput(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test DateTimeInput"
	now := time.Now()
	maxDate := now.AddDate(1, 0, 0)
	minDate := now.AddDate(-1, 0, 0)
	placeholder := "Select date and time"
	format := "YYYY-MM-DD HH:mm:ss"
	location := *time.UTC

	value := builder.DateTimeInput(label,
		datetimeinput.WithDefaultValue(now),
		datetimeinput.WithPlaceholder(placeholder),
		datetimeinput.WithRequired(true),
		datetimeinput.WithDisabled(true),
		datetimeinput.WithFormat(format),
		datetimeinput.WithMaxValue(maxDate),
		datetimeinput.WithMinValue(minDate),
		datetimeinput.WithLocation(location),
	)

	if value == nil {
		t.Fatal("DateTimeInput returned nil")
	}
	if !value.Equal(now) {
		t.Errorf("DateTimeInput value = %v, want %v", value, now)
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeDateTimeInput, []int{0})
	state := sess.State.GetDateTimeInput(widgetID)
	if state == nil {
		t.Fatal("DateTimeInput state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, label},
		{"Placeholder", state.Placeholder, placeholder},
		{"Required", state.Required, true},
		{"Disabled", state.Disabled, true},
		{"Format", state.Format, format},
		{"Location", state.Location.String(), location.String()},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}

	if !state.Value.Equal(*value) {
		t.Errorf("Value = %v, want %v", state.Value, value)
	}
	if !state.DefaultValue.Equal(now) {
		t.Errorf("DefaultValue = %v, want %v", state.DefaultValue, now)
	}
	if !state.MaxValue.Equal(maxDate) {
		t.Errorf("MaxValue = %v, want %v", state.MaxValue, maxDate)
	}
	if !state.MinValue.Equal(minDate) {
		t.Errorf("MinValue = %v, want %v", state.MinValue, minDate)
	}
}

func TestDateTimeInput_DefaultValues(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test DateTimeInput"

	builder.DateTimeInput(label)

	widgetID := builder.generatePageID(state.WidgetTypeDateTimeInput, []int{0})
	state := sess.State.GetDateTimeInput(widgetID)
	if state == nil {
		t.Fatal("DateTimeInput state not found")
	}

	if state.Format != "YYYY/MM/DD HH:MM:SS" {
		t.Errorf("Default Format = %v, want YYYY/MM/DD HH:MM:SS", state.Format)
	}
	if state.Location != time.Local {
		t.Errorf("Default Location = %v, want %v", state.Location, time.Local)
	}
	if state.Required {
		t.Error("Default Required = true, want false")
	}
	if state.Disabled {
		t.Error("Default Disabled = true, want false")
	}
}
</file>

<file path="datetimeinput.go">
package sourcetool

import (
	"fmt"
	"time"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/datetimeinput"
	"github.com/trysourcetool/sourcetool-go/internal/conv"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
)

func (b *uiBuilder) DateTimeInput(label string, opts ...datetimeinput.Option) *time.Time {
	dateTimeInputOpts := &options.DateTimeInputOptions{
		Label:        label,
		Placeholder:  "",
		DefaultValue: nil,
		Required:     false,
		Disabled:     false,
		Format:       "YYYY/MM/DD HH:MM:SS",
		MaxValue:     nil,
		MinValue:     nil,
		Location:     time.Local,
	}

	for _, o := range opts {
		o.Apply(dateTimeInputOpts)
	}

	sess := b.session
	if sess == nil {
		return nil
	}
	page := b.page
	if page == nil {
		return nil
	}
	cursor := b.cursor
	if cursor == nil {
		return nil
	}
	path := cursor.getPath()

	widgetID := b.generatePageID(state.WidgetTypeDateTimeInput, path)
	dateTimeInputState := sess.State.GetDateTimeInput(widgetID)
	if dateTimeInputState == nil {
		dateTimeInputState = &state.DateTimeInputState{
			ID:    widgetID,
			Value: dateTimeInputOpts.DefaultValue,
		}
	}
	dateTimeInputState.Label = dateTimeInputOpts.Label
	dateTimeInputState.Placeholder = dateTimeInputOpts.Placeholder
	dateTimeInputState.DefaultValue = dateTimeInputOpts.DefaultValue
	dateTimeInputState.Required = dateTimeInputOpts.Required
	dateTimeInputState.Disabled = dateTimeInputOpts.Disabled
	dateTimeInputState.Format = dateTimeInputOpts.Format
	dateTimeInputState.MaxValue = dateTimeInputOpts.MaxValue
	dateTimeInputState.MinValue = dateTimeInputOpts.MinValue
	dateTimeInputState.Location = dateTimeInputOpts.Location
	sess.State.Set(widgetID, dateTimeInputState)

	dateTimeInput := convertStateToDateTimeInputProto(dateTimeInputState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_DateTimeInput{
				DateTimeInput: dateTimeInput,
			},
		},
	})

	cursor.next()

	return dateTimeInputState.Value
}

func convertDateTimeInputProtoToState(id uuid.UUID, data *widgetv1.DateTimeInput, location *time.Location) (*state.DateTimeInputState, error) {
	if data == nil {
		return nil, nil
	}

	parseDate := func(dateStr string) (*time.Time, error) {
		if dateStr == "" {
			return nil, nil
		}
		t, err := time.ParseInLocation(time.DateTime, dateStr, location)
		if err != nil {
			return nil, fmt.Errorf("failed to parse date %q: %v", dateStr, err)
		}
		return &t, nil
	}

	value, err := parseDate(conv.SafeValue(data.Value))
	if err != nil {
		return nil, err
	}

	defaultValue, err := parseDate(conv.SafeValue(data.DefaultValue))
	if err != nil {
		return nil, err
	}

	maxValue, err := parseDate(data.MaxValue)
	if err != nil {
		return nil, err
	}

	minValue, err := parseDate(data.MinValue)
	if err != nil {
		return nil, err
	}

	return &state.DateTimeInputState{
		ID:           id,
		Value:        value,
		Label:        data.Label,
		DefaultValue: defaultValue,
		Placeholder:  data.Placeholder,
		Required:     data.Required,
		Disabled:     data.Disabled,
		Format:       data.Format,
		MaxValue:     maxValue,
		MinValue:     minValue,
		Location:     location,
	}, nil
}

func convertStateToDateTimeInputProto(state *state.DateTimeInputState) *widgetv1.DateTimeInput {
	if state == nil {
		return nil
	}
	var value, defaultValue, maxValue, minValue string
	if state.Value != nil {
		value = state.Value.Format(time.DateTime)
	}
	if state.DefaultValue != nil {
		defaultValue = state.DefaultValue.Format(time.DateTime)
	}
	if state.MaxValue != nil {
		maxValue = state.MaxValue.Format(time.DateTime)
	}
	if state.MinValue != nil {
		minValue = state.MinValue.Format(time.DateTime)
	}
	return &widgetv1.DateTimeInput{
		Value:        conv.NilValue(value),
		Label:        state.Label,
		Placeholder:  state.Placeholder,
		DefaultValue: conv.NilValue(defaultValue),
		Required:     state.Required,
		Disabled:     state.Disabled,
		Format:       state.Format,
		MaxValue:     maxValue,
		MinValue:     minValue,
	}
}
</file>

<file path="form_test.go">
package sourcetool

import (
	"context"
	"testing"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/form"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
)

func TestConvertStateToFormProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	formState := &state.FormState{
		ID:             id,
		Value:          true,
		ButtonLabel:    "Submit",
		ButtonDisabled: true,
		ClearOnSubmit:  true,
	}

	data := convertStateToFormProto(formState)

	if data == nil {
		t.Fatal("convertStateToFormProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Value", data.Value, formState.Value},
		{"ButtonLabel", data.ButtonLabel, formState.ButtonLabel},
		{"ButtonDisabled", data.ButtonDisabled, formState.ButtonDisabled},
		{"ClearOnSubmit", data.ClearOnSubmit, formState.ClearOnSubmit},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertFormProtoToState(t *testing.T) {
	data := &widgetv1.Form{
		Value:          true,
		ButtonLabel:    "Submit",
		ButtonDisabled: true,
		ClearOnSubmit:  true,
	}

	state := convertFormProtoToState(uuid.Must(uuid.NewV4()), data)

	if state == nil {
		t.Fatal("convertFormProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Value", state.Value, data.Value},
		{"ButtonLabel", state.ButtonLabel, data.ButtonLabel},
		{"ButtonDisabled", state.ButtonDisabled, data.ButtonDisabled},
		{"ClearOnSubmit", state.ClearOnSubmit, data.ClearOnSubmit},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestForm(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	buttonLabel := "Submit"
	childBuilder, submitted := builder.Form(buttonLabel)

	if childBuilder == nil {
		t.Fatal("Form returned nil builder")
	}
	if submitted {
		t.Error("Form returned true for submitted, want false")
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeForm, []int{0})
	state := sess.State.GetForm(widgetID)
	if state == nil {
		t.Fatal("Form state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ButtonLabel", state.ButtonLabel, buttonLabel},
		{"ButtonDisabled", state.ButtonDisabled, false}, // default value
		{"ClearOnSubmit", state.ClearOnSubmit, false},   // default value
		{"Value", state.Value, false},                   // default value
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestForm_WithOptions(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	buttonLabel := "Submit"
	childBuilder, submitted := builder.Form(buttonLabel,
		form.WithButtonDisabled(true),
		form.WithClearOnSubmit(true),
	)

	if childBuilder == nil {
		t.Fatal("Form returned nil builder")
	}
	if submitted {
		t.Error("Form returned true for submitted, want false")
	}

	widgetID := builder.generatePageID(state.WidgetTypeForm, []int{0})
	state := sess.State.GetForm(widgetID)
	if state == nil {
		t.Fatal("Form state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ButtonLabel", state.ButtonLabel, buttonLabel},
		{"ButtonDisabled", state.ButtonDisabled, true},
		{"ClearOnSubmit", state.ClearOnSubmit, true},
		{"Value", state.Value, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}
</file>

<file path="form.go">
package sourcetool

import (
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/form"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
)

func (b *uiBuilder) Form(buttonLabel string, opts ...form.Option) (UIBuilder, bool) {
	formOpts := &options.FormOptions{
		ButtonLabel:    buttonLabel,
		ButtonDisabled: false,
		ClearOnSubmit:  false,
	}

	for _, o := range opts {
		o.Apply(formOpts)
	}

	sess := b.session
	if sess == nil {
		return b, false
	}
	page := b.page
	if page == nil {
		return b, false
	}
	cursor := b.cursor
	if cursor == nil {
		return b, false
	}
	path := cursor.getPath()

	widgetID := b.generatePageID(state.WidgetTypeForm, path)
	formState := sess.State.GetForm(widgetID)
	if formState == nil {
		formState = &state.FormState{
			ID:    widgetID,
			Value: false,
		}
	}
	formState.ButtonLabel = formOpts.ButtonLabel
	formState.ButtonDisabled = formOpts.ButtonDisabled
	formState.ClearOnSubmit = formOpts.ClearOnSubmit
	sess.State.Set(widgetID, formState)

	form := convertStateToFormProto(formState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_Form{
				Form: form,
			},
		},
	})

	cursor.next()

	childCursor := newCursor()
	childCursor.parentPath = path

	childBuilder := &uiBuilder{
		runtime: b.runtime,
		session: sess,
		page:    page,
		cursor:  childCursor,
	}

	return childBuilder, formState.Value
}

func convertStateToFormProto(state *state.FormState) *widgetv1.Form {
	if state == nil {
		return nil
	}
	return &widgetv1.Form{
		Value:          state.Value,
		ButtonLabel:    state.ButtonLabel,
		ButtonDisabled: state.ButtonDisabled,
		ClearOnSubmit:  state.ClearOnSubmit,
	}
}

func convertFormProtoToState(id uuid.UUID, data *widgetv1.Form) *state.FormState {
	if data == nil {
		return nil
	}
	return &state.FormState{
		ID:             id,
		Value:          data.Value,
		ButtonLabel:    data.ButtonLabel,
		ButtonDisabled: data.ButtonDisabled,
		ClearOnSubmit:  data.ClearOnSubmit,
	}
}
</file>

<file path="go.mod">
module github.com/trysourcetool/sourcetool-go

go 1.22

require (
	github.com/gofrs/uuid/v5 v5.3.0
	github.com/gorilla/websocket v1.5.3
	github.com/samber/lo v1.47.0
	go.uber.org/zap v1.27.0
	google.golang.org/protobuf v1.32.0
)

require (
	go.uber.org/multierr v1.11.0 // indirect
	golang.org/x/text v0.16.0 // indirect
)
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Sourcetool

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="markdown_test.go">
package sourcetool

import (
	"context"
	"testing"

	"github.com/gofrs/uuid/v5"

	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
)

func TestConvertStateToMarkdownProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	markdownState := &state.MarkdownState{
		ID:   id,
		Body: "# Test Markdown",
	}

	data := convertStateToMarkdownProto(markdownState)

	if data == nil {
		t.Fatal("convertStateToMarkdownProto returned nil")
	}

	if data.Body != markdownState.Body {
		t.Errorf("Body = %v, want %v", data.Body, markdownState.Body)
	}
}

func TestConvertMarkdownProtoToState(t *testing.T) {
	data := &widgetv1.Markdown{
		Body: "# Test Markdown",
	}

	state := convertMarkdownProtoToState(uuid.Must(uuid.NewV4()), data)

	if state == nil {
		t.Fatal("convertMarkdownProtoToState returned nil")
	}

	if state.Body != data.Body {
		t.Errorf("Body = %v, want %v", state.Body, data.Body)
	}
}

func TestMarkdown(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	body := "# Test Markdown"
	builder.Markdown(body)

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeMarkdown, []int{0})
	state := sess.State.GetMarkdown(widgetID)
	if state == nil {
		t.Fatal("Markdown state not found")
	}

	if state.Body != body {
		t.Errorf("Body = %v, want %v", state.Body, body)
	}
}
</file>

<file path="markdown.go">
package sourcetool

import (
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
)

func (b *uiBuilder) Markdown(body string) {
	markdownOpts := &options.MarkdownOptions{
		Body: body,
	}

	sess := b.session
	if sess == nil {
		return
	}
	page := b.page
	if page == nil {
		return
	}
	cursor := b.cursor
	if cursor == nil {
		return
	}
	path := cursor.getPath()

	widgetID := b.generatePageID(state.WidgetTypeMarkdown, path)
	markdownState := sess.State.GetMarkdown(widgetID)
	if markdownState == nil {
		markdownState = &state.MarkdownState{
			ID: widgetID,
		}
	}
	markdownState.Body = markdownOpts.Body
	sess.State.Set(widgetID, markdownState)

	markdown := convertStateToMarkdownProto(markdownState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_Markdown{
				Markdown: markdown,
			},
		},
	})

	cursor.next()
}

func convertStateToMarkdownProto(state *state.MarkdownState) *widgetv1.Markdown {
	return &widgetv1.Markdown{
		Body: state.Body,
	}
}

func convertMarkdownProtoToState(id uuid.UUID, data *widgetv1.Markdown) *state.MarkdownState {
	return &state.MarkdownState{
		ID:   id,
		Body: data.Body,
	}
}
</file>

<file path="MIRROR_README.md">
# Sourcetool Go SDK

This repository is a read-only mirror of the Go SDK for Sourcetool. It is automatically synced from the main monorepo.

## ⚠️ Important Notice

- **Do not submit pull requests to this repository** - they will be ignored.
- **All development happens in the [main monorepo](https://github.com/trysourcetool/sourcetool)**.

## Usage

```bash
go get github.com/trysourcetool/sourcetool-go
```

## Documentation

For documentation, please visit the [official website](https://trysourcetool.com) or refer to the [main repository](https://github.com/trysourcetool/sourcetool).

## License

See the [LICENSE](LICENSE) file for license rights and limitations.
</file>

<file path="multiselect_test.go">
package sourcetool

import (
	"context"
	"reflect"
	"testing"

	"github.com/gofrs/uuid/v5"

	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
	"github.com/trysourcetool/sourcetool-go/multiselect"
)

func TestConvertStateToMultiSelectProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	value := []int32{0, 2}
	defaultValue := []int32{0}
	options := []string{"Option 1", "Option 2", "Option 3"}

	multiSelectState := &state.MultiSelectState{
		ID:           id,
		Label:        "Test MultiSelect",
		Value:        value,
		Options:      options,
		Placeholder:  "Select options",
		DefaultValue: defaultValue,
		Required:     true,
		Disabled:     false,
	}

	data := convertStateToMultiSelectProto(multiSelectState)

	if data == nil {
		t.Fatal("convertStateToMultiSelectProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", data.Label, multiSelectState.Label},
		{"Value", data.Value, multiSelectState.Value},
		{"Options length", len(data.Options), len(multiSelectState.Options)},
		{"Placeholder", data.Placeholder, multiSelectState.Placeholder},
		{"DefaultValue", data.DefaultValue, multiSelectState.DefaultValue},
		{"Required", data.Required, multiSelectState.Required},
		{"Disabled", data.Disabled, multiSelectState.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !reflect.DeepEqual(tt.got, tt.want) {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertMultiSelectProtoToState(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	value := []int32{0, 2}
	defaultValue := []int32{0}
	options := []string{"Option 1", "Option 2", "Option 3"}

	data := &widgetv1.MultiSelect{
		Label:        "Test MultiSelect",
		Value:        value,
		Options:      options,
		Placeholder:  "Select options",
		DefaultValue: defaultValue,
		Required:     true,
		Disabled:     false,
	}

	state := convertMultiSelectProtoToState(id, data)

	if state == nil {
		t.Fatal("convertMultiSelectProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ID", state.ID, id},
		{"Label", state.Label, data.Label},
		{"Value", state.Value, data.Value},
		{"Options length", len(state.Options), len(data.Options)},
		{"Placeholder", state.Placeholder, data.Placeholder},
		{"DefaultValue", state.DefaultValue, data.DefaultValue},
		{"Required", state.Required, data.Required},
		{"Disabled", state.Disabled, data.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !reflect.DeepEqual(tt.got, tt.want) {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestMultiSelect(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test MultiSelect"
	options := []string{"Option 1", "Option 2", "Option 3"}
	defaultValue := []string{"Option 1", "Option 3"}
	placeholder := "Select options"

	value := builder.MultiSelect(label,
		multiselect.WithOptions(options...),
		multiselect.WithDefaultValue(defaultValue...),
		multiselect.WithPlaceholder(placeholder),
		multiselect.WithRequired(true),
		multiselect.WithDisabled(true),
	)

	if value == nil {
		t.Fatal("MultiSelect returned nil")
	}
	if !reflect.DeepEqual(value.Values, defaultValue) {
		t.Errorf("MultiSelect values = %v, want %v", value.Values, defaultValue)
	}
	expectedIndexes := []int{0, 2}
	if !reflect.DeepEqual(value.Indexes, expectedIndexes) {
		t.Errorf("MultiSelect indexes = %v, want %v", value.Indexes, expectedIndexes)
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeMultiSelect, []int{0})
	state := sess.State.GetMultiSelect(widgetID)
	if state == nil {
		t.Fatal("MultiSelect state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, label},
		{"Options length", len(state.Options), len(options)},
		{"Placeholder", state.Placeholder, placeholder},
		{"Required", state.Required, true},
		{"Disabled", state.Disabled, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !reflect.DeepEqual(tt.got, tt.want) {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestMultiSelect_WithFormatFunc(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test MultiSelect"
	options := []string{"Option 1", "Option 2"}
	formatFunc := func(value string, index int) string {
		return value + " (Custom)"
	}

	builder.MultiSelect(label,
		multiselect.WithOptions(options...),
		multiselect.WithFormatFunc(formatFunc),
	)

	widgetID := builder.generatePageID(state.WidgetTypeMultiSelect, []int{0})
	state := sess.State.GetMultiSelect(widgetID)
	if state == nil {
		t.Fatal("MultiSelect state not found")
	}

	expectedOptions := []string{"Option 1 (Custom)", "Option 2 (Custom)"}
	if !reflect.DeepEqual(state.Options, expectedOptions) {
		t.Errorf("Formatted options = %v, want %v", state.Options, expectedOptions)
	}
}
</file>

<file path="multiselect.go">
package sourcetool

import (
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/multiselect"
)

func (b *uiBuilder) MultiSelect(label string, opts ...multiselect.Option) *multiselect.Value {
	multiSelectOpts := &options.MultiSelectOptions{
		Label:        label,
		DefaultValue: nil,
		Placeholder:  "",
		Required:     false,
		Disabled:     false,
		FormatFunc:   nil,
	}

	for _, o := range opts {
		o.Apply(multiSelectOpts)
	}

	sess := b.session
	if sess == nil {
		return nil
	}
	page := b.page
	if page == nil {
		return nil
	}
	cursor := b.cursor
	if cursor == nil {
		return nil
	}
	path := cursor.getPath()

	var defaultVal []int32
	if len(multiSelectOpts.DefaultValue) != 0 {
		for _, o := range multiSelectOpts.DefaultValue {
			for i, opt := range multiSelectOpts.Options {
				if opt == o {
					defaultVal = append(defaultVal, int32(i))
					break
				}
			}
		}
	}

	widgetID := b.generatePageID(state.WidgetTypeMultiSelect, path)
	multiSelectState := sess.State.GetMultiSelect(widgetID)
	if multiSelectState == nil {
		multiSelectState = &state.MultiSelectState{
			ID:    widgetID,
			Value: defaultVal,
		}
	}
	if multiSelectOpts.FormatFunc == nil {
		multiSelectOpts.FormatFunc = func(v string, i int) string {
			return v
		}
	}

	displayVals := make([]string, len(multiSelectOpts.Options))
	for i, v := range multiSelectOpts.Options {
		displayVals[i] = multiSelectOpts.FormatFunc(v, i)
	}

	multiSelectState.Label = multiSelectOpts.Label
	multiSelectState.Options = displayVals
	multiSelectState.Placeholder = multiSelectOpts.Placeholder
	multiSelectState.DefaultValue = defaultVal
	multiSelectState.Required = multiSelectOpts.Required
	multiSelectState.Disabled = multiSelectOpts.Disabled
	sess.State.Set(widgetID, multiSelectState)

	multiSelectProto := convertStateToMultiSelectProto(multiSelectState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_MultiSelect{
				MultiSelect: multiSelectProto,
			},
		},
	})

	cursor.next()

	var value *multiselect.Value
	if multiSelectState.Value != nil {
		value = &multiselect.Value{
			Values:  make([]string, len(multiSelectState.Value)),
			Indexes: make([]int, len(multiSelectState.Value)),
		}
		for i, idx := range multiSelectState.Value {
			value.Values[i] = multiSelectOpts.Options[idx]
			value.Indexes[i] = int(idx)
		}
	}

	return value
}

func convertStateToMultiSelectProto(state *state.MultiSelectState) *widgetv1.MultiSelect {
	if state == nil {
		return nil
	}
	return &widgetv1.MultiSelect{
		Label:        state.Label,
		Value:        state.Value,
		Options:      state.Options,
		Placeholder:  state.Placeholder,
		DefaultValue: state.DefaultValue,
		Required:     state.Required,
		Disabled:     state.Disabled,
	}
}

func convertMultiSelectProtoToState(id uuid.UUID, data *widgetv1.MultiSelect) *state.MultiSelectState {
	if data == nil {
		return nil
	}
	return &state.MultiSelectState{
		ID:           id,
		Label:        data.Label,
		Value:        data.Value,
		Options:      data.Options,
		Placeholder:  data.Placeholder,
		DefaultValue: data.DefaultValue,
		Required:     data.Required,
		Disabled:     data.Disabled,
	}
}
</file>

<file path="numberinput_test.go">
package sourcetool

import (
	"context"
	"testing"

	"github.com/gofrs/uuid/v5"

	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
	"github.com/trysourcetool/sourcetool-go/numberinput"
)

func TestConvertStateToNumberInputProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	value := 42.5
	defaultValue := 0.0
	maxValue := 100.0
	minValue := 0.0

	numberInputState := &state.NumberInputState{
		ID:           id,
		Label:        "Test NumberInput",
		Value:        &value,
		Placeholder:  "Enter number",
		DefaultValue: &defaultValue,
		Required:     true,
		Disabled:     false,
		MaxValue:     &maxValue,
		MinValue:     &minValue,
	}

	data := convertStateToNumberInputProto(numberInputState)

	if data == nil {
		t.Fatal("convertStateToNumberInputProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", data.Label, numberInputState.Label},
		{"Value", *data.Value, *numberInputState.Value},
		{"Placeholder", data.Placeholder, numberInputState.Placeholder},
		{"DefaultValue", *data.DefaultValue, *numberInputState.DefaultValue},
		{"Required", data.Required, numberInputState.Required},
		{"Disabled", data.Disabled, numberInputState.Disabled},
		{"MaxValue", *data.MaxValue, *numberInputState.MaxValue},
		{"MinValue", *data.MinValue, *numberInputState.MinValue},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertNumberInputProtoToState(t *testing.T) {
	value := 42.5
	defaultValue := 0.0
	maxValue := 100.0
	minValue := 0.0

	data := &widgetv1.NumberInput{
		Label:        "Test NumberInput",
		Value:        &value,
		Placeholder:  "Enter number",
		DefaultValue: &defaultValue,
		Required:     true,
		Disabled:     false,
		MaxValue:     &maxValue,
		MinValue:     &minValue,
	}

	state := convertNumberInputProtoToState(uuid.Must(uuid.NewV4()), data)

	if state == nil {
		t.Fatal("convertNumberInputProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, data.Label},
		{"Value", *state.Value, *data.Value},
		{"Placeholder", state.Placeholder, data.Placeholder},
		{"DefaultValue", *state.DefaultValue, *data.DefaultValue},
		{"Required", state.Required, data.Required},
		{"Disabled", state.Disabled, data.Disabled},
		{"MaxValue", *state.MaxValue, *data.MaxValue},
		{"MinValue", *state.MinValue, *data.MinValue},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestNumberInput(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test NumberInput"
	defaultValue := 42.5
	placeholder := "Enter number"
	maxValue := 100.0
	minValue := 0.0

	value := builder.NumberInput(label,
		numberinput.WithDefaultValue(defaultValue),
		numberinput.WithPlaceholder(placeholder),
		numberinput.WithRequired(true),
		numberinput.WithDisabled(true),
		numberinput.WithMaxValue(maxValue),
		numberinput.WithMinValue(minValue),
	)

	if value == nil {
		t.Fatal("NumberInput returned nil")
	}
	if *value != defaultValue {
		t.Errorf("NumberInput value = %v, want %v", *value, defaultValue)
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeNumberInput, []int{0})
	state := sess.State.GetNumberInput(widgetID)
	if state == nil {
		t.Fatal("NumberInput state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, label},
		{"Value", *state.Value, defaultValue},
		{"Placeholder", state.Placeholder, placeholder},
		{"DefaultValue", *state.DefaultValue, defaultValue},
		{"Required", state.Required, true},
		{"Disabled", state.Disabled, true},
		{"MaxValue", *state.MaxValue, maxValue},
		{"MinValue", *state.MinValue, minValue},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}
</file>

<file path="numberinput.go">
package sourcetool

import (
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/conv"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/numberinput"
)

func (b *uiBuilder) NumberInput(label string, opts ...numberinput.Option) *float64 {
	numberInputOpts := &options.NumberInputOptions{
		Label:        label,
		Placeholder:  "",
		DefaultValue: conv.NilValue(float64(0)),
		Required:     false,
		Disabled:     false,
		MaxValue:     nil,
		MinValue:     nil,
	}

	for _, o := range opts {
		o.Apply(numberInputOpts)
	}

	sess := b.session
	if sess == nil {
		return nil
	}
	page := b.page
	if page == nil {
		return nil
	}
	cursor := b.cursor
	if cursor == nil {
		return nil
	}
	path := cursor.getPath()

	widgetID := b.generatePageID(state.WidgetTypeNumberInput, path)
	numberInputState := sess.State.GetNumberInput(widgetID)
	if numberInputState == nil {
		numberInputState = &state.NumberInputState{
			ID:    widgetID,
			Value: numberInputOpts.DefaultValue,
		}
	}
	numberInputState.Label = numberInputOpts.Label
	numberInputState.Placeholder = numberInputOpts.Placeholder
	numberInputState.DefaultValue = numberInputOpts.DefaultValue
	numberInputState.Required = numberInputOpts.Required
	numberInputState.Disabled = numberInputOpts.Disabled
	numberInputState.MaxValue = numberInputOpts.MaxValue
	numberInputState.MinValue = numberInputOpts.MinValue
	sess.State.Set(widgetID, numberInputState)

	numberInput := convertStateToNumberInputProto(numberInputState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_NumberInput{
				NumberInput: numberInput,
			},
		},
	})

	cursor.next()

	return numberInputState.Value
}

func convertStateToNumberInputProto(state *state.NumberInputState) *widgetv1.NumberInput {
	if state == nil {
		return nil
	}
	return &widgetv1.NumberInput{
		Value:        state.Value,
		Label:        state.Label,
		Placeholder:  state.Placeholder,
		DefaultValue: state.DefaultValue,
		Required:     state.Required,
		Disabled:     state.Disabled,
		MaxValue:     state.MaxValue,
		MinValue:     state.MinValue,
	}
}

func convertNumberInputProtoToState(id uuid.UUID, data *widgetv1.NumberInput) *state.NumberInputState {
	if data == nil {
		return nil
	}
	return &state.NumberInputState{
		ID:           id,
		Value:        data.Value,
		Label:        data.Label,
		Placeholder:  data.Placeholder,
		DefaultValue: data.DefaultValue,
		Required:     data.Required,
		Disabled:     data.Disabled,
		MaxValue:     data.MaxValue,
		MinValue:     data.MinValue,
	}
}
</file>

<file path="page.go">
package sourcetool

import (
	"sync"

	"github.com/gofrs/uuid/v5"
)

type page struct {
	id           uuid.UUID
	name         string
	route        string
	path         []int
	handler      func(UIBuilder) error
	accessGroups []string
}

func (p *page) run(ui UIBuilder) error {
	if err := p.handler(ui); err != nil {
		return err
	}
	return nil
}

func (p *page) hasAccess(userGroups []string) bool {
	if len(p.accessGroups) == 0 {
		return true
	}

	for _, userGroup := range userGroups {
		for _, requiredGroup := range p.accessGroups {
			if userGroup == requiredGroup {
				return true
			}
		}
	}
	return false
}

type pageManager struct {
	pages map[uuid.UUID]*page
	mu    sync.RWMutex
}

func newPageManager(pages map[uuid.UUID]*page) *pageManager {
	return &pageManager{
		pages: pages,
	}
}

func (s *pageManager) getPage(id uuid.UUID) *page {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.pages[id]
}
</file>

<file path="radio_test.go">
package sourcetool

import (
	"context"
	"testing"

	"github.com/gofrs/uuid/v5"

	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
	"github.com/trysourcetool/sourcetool-go/radio"
)

func TestConvertStateToRadioProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	value := int32(1)
	defaultValue := int32(0)
	options := []string{"Option 1", "Option 2"}

	radioState := &state.RadioState{
		ID:           id,
		Label:        "Test Radio",
		Value:        &value,
		Options:      options,
		DefaultValue: &defaultValue,
		Required:     true,
		Disabled:     false,
	}

	data := convertStateToRadioProto(radioState)

	if data == nil {
		t.Fatal("convertStateToRadioProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", data.Label, radioState.Label},
		{"Value", *data.Value, *radioState.Value},
		{"Options length", len(data.Options), len(radioState.Options)},
		{"DefaultValue", *data.DefaultValue, *radioState.DefaultValue},
		{"Required", data.Required, radioState.Required},
		{"Disabled", data.Disabled, radioState.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertRadioProtoToState(t *testing.T) {
	value := int32(1)
	defaultValue := int32(0)
	options := []string{"Option 1", "Option 2"}

	data := &widgetv1.Radio{
		Label:        "Test Radio",
		Value:        &value,
		Options:      options,
		DefaultValue: &defaultValue,
		Required:     true,
		Disabled:     false,
	}

	state := convertRadioProtoToState(uuid.Must(uuid.NewV4()), data)

	if state == nil {
		t.Fatal("convertRadioProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ID", state.ID, state.ID},
		{"Label", state.Label, data.Label},
		{"Value", *state.Value, *data.Value},
		{"Options length", len(state.Options), len(data.Options)},
		{"DefaultValue", *state.DefaultValue, *data.DefaultValue},
		{"Required", state.Required, data.Required},
		{"Disabled", state.Disabled, data.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestRadio(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test Radio"
	options := []string{"Option 1", "Option 2"}
	defaultValue := "Option 1"

	value := builder.Radio(label,
		radio.WithOptions(options...),
		radio.WithDefaultValue(defaultValue),
		radio.WithRequired(true),
	)

	if value == nil {
		t.Fatal("Radio returned nil")
	}
	if value.Value != defaultValue {
		t.Errorf("Radio value = %v, want %v", value.Value, defaultValue)
	}
	if value.Index != 0 {
		t.Errorf("Radio index = %v, want 0", value.Index)
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeRadio, []int{0})
	state := sess.State.GetRadio(widgetID)
	if state == nil {
		t.Fatal("Radio state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, label},
		{"Options length", len(state.Options), len(options)},
		{"Required", state.Required, true},
		{"Disabled", state.Disabled, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestRadio_WithFormatFunc(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test Radio"
	options := []string{"Option 1", "Option 2"}
	formatFunc := func(value string, index int) string {
		return value + " (Custom)"
	}

	builder.Radio(label,
		radio.WithOptions(options...),
		radio.WithFormatFunc(formatFunc),
	)

	widgetID := builder.generatePageID(state.WidgetTypeRadio, []int{0})
	state := sess.State.GetRadio(widgetID)
	if state == nil {
		t.Fatal("Radio state not found")
	}

	expectedOptions := []string{"Option 1 (Custom)", "Option 2 (Custom)"}
	for i, opt := range state.Options {
		if opt != expectedOptions[i] {
			t.Errorf("Formatted option[%d] = %v, want %v", i, opt, expectedOptions[i])
		}
	}
}
</file>

<file path="radio.go">
package sourcetool

import (
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/conv"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/radio"
)

func (b *uiBuilder) Radio(label string, opts ...radio.Option) *radio.Value {
	radioOpts := &options.RadioOptions{
		Label:        label,
		DefaultValue: nil,
		Required:     false,
		Disabled:     false,
		FormatFunc:   nil,
	}

	for _, o := range opts {
		o.Apply(radioOpts)
	}

	sess := b.session
	if sess == nil {
		return nil
	}
	page := b.page
	if page == nil {
		return nil
	}
	cursor := b.cursor
	if cursor == nil {
		return nil
	}
	path := cursor.getPath()

	var defaultVal *int32
	if radioOpts.DefaultValue != nil {
		for i, o := range radioOpts.Options {
			if conv.SafeValue(radioOpts.DefaultValue) == o {
				v := int32(i)
				defaultVal = &v
				break
			}
		}
	}

	widgetID := b.generatePageID(state.WidgetTypeRadio, path)
	radioState := sess.State.GetRadio(widgetID)
	if radioState == nil {
		radioState = &state.RadioState{
			ID:           widgetID,
			Value:        defaultVal,
			DefaultValue: defaultVal,
		}
	}

	if radioOpts.FormatFunc == nil {
		radioOpts.FormatFunc = func(v string, i int) string {
			return v
		}
	}

	displayVals := make([]string, len(radioOpts.Options))
	for i, v := range radioOpts.Options {
		displayVals[i] = radioOpts.FormatFunc(v, i)
	}

	radioState.Label = radioOpts.Label
	radioState.Options = displayVals
	radioState.DefaultValue = defaultVal
	radioState.Required = radioOpts.Required
	radioState.Disabled = radioOpts.Disabled
	sess.State.Set(widgetID, radioState)

	radioProto := convertStateToRadioProto(radioState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_Radio{
				Radio: radioProto,
			},
		},
	})

	cursor.next()

	var value *radio.Value
	if radioState.Value != nil {
		value = &radio.Value{
			Value: radioOpts.Options[*radioState.Value],
			Index: int(conv.SafeValue(radioState.Value)),
		}
	}

	return value
}

func convertStateToRadioProto(state *state.RadioState) *widgetv1.Radio {
	if state == nil {
		return nil
	}
	return &widgetv1.Radio{
		Label:        state.Label,
		Value:        state.Value,
		Options:      state.Options,
		DefaultValue: state.DefaultValue,
		Required:     state.Required,
		Disabled:     state.Disabled,
	}
}

func convertRadioProtoToState(id uuid.UUID, data *widgetv1.Radio) *state.RadioState {
	if data == nil {
		return nil
	}
	return &state.RadioState{
		ID:           id,
		Label:        data.Label,
		Value:        data.Value,
		Options:      data.Options,
		DefaultValue: data.DefaultValue,
		Required:     data.Required,
		Disabled:     data.Disabled,
	}
}
</file>

<file path="router_test.go">
package sourcetool

import (
	"errors"
	"testing"
)

func TestJoinPath(t *testing.T) {
	tests := []struct {
		name     string
		basePath string
		path     string
		want     string
	}{
		{
			name:     "Empty base path",
			basePath: "",
			path:     "/users",
			want:     "/users",
		},
		{
			name:     "Base path with trailing slash",
			basePath: "/admin/",
			path:     "users",
			want:     "/admin/users",
		},
		{
			name:     "Path without leading slash",
			basePath: "/admin",
			path:     "users",
			want:     "/admin/users",
		},
		{
			name:     "Both with slashes",
			basePath: "/admin/",
			path:     "/users/",
			want:     "/admin/users",
		},
		{
			name:     "Nested paths",
			basePath: "/api/v1",
			path:     "users/list",
			want:     "/api/v1/users/list",
		},
		{
			name:     "Root path",
			basePath: "",
			path:     "/",
			want:     "/",
		},
		{
			name:     "Root path with base path",
			basePath: "/admin",
			path:     "/",
			want:     "/admin",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := &router{basePath: tt.basePath}
			got := r.joinPath(tt.path)
			if got != tt.want {
				t.Errorf("joinPath() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRemoveDuplicates(t *testing.T) {
	tests := []struct {
		name   string
		groups []string
		want   []string
	}{
		{
			name:   "No duplicates",
			groups: []string{"admin", "user", "guest"},
			want:   []string{"admin", "user", "guest"},
		},
		{
			name:   "With duplicates",
			groups: []string{"admin", "user", "admin", "guest", "user"},
			want:   []string{"admin", "user", "guest"},
		},
		{
			name:   "Empty slice",
			groups: []string{},
			want:   []string{},
		},
		{
			name:   "Single element",
			groups: []string{"admin"},
			want:   []string{"admin"},
		},
		{
			name:   "All duplicates",
			groups: []string{"admin", "admin", "admin"},
			want:   []string{"admin"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := removeDuplicates(tt.groups)
			if len(got) != len(tt.want) {
				t.Errorf("removeDuplicates() length = %v, want %v", len(got), len(tt.want))
			}
			for _, w := range tt.want {
				found := false
				for _, g := range got {
					if g == w {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("removeDuplicates() missing element %v", w)
				}
			}
		})
	}
}

func TestGeneratePageID(t *testing.T) {
	r := &router{
		namespaceDNS: "test.trysourcetool.com",
	}

	tests := []struct {
		name     string
		path     string
		wantSame bool
	}{
		{
			name:     "Simple path",
			path:     "/users",
			wantSame: true,
		},
		{
			name:     "Nested path",
			path:     "/admin/users/list",
			wantSame: true,
		},
		{
			name:     "Root path",
			path:     "/",
			wantSame: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			id1 := r.generatePageID(tt.path)
			id2 := r.generatePageID(tt.path)

			if tt.wantSame && id1 != id2 {
				t.Errorf("generatePageID() generated different IDs for same path")
			}

			differentPath := tt.path + "/different"
			id3 := r.generatePageID(differentPath)
			if id1 == id3 {
				t.Errorf("generatePageID() generated same ID for different paths")
			}
		})
	}
}

func TestRouterAccessGroups(t *testing.T) {
	pageHandler := func(ui UIBuilder) error { return nil }

	t.Run("Group creation before and after AccessGroups", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)

		st.AccessGroups("global")
		admin := st.Group("/admin")
		admin.Page("/dashboard", "Dashboard", pageHandler)

		users := st.Group("/users")
		users.AccessGroups("user_manager")
		users.Page("/list", "User List", pageHandler)

		tests := []struct {
			path           string
			expectedGroups []string
		}{
			{"/admin/dashboard", []string{"global"}},
			{"/users/list", []string{"global", "user_manager"}},
		}

		for _, tt := range tests {
			t.Run(tt.path, func(t *testing.T) {
				page := findPageByPath(st.pages, tt.path)
				assertPageGroups(t, page, tt.expectedGroups)
			})
		}
	})

	t.Run("Multiple AccessGroups calls", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		admin := st.Group("/admin")

		admin.AccessGroups("admin")
		admin.AccessGroups("super_admin")
		admin.Page("/settings", "Settings", pageHandler)

		userAdminGroup := admin.Group("/")
		userAdminGroup.AccessGroups("user_admin").Page("/users", "Users", pageHandler)
		systemAdminGroup := admin.Group("/")
		systemAdminGroup.AccessGroups("system_admin").Page("/system", "System", pageHandler)

		tests := []struct {
			path           string
			expectedGroups []string
		}{
			{"/admin/settings", []string{"admin", "super_admin"}},
			{"/admin/users", []string{"admin", "super_admin", "user_admin"}},
			{"/admin/system", []string{"admin", "super_admin", "system_admin"}},
		}

		for _, tt := range tests {
			t.Run(tt.path, func(t *testing.T) {
				page := findPageByPath(st.pages, tt.path)
				assertPageGroups(t, page, tt.expectedGroups)
			})
		}
	})

	t.Run("Sibling groups inheritance", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		st.AccessGroups("global")

		users := st.Group("/users")
		users.AccessGroups("user_admin")
		users.Page("/list", "Users", pageHandler)

		products := st.Group("/products")
		products.AccessGroups("product_admin")
		products.Page("/list", "Products", pageHandler)

		tests := []struct {
			path           string
			expectedGroups []string
		}{
			{"/users/list", []string{"global", "user_admin"}},
			{"/products/list", []string{"global", "product_admin"}},
		}

		for _, tt := range tests {
			t.Run(tt.path, func(t *testing.T) {
				page := findPageByPath(st.pages, tt.path)
				assertPageGroups(t, page, tt.expectedGroups)
			})
		}
	})

	t.Run("Deep nested groups inheritance", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		st.AccessGroups("global")

		api := st.Group("/api")
		api.AccessGroups("api_user")

		v1 := api.Group("/v1")
		v1.AccessGroups("v1_user")

		users := v1.Group("/users")
		users.AccessGroups("user_admin")

		settings := users.Group("/settings")
		settings.AccessGroups("settings_admin")
		settings.Page("/profile", "Profile Settings", pageHandler)

		page := findPageByPath(st.pages, "/api/v1/users/settings/profile")
		expectedGroups := []string{"global", "api_user", "v1_user", "user_admin", "settings_admin"}
		assertPageGroups(t, page, expectedGroups)
	})

	t.Run("Mixed group and page specific access groups", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)

		admin := st.Group("/admin")
		admin.AccessGroups("admin")
		admin.Page("/dashboard", "Dashboard", pageHandler)

		settings := admin.Group("/settings")
		settings.AccessGroups("settings_admin")
		settings.AccessGroups("system_admin")
		settings.Page("/general", "General Settings", pageHandler)

		users := settings.Group("/users")
		users.AccessGroups("user_manager")
		users.AccessGroups("profile_admin").Page("/profiles", "User Profiles", pageHandler)

		tests := []struct {
			path           string
			expectedGroups []string
		}{
			{"/admin/dashboard", []string{"admin"}},
			{"/admin/settings/general", []string{"admin", "settings_admin", "system_admin"}},
			{"/admin/settings/users/profiles", []string{"admin", "settings_admin", "system_admin", "user_manager", "profile_admin"}},
		}

		for _, tt := range tests {
			t.Run(tt.path, func(t *testing.T) {
				page := findPageByPath(st.pages, tt.path)
				assertPageGroups(t, page, tt.expectedGroups)
			})
		}
	})
}

func assertPageGroups(t *testing.T, page *page, expectedGroups []string) {
	t.Helper()

	if page == nil {
		t.Fatal("Page not found")
	}

	if len(page.accessGroups) != len(expectedGroups) {
		t.Errorf("Expected %d access groups, got %d", len(expectedGroups), len(page.accessGroups))
		t.Errorf("Expected groups: %v, got: %v", expectedGroups, page.accessGroups)
		return
	}

	for _, expectedGroup := range expectedGroups {
		found := false
		for _, actualGroup := range page.accessGroups {
			if actualGroup == expectedGroup {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected group %s not found in %v", expectedGroup, page.accessGroups)
		}
	}
}

func TestRouterGroup(t *testing.T) {
	pageHandler := func(ui UIBuilder) error { return nil }

	t.Run("Base path construction", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		admin := st.Group("/admin")
		settings := admin.Group("/settings")
		settings.Page("/users", "User Settings", pageHandler)

		page := findPageByPath(st.pages, "/admin/settings/users")
		if page == nil {
			t.Fatal("Page not found")
		}

		if page.route != "/admin/settings/users" {
			t.Errorf("Expected route /admin/settings/users, got %s", page.route)
		}
	})

	t.Run("Multiple nested groups", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		api := st.Group("/api")
		v1 := api.Group("/v1")
		users := v1.Group("/users")
		users.Page("/list", "List Users", pageHandler)

		page := findPageByPath(st.pages, "/api/v1/users/list")
		if page == nil {
			t.Fatal("Page not found")
		}

		if page.route != "/api/v1/users/list" {
			t.Errorf("Expected route /api/v1/users/list, got %s", page.route)
		}
	})
}

func TestRouter_Page(t *testing.T) {
	t.Run("Basic page", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		handler := func(ui UIBuilder) error { return nil }
		st.Page("/test", "Test Page", handler)

		page := findPageByPath(st.pages, "/test")
		if page == nil {
			t.Fatal("Page not found")
		}

		if page.name != "Test Page" {
			t.Errorf("Page name = %v, want %v", page.name, "Test Page")
		}
	})

	t.Run("Skip top-level root path", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		handler := func(ui UIBuilder) error { return nil }
		st.Page("/", "Root Page", handler)

		page := findPageByPath(st.pages, "/")
		if page != nil {
			t.Error("Top-level root path page should not be created")
		}

		// Verify that other pages can still be created
		st.Page("/other", "Other Page", handler)
		otherPage := findPageByPath(st.pages, "/other")
		if otherPage == nil {
			t.Error("Other page should be created")
		}
	})

	t.Run("Allow nested root path", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		handler := func(ui UIBuilder) error { return nil }

		users := st.Group("/users")
		users.Page("/", "Users List", handler)

		page := findPageByPath(st.pages, "/users")
		if page == nil {
			t.Error("Nested root path page should be created")
		}
		if page != nil && page.name != "Users List" {
			t.Errorf("Page name = %v, want %v", page.name, "Users List")
		}

		// Test deeply nested root path
		admin := st.Group("/admin")
		settings := admin.Group("/settings")
		settings.Page("/", "Settings Home", handler)

		settingsPage := findPageByPath(st.pages, "/admin/settings")
		if settingsPage == nil {
			t.Error("Deeply nested root path page should be created")
		}
		if settingsPage != nil && settingsPage.name != "Settings Home" {
			t.Errorf("Page name = %v, want %v", settingsPage.name, "Settings Home")
		}
	})

	t.Run("Page with access groups", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		st.AccessGroups("admin")
		handler := func(ui UIBuilder) error { return nil }
		st.Page("/admin", "Admin Page", handler)

		page := findPageByPath(st.pages, "/admin")
		if page == nil {
			t.Fatal("Page not found")
		}

		if len(page.accessGroups) != 1 || page.accessGroups[0] != "admin" {
			t.Errorf("Expected [admin] access group, got %v", page.accessGroups)
		}
	})

	t.Run("Page with error handler", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		handler := func(ui UIBuilder) error {
			return errors.New("test error")
		}
		st.Page("/error", "Error Page", handler)

		page := findPageByPath(st.pages, "/error")
		if page == nil {
			t.Fatal("Page not found")
		}

		if err := page.run(nil); err == nil {
			t.Error("Expected error from handler, got nil")
		}
	})

	t.Run("Page with empty route", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		handler := func(ui UIBuilder) error { return nil }
		st.Page("", "Root Page", handler)

		page := findPageByPath(st.pages, "/")
		if page == nil {
			t.Fatal("Page not found")
		}

		if page.route != "/" {
			t.Errorf("Expected route '/', got %q", page.route)
		}

		if page.name != "Root Page" {
			t.Errorf("Expected page name 'Root Page', got %q", page.name)
		}
	})

	t.Run("Page with duplicate route", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		handler := func(ui UIBuilder) error { return nil }
		st.Page("/duplicate", "First Page", handler)
		st.Page("/duplicate", "Second Page", handler)

		page := findPageByPath(st.pages, "/duplicate")
		if page == nil {
			t.Fatal("Page not found")
		}

		if page.name != "Second Page" {
			t.Errorf("Expected page name to be 'Second Page', got %q", page.name)
		}
	})
}

func TestRouter_Group(t *testing.T) {
	t.Run("Basic group", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		group := st.Group("/test")

		if group == nil {
			t.Fatal("Group returned nil")
		}

		handler := func(ui UIBuilder) error { return nil }
		group.Page("/page", "Test Page", handler)

		page := findPageByPath(st.pages, "/test/page")
		if page == nil {
			t.Fatal("Page not found")
		}
	})

	t.Run("Group with access groups", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		group := st.Group("/admin")
		group.AccessGroups("admin")

		handler := func(ui UIBuilder) error { return nil }
		group.Page("/dashboard", "Admin Dashboard", handler)

		page := findPageByPath(st.pages, "/admin/dashboard")
		if page == nil {
			t.Fatal("Page not found")
		}

		if len(page.accessGroups) != 1 || page.accessGroups[0] != "admin" {
			t.Errorf("Expected [admin] access group, got %v", page.accessGroups)
		}
	})

	t.Run("Nested groups", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		parent := st.Group("/parent")
		child := parent.Group("/child")

		if child == nil {
			t.Fatal("Child group returned nil")
		}

		handler := func(ui UIBuilder) error { return nil }
		child.Page("/page", "Test Page", handler)

		page := findPageByPath(st.pages, "/parent/child/page")
		if page == nil {
			t.Fatal("Page not found")
		}
	})

	t.Run("Group with empty path", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		group := st.Group("")

		if group == nil {
			t.Fatal("Group returned nil")
		}

		handler := func(ui UIBuilder) error { return nil }
		group.Page("/page", "Test Page", handler)

		page := findPageByPath(st.pages, "/page")
		if page == nil {
			t.Fatal("Page not found")
		}
	})
}

func TestRouter_AccessGroups(t *testing.T) {
	t.Run("Set access groups", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		st.AccessGroups("admin", "user")

		handler := func(ui UIBuilder) error { return nil }
		st.Page("/test", "Test Page", handler)

		page := findPageByPath(st.pages, "/test")
		if page == nil {
			t.Fatal("Page not found")
		}

		if len(page.accessGroups) != 2 {
			t.Errorf("Expected 2 access groups, got %d", len(page.accessGroups))
		}

		expectedGroups := []string{"admin", "user"}
		for _, group := range expectedGroups {
			found := false
			for _, actualGroup := range page.accessGroups {
				if actualGroup == group {
					found = true
					break
				}
			}
			if !found {
				t.Errorf("Expected group %s not found in %v", group, page.accessGroups)
			}
		}
	})

	t.Run("Clear access groups", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		st.AccessGroups("admin")
		st.AccessGroups()

		handler := func(ui UIBuilder) error { return nil }
		st.Page("/test", "Test Page", handler)

		page := findPageByPath(st.pages, "/test")
		if page == nil {
			t.Fatal("Page not found")
		}

		if len(page.accessGroups) != 1 || page.accessGroups[0] != "admin" {
			t.Errorf("Expected [admin] access group, got %v", page.accessGroups)
		}
	})
}
</file>

<file path="router.go">
package sourcetool

import (
	"strings"

	"github.com/gofrs/uuid/v5"
)

type Router interface {
	Page(relativePath, name string, handler func(UIBuilder) error)
	AccessGroups(groups ...string) Router
	Group(relativePath string) Router
}

type router struct {
	parent       *router
	sourcetool   *Sourcetool
	basePath     string
	namespaceDNS string
	groups       []string
}

func newRouter(st *Sourcetool, namespaceDNS string) Router {
	return &router{
		groups:       make([]string, 0),
		sourcetool:   st,
		namespaceDNS: namespaceDNS,
	}
}

func (r *router) generatePageID(fullPath string) uuid.UUID {
	ns := uuid.NewV5(uuid.NamespaceDNS, r.namespaceDNS)
	return uuid.NewV5(ns, fullPath)
}

func (r *router) joinPath(relativePath string) string {
	if !strings.HasPrefix(relativePath, "/") {
		relativePath = "/" + relativePath
	}
	if r.basePath == "" {
		if relativePath == "/" {
			return relativePath
		}
		return strings.TrimSuffix(relativePath, "/")
	}
	basePath := strings.TrimSuffix(r.basePath, "/")
	cleanPath := strings.TrimPrefix(relativePath, "/")
	result := basePath + "/" + cleanPath
	if result == "/" {
		return result
	}
	return strings.TrimSuffix(result, "/")
}

func removeDuplicates(groups []string) []string {
	seen := make(map[string]struct{})
	result := make([]string, 0, len(groups))

	for _, group := range groups {
		if _, exists := seen[group]; !exists {
			seen[group] = struct{}{}
			result = append(result, group)
		}
	}
	return result
}

func (r *router) collectGroups() []string {
	groups := make([]string, 0)
	current := r
	for current != nil {
		groups = append(groups, current.groups...)
		current = current.parent
	}
	return groups
}

func (r *router) Page(relativePath, name string, handler func(UIBuilder) error) {
	// Skip page creation only for top-level root path
	if relativePath == "/" && r.basePath == "" {
		return
	}

	var fullPath string
	if relativePath == "" {
		if r.basePath == "" {
			fullPath = "/"
		} else {
			fullPath = strings.TrimSuffix(r.basePath, "/")
		}
	} else {
		fullPath = r.joinPath(relativePath)
	}
	pageID := r.generatePageID(fullPath)

	page := &page{
		id:           pageID,
		name:         name,
		route:        fullPath,
		path:         []int{len(r.sourcetool.pages)},
		handler:      handler,
		accessGroups: removeDuplicates(r.collectGroups()),
	}

	r.sourcetool.addPage(pageID, page)
}

func (r *router) AccessGroups(groups ...string) Router {
	if len(groups) > 0 {
		r.groups = append(r.groups, groups...)
	}
	return r
}

func (r *router) Group(relativePath string) Router {
	newRouter := &router{
		parent:       r,
		sourcetool:   r.sourcetool,
		basePath:     r.joinPath(relativePath),
		namespaceDNS: r.namespaceDNS,
		groups:       make([]string, 0),
	}

	return newRouter
}
</file>

<file path="runtime_test.go">
package sourcetool

import (
	"testing"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/conv"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
)

func TestRuntime_HandleInitializeClient(t *testing.T) {
	pages := make(map[uuid.UUID]*page)
	pageID := uuid.Must(uuid.NewV4())

	// Test page handler
	handlerCalled := false
	testPage := &page{
		id:   pageID,
		name: "Test Page",
		handler: func(ui UIBuilder) error {
			handlerCalled = true
			return nil
		},
	}
	pages[pageID] = testPage

	mockClient := mock.NewClient()
	r := &runtime{
		wsClient:       mockClient,
		sessionManager: session.NewSessionManager(),
		pageManager:    newPageManager(pages),
	}

	// Create test message
	sessionID := uuid.Must(uuid.NewV4())
	initClient := &websocketv1.InitializeClient{
		SessionId: conv.NilValue(sessionID.String()),
		PageId:    pageID.String(),
	}

	// Register handler
	mockClient.RegisterHandler(func(msg *websocketv1.Message) error {
		switch m := msg.Type.(type) {
		case *websocketv1.Message_InitializeClient:
			return r.handleInitializeClient(m.InitializeClient)
		}
		return nil
	})

	// Send message
	mockClient.Enqueue(uuid.Must(uuid.NewV4()).String(), initClient)

	// Verify that session was created
	sess := r.sessionManager.GetSession(sessionID)
	if sess == nil {
		t.Error("session was not created")
	}

	// Verify that page handler was called
	if !handlerCalled {
		t.Error("page handler was not called")
	}
}

func TestRuntime_HandleRerunPage(t *testing.T) {
	pages := make(map[uuid.UUID]*page)
	pageID := uuid.Must(uuid.NewV4())
	sessionID := uuid.Must(uuid.NewV4())

	// Test page handler
	handlerCallCount := 0
	testPage := &page{
		id:   pageID,
		name: "Test Page",
		handler: func(ui UIBuilder) error {
			handlerCallCount++
			return nil
		},
	}
	pages[pageID] = testPage

	mockClient := mock.NewClient()
	r := &runtime{
		wsClient:       mockClient,
		sessionManager: session.NewSessionManager(),
		pageManager:    newPageManager(pages),
	}

	// Initialize session
	sess := session.New(sessionID, pageID)
	r.sessionManager.SetSession(sess)

	// Create test message
	rerunPage := &websocketv1.RerunPage{
		SessionId: sessionID.String(),
		PageId:    pageID.String(),
	}

	// Register handler
	mockClient.RegisterHandler(func(msg *websocketv1.Message) error {
		switch m := msg.Type.(type) {
		case *websocketv1.Message_RerunPage:
			return r.handleRerunPage(m.RerunPage)
		}
		return nil
	})

	// Send message
	mockClient.Enqueue(uuid.Must(uuid.NewV4()).String(), rerunPage)

	// Verify that page handler was called
	if handlerCallCount != 1 {
		t.Errorf("page handler call count = %d, want 1", handlerCallCount)
	}

	// Send message again
	mockClient.Enqueue(uuid.Must(uuid.NewV4()).String(), rerunPage)

	// Verify that page handler was called again
	if handlerCallCount != 2 {
		t.Errorf("page handler call count after rerun = %d, want 2", handlerCallCount)
	}
}

func TestRuntime_HandleCloseSession(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())

	mockClient := mock.NewClient()
	r := &runtime{
		wsClient:       mockClient,
		sessionManager: session.NewSessionManager(),
		pageManager:    newPageManager(make(map[uuid.UUID]*page)),
	}

	// Initialize session
	sess := session.New(sessionID, pageID)
	r.sessionManager.SetSession(sess)

	// Create test message
	closeSession := &websocketv1.CloseSession{
		SessionId: sessionID.String(),
	}

	// Register handler
	mockClient.RegisterHandler(func(msg *websocketv1.Message) error {
		switch m := msg.Type.(type) {
		case *websocketv1.Message_CloseSession:
			return r.handleCloseSession(m.CloseSession)
		}
		return nil
	})

	// Send message
	mockClient.Enqueue(uuid.Must(uuid.NewV4()).String(), closeSession)

	// Verify that session was deleted
	if got := r.sessionManager.GetSession(sessionID); got != nil {
		t.Error("session was not deleted")
	}
}
</file>

<file path="runtime.go">
package sourcetool

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/gofrs/uuid/v5"
	"go.uber.org/zap"

	"github.com/trysourcetool/sourcetool-go/internal/conv"
	"github.com/trysourcetool/sourcetool-go/internal/errdefs"
	"github.com/trysourcetool/sourcetool-go/internal/logger"
	exceptionv1 "github.com/trysourcetool/sourcetool-go/internal/pb/exception/v1"
	pagev1 "github.com/trysourcetool/sourcetool-go/internal/pb/page/v1"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/websocket"
)

type runtime struct {
	wsClient       websocket.Client
	sessionManager *session.SessionManager
	pageManager    *pageManager
}

func startRuntime(apiKey, endpoint string, pages map[uuid.UUID]*page) (*runtime, error) {
	r := &runtime{
		sessionManager: session.NewSessionManager(),
		pageManager:    newPageManager(pages),
	}

	wsClient, err := websocket.NewClient(websocket.Config{
		URL:            endpoint,
		APIKey:         apiKey,
		InstanceID:     uuid.Must(uuid.NewV4()),
		PingInterval:   1 * time.Second,
		ReconnectDelay: 1 * time.Second,
		OnReconnecting: func() {
			logger.Log.Info("Reconnecting...")
		},
		OnReconnected: func() {
			logger.Log.Info("Reconnected!")
			r.sendInitializeHost(apiKey, pages)
		},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create websocket client: %v", err)
	}

	r.wsClient = wsClient
	wsClient.RegisterHandler(func(msg *websocketv1.Message) error {
		switch t := msg.Type.(type) {
		case *websocketv1.Message_InitializeClient:
			if err := r.handleInitializeClient(t.InitializeClient); err != nil {
				r.sendException(msg.Id, *t.InitializeClient.SessionId, err)
			}
			return nil
		case *websocketv1.Message_RerunPage:
			if err := r.handleRerunPage(t.RerunPage); err != nil {
				r.sendException(msg.Id, t.RerunPage.SessionId, err)
			}
			return nil
		case *websocketv1.Message_CloseSession:
			if err := r.handleCloseSession(t.CloseSession); err != nil {
				r.sendException(msg.Id, t.CloseSession.SessionId, err)
			}
			return nil
		default:
			return fmt.Errorf("unknown message type: %T", t)
		}
	})

	r.sendInitializeHost(apiKey, pages)

	return r, nil
}

func (r *runtime) sendInitializeHost(apiKey string, pages map[uuid.UUID]*page) {
	pagesPayload := make([]*pagev1.Page, 0, len(pages))
	for _, page := range pages {
		pagesPayload = append(pagesPayload, &pagev1.Page{
			Id:     page.id.String(),
			Name:   page.name,
			Route:  page.route,
			Path:   conv.PathToInt32Slice(page.path),
			Groups: page.accessGroups,
		})
	}

	msg := &websocketv1.InitializeHost{
		ApiKey:     apiKey,
		SdkName:    "sourcetool-go",
		SdkVersion: "0.1.0",
		Pages:      pagesPayload,
	}

	resp, err := r.wsClient.EnqueueWithResponse(uuid.Must(uuid.NewV4()).String(), msg)
	if err != nil {
		logger.Log.Fatal("failed to send initialize host message", zap.Error(err))
	}

	if e := resp.GetException(); e != nil {
		logger.Log.Fatal("initialize host message failed", zap.String("message", e.Message))
	}

	logger.Log.Info("initialize host message sent", zap.Any("response", resp))
}

func (r *runtime) handleInitializeClient(msg *websocketv1.InitializeClient) error {
	if msg.SessionId == nil {
		return errdefs.ErrInvalidParameter(errors.New("session id is required"))
	}
	sessionID, err := uuid.FromString(conv.SafeValue(msg.SessionId))
	if err != nil {
		return errdefs.ErrInvalidParameter(err)
	}
	pageID, err := uuid.FromString(msg.PageId)
	if err != nil {
		return errdefs.ErrInvalidParameter(err)
	}

	session := session.New(sessionID, pageID)
	r.sessionManager.SetSession(session)

	page := r.pageManager.getPage(pageID)
	if page == nil {
		return errdefs.ErrInternal(fmt.Errorf("page not found: %s", pageID))
	}

	ui := &uiBuilder{
		context: context.Background(),
		runtime: r,
		session: session,
		page:    page,
		cursor:  newCursor(),
	}

	if err := page.run(ui); err != nil {
		r.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.ScriptFinished{
			SessionId: sessionID.String(),
			Status:    websocketv1.ScriptFinished_STATUS_FAILURE,
		})

		return errdefs.ErrRunPage(err)
	}

	r.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.ScriptFinished{
		SessionId: sessionID.String(),
		Status:    websocketv1.ScriptFinished_STATUS_SUCCESS,
	})

	return nil
}

func (r *runtime) handleRerunPage(msg *websocketv1.RerunPage) error {
	sessionID, err := uuid.FromString(msg.SessionId)
	if err != nil {
		return errdefs.ErrInvalidParameter(err)
	}
	sess := r.sessionManager.GetSession(sessionID)
	if sess == nil {
		return errdefs.ErrSessionNotFound(fmt.Errorf("session not found: %s", sessionID))
	}

	pageID, err := uuid.FromString(msg.PageId)
	if err != nil {
		return errdefs.ErrInvalidParameter(err)
	}
	page := r.pageManager.getPage(pageID)
	if page == nil {
		return errdefs.ErrPageNotFound(fmt.Errorf("page not found: %s", pageID))
	}

	if sess.PageID != pageID {
		sess.State.ResetStates()
	}

	newWidgetStates := make(map[uuid.UUID]session.WidgetState)
	for _, widget := range msg.States {
		id, err := uuid.FromString(widget.Id)
		if err != nil {
			return errdefs.ErrInvalidParameter(err)
		}
		switch t := widget.Type.(type) {
		case *widgetv1.Widget_TextInput:
			newWidgetStates[id] = convertTextInputProtoToState(id, t.TextInput)
		case *widgetv1.Widget_NumberInput:
			newWidgetStates[id] = convertNumberInputProtoToState(id, t.NumberInput)
		case *widgetv1.Widget_DateInput:
			state, err := convertDateInputProtoToState(id, t.DateInput, time.Local)
			if err != nil {
				return errdefs.ErrInvalidParameter(err)
			}
			newWidgetStates[id] = state
		case *widgetv1.Widget_DateTimeInput:
			state, err := convertDateTimeInputProtoToState(id, t.DateTimeInput, time.Local)
			if err != nil {
				return errdefs.ErrInvalidParameter(err)
			}
			newWidgetStates[id] = state
		case *widgetv1.Widget_TimeInput:
			state, err := convertTimeInputProtoToState(id, t.TimeInput, time.Local)
			if err != nil {
				return errdefs.ErrInvalidParameter(err)
			}
			newWidgetStates[id] = state
		case *widgetv1.Widget_Form:
			newWidgetStates[id] = convertFormProtoToState(id, t.Form)
		case *widgetv1.Widget_Button:
			newWidgetStates[id] = convertButtonProtoToState(id, t.Button)
		case *widgetv1.Widget_Markdown:
			newWidgetStates[id] = convertMarkdownProtoToState(id, t.Markdown)
		case *widgetv1.Widget_Columns:
			newWidgetStates[id] = convertColumnsProtoToState(id, t.Columns)
		case *widgetv1.Widget_ColumnItem:
			newWidgetStates[id] = convertColumnItemProtoToState(id, t.ColumnItem)
		case *widgetv1.Widget_Table:
			newWidgetStates[id] = convertTableProtoToState(id, t.Table)
		case *widgetv1.Widget_Selectbox:
			newWidgetStates[id] = convertSelectboxProtoToState(id, t.Selectbox)
		case *widgetv1.Widget_MultiSelect:
			newWidgetStates[id] = convertMultiSelectProtoToState(id, t.MultiSelect)
		case *widgetv1.Widget_Checkbox:
			newWidgetStates[id] = convertCheckboxProtoToState(id, t.Checkbox)
		case *widgetv1.Widget_CheckboxGroup:
			newWidgetStates[id] = convertCheckboxGroupProtoToState(id, t.CheckboxGroup)
		case *widgetv1.Widget_Radio:
			newWidgetStates[id] = convertRadioProtoToState(id, t.Radio)
		case *widgetv1.Widget_TextArea:
			newWidgetStates[id] = convertTextAreaProtoToState(id, t.TextArea)
		default:
			return errdefs.ErrInvalidParameter(fmt.Errorf("unknown widget type: %T", t))
		}
	}

	sess.State.SetStates(newWidgetStates)

	ui := &uiBuilder{
		context: context.Background(),
		runtime: r,
		session: sess,
		page:    page,
		cursor:  newCursor(),
	}

	if err := page.run(ui); err != nil {
		r.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.ScriptFinished{
			SessionId: sessionID.String(),
			Status:    websocketv1.ScriptFinished_STATUS_FAILURE,
		})

		return errdefs.ErrRunPage(err)
	}

	r.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.ScriptFinished{
		SessionId: sessionID.String(),
		Status:    websocketv1.ScriptFinished_STATUS_SUCCESS,
	})

	sess.State.ResetButtons()

	return nil
}

func (r *runtime) handleCloseSession(msg *websocketv1.CloseSession) error {
	sessionID, err := uuid.FromString(msg.SessionId)
	if err != nil {
		return errdefs.ErrInvalidParameter(err)
	}

	r.sessionManager.DisconnectSession(sessionID)

	return nil
}

func (r *runtime) sendException(id, sessionID string, err error) {
	e, ok := err.(*errdefs.Error)
	if !ok {
		v := errdefs.ErrInternal(err)
		e = v.(*errdefs.Error)
	}

	exception := &exceptionv1.Exception{
		Title:      e.Title,
		Message:    e.Message,
		StackTrace: e.StackTrace(),
		SessionId:  sessionID,
	}

	r.wsClient.Enqueue(id, exception)
}

func (r *runtime) Close() error {
	err := r.wsClient.Close()
	r.wsClient = nil
	return err
}
</file>

<file path="SECURITY.md">
# Security Policy

## Supported Versions

| Version | Supported          |
| ------- | ------------------ |
| 1.0.x   | :white_check_mark: |
| < 1.0   | :x:                |

## Reporting a Vulnerability

We take the security of sourcetool-go seriously. If you believe you have found a security vulnerability, please report it to us as described below.

**Please do not report security vulnerabilities through public GitHub issues.**

Instead, please report them via email to security@trysourcetool.com (if this email address is not yet set up, please report via private discussion in GitHub Security tab).

When reporting a vulnerability, please include:
* Description of the issue
* Steps to reproduce
* Impact of the issue
* Any relevant code or configuration

We will acknowledge receipt within 48 hours and work to address the issue as soon as possible.

## Security Updates
Security updates will be released as soon as possible after a vulnerability is confirmed and fixed. We will:
1. Confirm the vulnerability
2. Develop and test a fix
3. Release a security update
4. Credit the reporter (if desired)

## Contact
For any security-related questions or concerns, please contact us at security@trysourcetool.com.

## Preferred Languages

We prefer all communications to be in English.

## Policy

We follow the principle of [Responsible Disclosure](https://en.wikipedia.org/wiki/Responsible_disclosure).
</file>

<file path="selectbox_test.go">
package sourcetool

import (
	"context"
	"testing"

	"github.com/gofrs/uuid/v5"

	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
	"github.com/trysourcetool/sourcetool-go/selectbox"
)

func TestConvertStateToSelectboxProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	value := int32(1)
	defaultValue := int32(0)
	options := []string{"Option 1", "Option 2"}
	placeholder := "Select an option"

	selectboxState := &state.SelectboxState{
		ID:           id,
		Label:        "Test Selectbox",
		Value:        &value,
		Options:      options,
		Placeholder:  placeholder,
		DefaultValue: &defaultValue,
		Required:     true,
		Disabled:     false,
	}

	data := convertStateToSelectboxProto(selectboxState)

	if data == nil {
		t.Fatal("convertStateToSelectboxProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", data.Label, selectboxState.Label},
		{"Value", *data.Value, *selectboxState.Value},
		{"Options length", len(data.Options), len(selectboxState.Options)},
		{"Placeholder", data.Placeholder, selectboxState.Placeholder},
		{"DefaultValue", *data.DefaultValue, *selectboxState.DefaultValue},
		{"Required", data.Required, selectboxState.Required},
		{"Disabled", data.Disabled, selectboxState.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertSelectboxProtoToState(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	value := int32(1)
	defaultValue := int32(0)
	options := []string{"Option 1", "Option 2"}
	placeholder := "Select an option"

	data := &widgetv1.Selectbox{
		Label:        "Test Selectbox",
		Value:        &value,
		Options:      options,
		Placeholder:  placeholder,
		DefaultValue: &defaultValue,
		Required:     true,
		Disabled:     false,
	}

	state := convertSelectboxProtoToState(id, data)

	if state == nil {
		t.Fatal("convertSelectboxProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ID", state.ID, id},
		{"Label", state.Label, data.Label},
		{"Value", *state.Value, *data.Value},
		{"Options length", len(state.Options), len(data.Options)},
		{"Placeholder", state.Placeholder, data.Placeholder},
		{"DefaultValue", *state.DefaultValue, *data.DefaultValue},
		{"Required", state.Required, data.Required},
		{"Disabled", state.Disabled, data.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestSelectbox(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test Selectbox"
	options := []string{"Option 1", "Option 2"}
	defaultValue := "Option 1"
	placeholder := "Select an option"

	value := builder.Selectbox(label,
		selectbox.WithOptions(options...),
		selectbox.WithDefaultValue(defaultValue),
		selectbox.WithPlaceholder(placeholder),
		selectbox.WithRequired(true),
	)

	if value == nil {
		t.Fatal("Selectbox returned nil")
	}
	if value.Value != defaultValue {
		t.Errorf("Selectbox value = %v, want %v", value.Value, defaultValue)
	}
	if value.Index != 0 {
		t.Errorf("Selectbox index = %v, want 0", value.Index)
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeSelectbox, []int{0})
	state := sess.State.GetSelectbox(widgetID)
	if state == nil {
		t.Fatal("Selectbox state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, label},
		{"Options length", len(state.Options), len(options)},
		{"Placeholder", state.Placeholder, placeholder},
		{"Required", state.Required, true},
		{"Disabled", state.Disabled, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestSelectbox_WithFormatFunc(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test Selectbox"
	options := []string{"Option 1", "Option 2"}
	formatFunc := func(value string, index int) string {
		return value + " (Custom)"
	}

	builder.Selectbox(label,
		selectbox.WithOptions(options...),
		selectbox.WithFormatFunc(formatFunc),
	)

	widgetID := builder.generatePageID(state.WidgetTypeSelectbox, []int{0})
	state := sess.State.GetSelectbox(widgetID)
	if state == nil {
		t.Fatal("Selectbox state not found")
	}

	expectedOptions := []string{"Option 1 (Custom)", "Option 2 (Custom)"}
	for i, opt := range state.Options {
		if opt != expectedOptions[i] {
			t.Errorf("Formatted option[%d] = %v, want %v", i, opt, expectedOptions[i])
		}
	}
}
</file>

<file path="selectbox.go">
package sourcetool

import (
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/conv"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/selectbox"
)

func (b *uiBuilder) Selectbox(label string, opts ...selectbox.Option) *selectbox.Value {
	selectboxOpts := &options.SelectboxOptions{
		Label:        label,
		DefaultValue: nil,
		Placeholder:  "",
		Required:     false,
		Disabled:     false,
		FormatFunc:   nil,
	}

	for _, o := range opts {
		o.Apply(selectboxOpts)
	}

	sess := b.session
	if sess == nil {
		return nil
	}
	page := b.page
	if page == nil {
		return nil
	}
	cursor := b.cursor
	if cursor == nil {
		return nil
	}
	path := cursor.getPath()

	var defaultVal *int32
	if selectboxOpts.DefaultValue != nil {
		for i, o := range selectboxOpts.Options {
			if conv.SafeValue(selectboxOpts.DefaultValue) == o {
				v := int32(i)
				defaultVal = &v
				break
			}
		}
	}

	widgetID := b.generatePageID(state.WidgetTypeSelectbox, path)
	selectboxState := sess.State.GetSelectbox(widgetID)
	if selectboxState == nil {
		selectboxState = &state.SelectboxState{
			ID:           widgetID,
			Value:        defaultVal,
			DefaultValue: defaultVal,
		}
	}

	if selectboxOpts.FormatFunc == nil {
		selectboxOpts.FormatFunc = func(v string, i int) string {
			return v
		}
	}

	displayVals := make([]string, len(selectboxOpts.Options))
	for i, v := range selectboxOpts.Options {
		displayVals[i] = selectboxOpts.FormatFunc(v, i)
	}

	selectboxState.Label = selectboxOpts.Label
	selectboxState.Options = displayVals
	selectboxState.Placeholder = selectboxOpts.Placeholder
	selectboxState.DefaultValue = defaultVal
	selectboxState.Required = selectboxOpts.Required
	selectboxState.Disabled = selectboxOpts.Disabled
	sess.State.Set(widgetID, selectboxState)

	selectboxProto := convertStateToSelectboxProto(selectboxState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_Selectbox{
				Selectbox: selectboxProto,
			},
		},
	})

	cursor.next()

	var value *selectbox.Value
	if selectboxState.Value != nil {
		value = &selectbox.Value{
			Value: selectboxOpts.Options[*selectboxState.Value],
			Index: int(conv.SafeValue(selectboxState.Value)),
		}
	}

	return value
}

func convertStateToSelectboxProto(state *state.SelectboxState) *widgetv1.Selectbox {
	if state == nil {
		return nil
	}
	return &widgetv1.Selectbox{
		Label:        state.Label,
		Value:        state.Value,
		Options:      state.Options,
		Placeholder:  state.Placeholder,
		DefaultValue: state.DefaultValue,
		Required:     state.Required,
		Disabled:     state.Disabled,
	}
}

func convertSelectboxProtoToState(id uuid.UUID, data *widgetv1.Selectbox) *state.SelectboxState {
	if data == nil {
		return nil
	}
	return &state.SelectboxState{
		ID:           id,
		Label:        data.Label,
		Value:        data.Value,
		Options:      data.Options,
		Placeholder:  data.Placeholder,
		DefaultValue: data.DefaultValue,
		Required:     data.Required,
		Disabled:     data.Disabled,
	}
}
</file>

<file path="sourcetool_test.go">
package sourcetool

import (
	"errors"
	"testing"

	"github.com/gofrs/uuid/v5"
)

func TestNew(t *testing.T) {
	apiKey := "test_api_key"
	endpoint := "ws://test.trysourcetool.com"
	config := &Config{
		APIKey:   apiKey,
		Endpoint: endpoint,
	}
	st := New(config)

	if st == nil {
		t.Fatal("New returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"APIKey", st.apiKey, apiKey},
		{"Endpoint", st.endpoint, "ws://test.trysourcetool.com/ws"},
		{"Pages length", len(st.pages), 0},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestPage(t *testing.T) {
	pageHandler := func(ui UIBuilder) error { return nil }

	t.Run("Public page", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		st.Page("/public", "Public Page", pageHandler)

		page := findPageByPath(st.pages, "/public")
		if page == nil {
			t.Fatal("Page not found")
		}

		if len(page.accessGroups) != 0 {
			t.Errorf("Expected no access groups, got %v", page.accessGroups)
		}

		if !page.hasAccess([]string{}) {
			t.Error("Public page should be accessible without groups")
		}
	})

	t.Run("Page with direct access groups", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		st.AccessGroups("admin")
		st.Page("/admin", "Admin Page", pageHandler)

		page := findPageByPath(st.pages, "/admin")
		if page == nil {
			t.Fatal("Page not found")
		}

		if len(page.accessGroups) != 1 || page.accessGroups[0] != "admin" {
			t.Errorf("Expected [admin] access group, got %v", page.accessGroups)
		}
	})

	t.Run("Group with access groups", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		api := st.Group("/api")
		api.AccessGroups("api_user")
		api.Page("/users", "Users API", pageHandler)
		api.Page("/posts", "Posts API", pageHandler)

		usersPage := findPageByPath(st.pages, "/api/users")
		postsPage := findPageByPath(st.pages, "/api/posts")

		if usersPage == nil || postsPage == nil {
			t.Fatal("Pages not found")
		}

		if len(usersPage.accessGroups) != 1 || usersPage.accessGroups[0] != "api_user" {
			t.Errorf("Expected [api_user] access group for users page, got %v", usersPage.accessGroups)
		}

		if len(postsPage.accessGroups) != 1 || postsPage.accessGroups[0] != "api_user" {
			t.Errorf("Expected [api_user] access group for posts page, got %v", postsPage.accessGroups)
		}
	})

	t.Run("Nested groups with access groups", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		users := st.Group("/users")
		users.AccessGroups("admin")
		users.Page("/list", "List users page", pageHandler)
		users.AccessGroups("customer_support").Page("/create", "Create user page", pageHandler)

		products := users.Group("/products")
		products.AccessGroups("product_manager")
		products.Page("/list", "List products page", pageHandler)

		tests := []struct {
			path           string
			expectedGroups []string
		}{
			{"/users/list", []string{"admin"}},
			{"/users/create", []string{"admin", "customer_support"}},
			{"/users/products/list", []string{"admin", "customer_support", "product_manager"}},
		}

		for _, tt := range tests {
			t.Run(tt.path, func(t *testing.T) {
				page := findPageByPath(st.pages, tt.path)
				if page == nil {
					t.Fatalf("Page not found: %s", tt.path)
				}

				if len(page.accessGroups) != len(tt.expectedGroups) {
					t.Errorf("Expected %d access groups, got %d for path %s",
						len(tt.expectedGroups), len(page.accessGroups), tt.path)
					t.Errorf("Expected groups: %v, got: %v", tt.expectedGroups, page.accessGroups)
					return
				}

				for _, expectedGroup := range tt.expectedGroups {
					found := false
					for _, actualGroup := range page.accessGroups {
						if actualGroup == expectedGroup {
							found = true
							break
						}
					}
					if !found {
						t.Errorf("Expected group %s not found in %v for path %s",
							expectedGroup, page.accessGroups, tt.path)
					}
				}
			})
		}
	})

	t.Run("Complex group structure", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)

		admin := st.Group("/admin")
		admin.AccessGroups("admin")
		admin.Page("/dashboard", "Admin Dashboard", pageHandler)

		settings := admin.Group("/settings")
		settings.AccessGroups("super_admin")
		settings.Page("/system", "System Settings", pageHandler)

		api := st.Group("/api")
		api.AccessGroups("api_user")

		v1 := api.Group("/v1")
		v1.Page("/users", "Users API v1", pageHandler)

		v2 := api.Group("/v2")
		v2.AccessGroups("api_v2")
		v2.Page("/users", "Users API v2", pageHandler)

		tests := []struct {
			path           string
			expectedGroups []string
		}{
			{"/admin/dashboard", []string{"admin"}},
			{"/admin/settings/system", []string{"admin", "super_admin"}},
			{"/api/v1/users", []string{"api_user"}},
			{"/api/v2/users", []string{"api_user", "api_v2"}},
		}

		for _, tt := range tests {
			t.Run(tt.path, func(t *testing.T) {
				page := findPageByPath(st.pages, tt.path)
				if page == nil {
					t.Fatalf("Page not found: %s", tt.path)
				}

				if len(page.accessGroups) != len(tt.expectedGroups) {
					t.Errorf("Expected %d access groups, got %d for path %s",
						len(tt.expectedGroups), len(page.accessGroups), tt.path)
				}

				for _, expectedGroup := range tt.expectedGroups {
					found := false
					for _, actualGroup := range page.accessGroups {
						if actualGroup == expectedGroup {
							found = true
							break
						}
					}
					if !found {
						t.Errorf("Expected group %s not found in %v for path %s",
							expectedGroup, page.accessGroups, tt.path)
					}
				}
			})
		}
	})

	t.Run("Error handling", func(t *testing.T) {
		config := &Config{
			APIKey:   "test_api_key",
			Endpoint: "ws://test.trysourcetool.com",
		}
		st := New(config)
		errorHandler := func(ui UIBuilder) error {
			return errors.New("test error")
		}
		st.Page("/error", "Error Page", errorHandler)

		page := findPageByPath(st.pages, "/error")
		if page == nil {
			t.Fatal("Page not found")
		}

		if err := page.run(nil); err == nil {
			t.Error("Expected error from handler, got nil")
		}
	})
}

func findPageByPath(pages map[uuid.UUID]*page, path string) *page {
	for _, p := range pages {
		if p.route == path {
			return p
		}
	}
	return nil
}

func TestPageManager(t *testing.T) {
	t.Run("Get existing page", func(t *testing.T) {
		pages := make(map[uuid.UUID]*page)
		pageID := uuid.Must(uuid.NewV4())
		testPage := &page{
			id:   pageID,
			name: "TestPage",
		}
		pages[pageID] = testPage

		pm := newPageManager(pages)

		got := pm.getPage(pageID)
		if got != testPage {
			t.Error("getPage returned wrong page")
		}
	})

	t.Run("Get non-existent page", func(t *testing.T) {
		pages := make(map[uuid.UUID]*page)
		pm := newPageManager(pages)

		nonExistentID := uuid.Must(uuid.NewV4())
		got := pm.getPage(nonExistentID)
		if got != nil {
			t.Error("getPage returned non-nil for non-existent page")
		}
	})
}
</file>

<file path="sourcetool.go">
package sourcetool

import (
	"fmt"
	"strings"
	"sync"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/logger"
)

type Sourcetool struct {
	Router
	apiKey   string
	endpoint string
	runtime  *runtime
	pages    map[uuid.UUID]*page
	mu       sync.RWMutex
}

func New(config *Config) *Sourcetool {
	hostParts := strings.Split(config.Endpoint, "://")
	if len(hostParts) != 2 {
		panic("invalid host")
	}
	namespaceDNS := strings.Split(hostParts[1], ":")[0]
	s := &Sourcetool{
		apiKey:   config.APIKey,
		endpoint: fmt.Sprintf("%s/ws", config.Endpoint),
		pages:    make(map[uuid.UUID]*page),
	}
	s.Router = newRouter(s, namespaceDNS)
	return s
}

func (s *Sourcetool) Listen() error {
	if err := s.validatePages(); err != nil {
		return err
	}

	if err := logger.Init(); err != nil {
		return fmt.Errorf("failed to initialize logger: %v", err)
	}
	defer logger.Sync()

	s.mu.RLock()
	r, err := startRuntime(s.apiKey, s.endpoint, s.pages)
	s.mu.RUnlock()
	if err != nil {
		return err
	}
	defer r.Close()

	s.runtime = r

	return r.wsClient.Wait()
}

func (s *Sourcetool) Close() error {
	if s.runtime == nil {
		return nil
	}
	return s.runtime.Close()
}

func (s *Sourcetool) validatePages() error {
	s.mu.RLock()
	defer s.mu.RUnlock()

	pagesByRoute := make(map[string]uuid.UUID)
	for id, p := range s.pages {
		pagesByRoute[p.route] = id
	}

	newPages := make(map[uuid.UUID]*page)
	for _, id := range pagesByRoute {
		newPages[id] = s.pages[id]
	}
	s.pages = newPages

	return nil
}

func (s *Sourcetool) addPage(id uuid.UUID, p *page) {
	s.mu.Lock()
	s.pages[id] = p
	s.mu.Unlock()
}
</file>

<file path="table_test.go">
package sourcetool

import (
	"context"
	"encoding/json"
	"reflect"
	"testing"

	"github.com/gofrs/uuid/v5"

	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
	"github.com/trysourcetool/sourcetool-go/table"
)

type testData struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

func TestConvertStateToTableProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	data := []testData{
		{ID: 1, Name: "Test 1"},
		{ID: 2, Name: "Test 2"},
	}
	selection := &state.TableStateValueSelection{
		Row:  0,
		Rows: []int32{0},
	}

	tableState := &state.TableState{
		ID:           id,
		Data:         data,
		Header:       "Test Table",
		Description:  "Test Description",
		OnSelect:     table.OnSelectRerun.String(),
		RowSelection: table.RowSelectionSingle.String(),
		Value: state.TableStateValue{
			Selection: selection,
		},
	}

	tableData, err := convertStateToTableProto(tableState)
	if err != nil {
		t.Fatalf("convertStateToTableProto returned error: %v", err)
	}

	if tableData == nil {
		t.Fatal("convertStateToTableProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Header", tableData.Header, tableState.Header},
		{"Description", tableData.Description, tableState.Description},
		{"OnSelect", tableData.OnSelect, tableState.OnSelect},
		{"RowSelection", tableData.RowSelection, tableState.RowSelection},
		{"Selection.Row", tableData.Value.Selection.Row, tableState.Value.Selection.Row},
		{"Selection.Rows", tableData.Value.Selection.Rows, tableState.Value.Selection.Rows},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !reflect.DeepEqual(tt.got, tt.want) {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}

	dataBytes, err := json.Marshal(data)
	if err != nil {
		t.Fatalf("json.Marshal returned error: %v", err)
	}
	if !reflect.DeepEqual(tableData.Data, dataBytes) {
		t.Errorf("Data = %v, want %v", tableData.Data, data)
	}
}

func TestConvertTableProtoToState(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	data := []testData{
		{ID: 1, Name: "Test 1"},
		{ID: 2, Name: "Test 2"},
	}
	selection := &widgetv1.TableValueSelection{
		Row:  0,
		Rows: []int32{0},
	}

	dataBytes, err := json.Marshal(data)
	if err != nil {
		t.Fatalf("json.Marshal returned error: %v", err)
	}

	tableData := &widgetv1.Table{
		Data:         dataBytes,
		Header:       "Test Table",
		Description:  "Test Description",
		OnSelect:     table.OnSelectRerun.String(),
		RowSelection: table.RowSelectionSingle.String(),
		Value: &widgetv1.TableValue{
			Selection: selection,
		},
	}

	state := convertTableProtoToState(id, tableData)

	if state == nil {
		t.Fatal("convertTableProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ID", state.ID, id},
		{"Header", state.Header, tableData.Header},
		{"Description", state.Description, tableData.Description},
		{"OnSelect", state.OnSelect, tableData.OnSelect},
		{"RowSelection", state.RowSelection, tableData.RowSelection},
		{"Selection.Row", state.Value.Selection.Row, tableData.Value.Selection.Row},
		{"Selection.Rows", state.Value.Selection.Rows, tableData.Value.Selection.Rows},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !reflect.DeepEqual(tt.got, tt.want) {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}

	dataBytes, err = json.Marshal(data)
	if err != nil {
		t.Fatalf("json.Marshal returned error: %v", err)
	}
	if !reflect.DeepEqual(state.Data, dataBytes) {
		t.Errorf("Data = %v, want %v", state.Data, data)
	}
}

func TestTable(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	data := []testData{
		{ID: 1, Name: "Test 1"},
		{ID: 2, Name: "Test 2"},
	}
	header := "Test Table"
	description := "Test Description"

	builder.Table(data,
		table.WithHeader(header),
		table.WithDescription(description),
		table.WithOnSelect(table.OnSelectRerun),
		table.WithRowSelection(table.RowSelectionSingle),
	)

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeTable, []int{0})
	state := sess.State.GetTable(widgetID)
	if state == nil {
		t.Fatal("Table state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Header", state.Header, header},
		{"Description", state.Description, description},
		{"OnSelect", state.OnSelect, table.OnSelectRerun.String()},
		{"RowSelection", state.RowSelection, table.RowSelectionSingle.String()},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}

	if !reflect.DeepEqual(state.Data, data) {
		t.Errorf("Data = %v, want %v", state.Data, data)
	}
}

func TestTable_DefaultValues(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	data := []testData{
		{ID: 1, Name: "Test 1"},
		{ID: 2, Name: "Test 2"},
	}

	builder.Table(data)

	widgetID := builder.generatePageID(state.WidgetTypeTable, []int{0})
	state := sess.State.GetTable(widgetID)
	if state == nil {
		t.Fatal("Table state not found")
	}

	if state.OnSelect != table.OnSelectIgnore.String() {
		t.Errorf("Default OnSelect = %v, want %v", state.OnSelect, table.OnSelectIgnore)
	}
	if state.RowSelection != table.RowSelectionSingle.String() {
		t.Errorf("Default RowSelection = %v, want %v", state.RowSelection, table.RowSelectionSingle)
	}
	if state.Header != "" {
		t.Errorf("Default Header = %v, want empty string", state.Header)
	}
	if state.Description != "" {
		t.Errorf("Default Description = %v, want empty string", state.Description)
	}
}
</file>

<file path="table.go">
package sourcetool

import (
	"encoding/json"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/table"
)

func (b *uiBuilder) Table(data any, opts ...table.Option) table.Value {
	tableOpts := &options.TableOptions{
		OnSelect:     table.OnSelectIgnore.String(),
		RowSelection: table.RowSelectionSingle.String(),
	}

	for _, o := range opts {
		o.Apply(tableOpts)
	}

	sess := b.session
	if sess == nil {
		return table.Value{}
	}
	page := b.page
	if page == nil {
		return table.Value{}
	}
	cursor := b.cursor
	if cursor == nil {
		return table.Value{}
	}
	path := cursor.getPath()

	widgetID := b.generatePageID(state.WidgetTypeTable, path)
	tableState := sess.State.GetTable(widgetID)
	if tableState == nil {
		tableState = &state.TableState{
			ID:    widgetID,
			Value: state.TableStateValue{},
		}
	}
	tableState.Data = data
	tableState.Header = tableOpts.Header
	tableState.Description = tableOpts.Description
	tableState.Height = tableOpts.Height
	tableState.ColumnOrder = tableOpts.ColumnOrder
	tableState.OnSelect = tableOpts.OnSelect
	tableState.RowSelection = tableOpts.RowSelection
	sess.State.Set(widgetID, tableState)

	tableProto, err := convertStateToTableProto(tableState)
	if err != nil {
		return table.Value{}
	}
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_Table{
				Table: tableProto,
			},
		},
	})

	cursor.next()

	value := table.Value{}
	if tableState.Value.Selection != nil {
		rows := make([]int, len(tableState.Value.Selection.Rows))
		for i, r := range tableState.Value.Selection.Rows {
			rows[i] = int(r)
		}
		value.Selection = &table.Selection{
			Row:  int(tableState.Value.Selection.Row),
			Rows: rows,
		}
	}

	return value
}

func convertStateToTableProto(state *state.TableState) (*widgetv1.Table, error) {
	if state == nil {
		return nil, nil
	}
	dataBytes, err := json.Marshal(state.Data)
	if err != nil {
		return nil, err
	}
	data := &widgetv1.Table{
		Data:         dataBytes,
		Header:       state.Header,
		Description:  state.Description,
		Height:       state.Height,
		ColumnOrder:  state.ColumnOrder,
		OnSelect:     state.OnSelect,
		RowSelection: state.RowSelection,
		Value:        &widgetv1.TableValue{},
	}
	if state.Value.Selection != nil {
		data.Value.Selection = &widgetv1.TableValueSelection{
			Row:  state.Value.Selection.Row,
			Rows: state.Value.Selection.Rows,
		}
	}
	return data, nil
}

func convertTableProtoToState(id uuid.UUID, data *widgetv1.Table) *state.TableState {
	if data == nil {
		return nil
	}
	tableState := &state.TableState{
		ID:           id,
		Data:         data.Data,
		Header:       data.Header,
		Description:  data.Description,
		Height:       data.Height,
		ColumnOrder:  data.ColumnOrder,
		OnSelect:     data.OnSelect,
		RowSelection: data.RowSelection,
		Value:        state.TableStateValue{},
	}
	if data.Value.Selection != nil {
		tableState.Value.Selection = &state.TableStateValueSelection{
			Row:  data.Value.Selection.Row,
			Rows: data.Value.Selection.Rows,
		}
	}
	return tableState
}
</file>

<file path="textarea_test.go">
package sourcetool

import (
	"context"
	"testing"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/conv"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
	"github.com/trysourcetool/sourcetool-go/textarea"
)

func TestConvertStateToTextAreaProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	maxLength := int32(1000)
	minLength := int32(10)
	maxLines := int32(10)
	minLines := int32(3)

	textAreaState := &state.TextAreaState{
		ID:           id,
		Label:        "Test TextArea",
		Value:        conv.NilValue("test value"),
		Placeholder:  "Enter text",
		DefaultValue: conv.NilValue("default"),
		Required:     true,
		Disabled:     false,
		MaxLength:    &maxLength,
		MinLength:    &minLength,
		MaxLines:     &maxLines,
		MinLines:     &minLines,
		AutoResize:   true,
	}

	data := convertStateToTextAreaProto(textAreaState)

	if data == nil {
		t.Fatal("convertStateToTextAreaProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", data.Label, textAreaState.Label},
		{"Value", data.Value, textAreaState.Value},
		{"Placeholder", data.Placeholder, textAreaState.Placeholder},
		{"DefaultValue", data.DefaultValue, textAreaState.DefaultValue},
		{"Required", data.Required, textAreaState.Required},
		{"Disabled", data.Disabled, textAreaState.Disabled},
		{"MaxLength", *data.MaxLength, *textAreaState.MaxLength},
		{"MinLength", *data.MinLength, *textAreaState.MinLength},
		{"MaxLines", *data.MaxLines, *textAreaState.MaxLines},
		{"MinLines", *data.MinLines, *textAreaState.MinLines},
		{"AutoResize", data.AutoResize, textAreaState.AutoResize},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertTextAreaProtoToState(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	maxLength := int32(1000)
	minLength := int32(10)
	maxLines := int32(10)
	minLines := int32(3)

	data := &widgetv1.TextArea{
		Label:        "Test TextArea",
		Value:        conv.NilValue("test value"),
		Placeholder:  "Enter text",
		DefaultValue: conv.NilValue("default"),
		Required:     true,
		Disabled:     false,
		MaxLength:    &maxLength,
		MinLength:    &minLength,
		MaxLines:     &maxLines,
		MinLines:     &minLines,
		AutoResize:   true,
	}

	state := convertTextAreaProtoToState(id, data)

	if state == nil {
		t.Fatal("convertTextAreaProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ID", state.ID, id},
		{"Label", state.Label, data.Label},
		{"Value", state.Value, data.Value},
		{"Placeholder", state.Placeholder, data.Placeholder},
		{"DefaultValue", state.DefaultValue, data.DefaultValue},
		{"Required", state.Required, data.Required},
		{"Disabled", state.Disabled, data.Disabled},
		{"MaxLength", *state.MaxLength, *data.MaxLength},
		{"MinLength", *state.MinLength, *data.MinLength},
		{"MaxLines", *state.MaxLines, *data.MaxLines},
		{"MinLines", *state.MinLines, *data.MinLines},
		{"AutoResize", state.AutoResize, data.AutoResize},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestTextArea(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test TextArea"
	defaultValue := "default value"
	placeholder := "Enter text"
	maxLength := int32(1000)
	minLength := int32(10)
	maxLines := int32(10)
	minLines := int32(3)

	value := builder.TextArea(label,
		textarea.WithDefaultValue(defaultValue),
		textarea.WithPlaceholder(placeholder),
		textarea.WithRequired(true),
		textarea.WithDisabled(true),
		textarea.WithMaxLength(maxLength),
		textarea.WithMinLength(minLength),
		textarea.WithMaxLines(maxLines),
		textarea.WithMinLines(minLines),
		textarea.WithAutoResize(false),
	)

	if value != defaultValue {
		t.Errorf("TextArea value = %v, want %v", value, defaultValue)
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeTextArea, []int{0})
	state := sess.State.GetTextArea(widgetID)
	if state == nil {
		t.Fatal("TextArea state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, label},
		{"Value", conv.SafeValue(state.Value), defaultValue},
		{"Placeholder", state.Placeholder, placeholder},
		{"DefaultValue", conv.SafeValue(state.DefaultValue), defaultValue},
		{"Required", state.Required, true},
		{"Disabled", state.Disabled, true},
		{"MaxLength", *state.MaxLength, maxLength},
		{"MinLength", *state.MinLength, minLength},
		{"MaxLines", *state.MaxLines, maxLines},
		{"MinLines", *state.MinLines, minLines},
		{"AutoResize", state.AutoResize, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestTextArea_DefaultMinLines(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test TextArea"

	builder.TextArea(label)

	widgetID := builder.generatePageID(state.WidgetTypeTextArea, []int{0})
	state := sess.State.GetTextArea(widgetID)
	if state == nil {
		t.Fatal("TextArea state not found")
	}

	if state.MinLines == nil {
		t.Fatal("MinLines is nil, want 2")
	}
	if *state.MinLines != 2 {
		t.Errorf("Default MinLines = %v, want 2", *state.MinLines)
	}
}
</file>

<file path="textarea.go">
package sourcetool

import (
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/conv"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/textarea"
)

func (b *uiBuilder) TextArea(label string, opts ...textarea.Option) string {
	defaultMinLines := int32(2)
	textAreaOpts := &options.TextAreaOptions{
		Label:        label,
		Placeholder:  "",
		DefaultValue: nil,
		Required:     false,
		Disabled:     false,
		MaxLength:    nil,
		MinLength:    nil,
		MinLines:     &defaultMinLines,
		MaxLines:     nil,
		AutoResize:   true,
	}

	for _, o := range opts {
		o.Apply(textAreaOpts)
	}

	sess := b.session
	if sess == nil {
		return ""
	}
	page := b.page
	if page == nil {
		return ""
	}
	cursor := b.cursor
	if cursor == nil {
		return ""
	}
	path := cursor.getPath()

	widgetID := b.generatePageID(state.WidgetTypeTextArea, path)
	textAreaState := sess.State.GetTextArea(widgetID)
	if textAreaState == nil {
		textAreaState = &state.TextAreaState{
			ID:    widgetID,
			Value: textAreaOpts.DefaultValue,
		}
	}
	textAreaState.Label = textAreaOpts.Label
	textAreaState.Placeholder = textAreaOpts.Placeholder
	textAreaState.DefaultValue = textAreaOpts.DefaultValue
	textAreaState.Required = textAreaOpts.Required
	textAreaState.Disabled = textAreaOpts.Disabled
	textAreaState.MaxLength = textAreaOpts.MaxLength
	textAreaState.MinLength = textAreaOpts.MinLength
	textAreaState.MaxLines = textAreaOpts.MaxLines
	textAreaState.MinLines = textAreaOpts.MinLines
	textAreaState.AutoResize = textAreaOpts.AutoResize
	sess.State.Set(widgetID, textAreaState)

	textAreaProto := convertStateToTextAreaProto(textAreaState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_TextArea{
				TextArea: textAreaProto,
			},
		},
	})

	cursor.next()

	return conv.SafeValue(textAreaState.Value)
}

func convertStateToTextAreaProto(state *state.TextAreaState) *widgetv1.TextArea {
	if state == nil {
		return nil
	}
	return &widgetv1.TextArea{
		Value:        state.Value,
		Label:        state.Label,
		Placeholder:  state.Placeholder,
		DefaultValue: state.DefaultValue,
		Required:     state.Required,
		Disabled:     state.Disabled,
		MaxLength:    state.MaxLength,
		MinLength:    state.MinLength,
		MaxLines:     state.MaxLines,
		MinLines:     state.MinLines,
		AutoResize:   state.AutoResize,
	}
}

func convertTextAreaProtoToState(id uuid.UUID, data *widgetv1.TextArea) *state.TextAreaState {
	if data == nil {
		return nil
	}
	return &state.TextAreaState{
		ID:           id,
		Value:        data.Value,
		Label:        data.Label,
		Placeholder:  data.Placeholder,
		DefaultValue: data.DefaultValue,
		Required:     data.Required,
		Disabled:     data.Disabled,
		MaxLength:    data.MaxLength,
		MinLength:    data.MinLength,
		MaxLines:     data.MaxLines,
		MinLines:     data.MinLines,
		AutoResize:   data.AutoResize,
	}
}
</file>

<file path="textinput_test.go">
package sourcetool

import (
	"context"
	"testing"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/conv"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
	"github.com/trysourcetool/sourcetool-go/textinput"
)

func TestConvertStateToTextInputProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	maxLength := int32(100)
	minLength := int32(10)

	textInputState := &state.TextInputState{
		ID:           id,
		Label:        "Test TextInput",
		Value:        conv.NilValue("test value"),
		Placeholder:  "Enter text",
		DefaultValue: conv.NilValue("default"),
		Required:     true,
		Disabled:     false,
		MaxLength:    &maxLength,
		MinLength:    &minLength,
	}

	data := convertStateToTextInputProto(textInputState)

	if data == nil {
		t.Fatal("convertStateToTextInputProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", data.Label, textInputState.Label},
		{"Value", conv.SafeValue(data.Value), conv.SafeValue(textInputState.Value)},
		{"Placeholder", data.Placeholder, textInputState.Placeholder},
		{"DefaultValue", conv.SafeValue(data.DefaultValue), conv.SafeValue(textInputState.DefaultValue)},
		{"Required", data.Required, textInputState.Required},
		{"Disabled", data.Disabled, textInputState.Disabled},
		{"MaxLength", *data.MaxLength, *textInputState.MaxLength},
		{"MinLength", *data.MinLength, *textInputState.MinLength},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertTextInputProtoToState(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	maxLength := int32(100)
	minLength := int32(10)

	data := &widgetv1.TextInput{
		Label:        "Test TextInput",
		Value:        conv.NilValue("test value"),
		Placeholder:  "Enter text",
		DefaultValue: conv.NilValue("default"),
		Required:     true,
		Disabled:     false,
		MaxLength:    &maxLength,
		MinLength:    &minLength,
	}

	state := convertTextInputProtoToState(id, data)

	if state == nil {
		t.Fatal("convertTextInputProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ID", state.ID, id},
		{"Label", state.Label, data.Label},
		{"Value", conv.SafeValue(state.Value), conv.SafeValue(data.Value)},
		{"Placeholder", state.Placeholder, data.Placeholder},
		{"DefaultValue", conv.SafeValue(state.DefaultValue), conv.SafeValue(data.DefaultValue)},
		{"Required", state.Required, data.Required},
		{"Disabled", state.Disabled, data.Disabled},
		{"MaxLength", *state.MaxLength, *data.MaxLength},
		{"MinLength", *state.MinLength, *data.MinLength},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestTextInput(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test TextInput"
	defaultValue := "default value"
	placeholder := "Enter text"
	maxLength := int32(100)
	minLength := int32(10)

	value := builder.TextInput(label,
		textinput.WithDefaultValue(defaultValue),
		textinput.WithPlaceholder(placeholder),
		textinput.WithRequired(true),
		textinput.WithDisabled(true),
		textinput.WithMaxLength(maxLength),
		textinput.WithMinLength(minLength),
	)

	if value != defaultValue {
		t.Errorf("TextInput value = %v, want %v", value, defaultValue)
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeTextInput, []int{0})
	state := sess.State.GetTextInput(widgetID)
	if state == nil {
		t.Fatal("TextInput state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, label},
		{"Value", conv.SafeValue(state.Value), defaultValue},
		{"Placeholder", state.Placeholder, placeholder},
		{"DefaultValue", conv.SafeValue(state.DefaultValue), defaultValue},
		{"Required", state.Required, true},
		{"Disabled", state.Disabled, true},
		{"MaxLength", *state.MaxLength, maxLength},
		{"MinLength", *state.MinLength, minLength},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}
</file>

<file path="textinput.go">
package sourcetool

import (
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/conv"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/textinput"
)

func convertPathToInt32Slice(p path) []int32 {
	result := make([]int32, len(p))
	for i, v := range p {
		result[i] = int32(v)
	}
	return result
}

func (b *uiBuilder) TextInput(label string, opts ...textinput.Option) string {
	textInputOpts := &options.TextInputOptions{
		Label:        label,
		Placeholder:  "",
		DefaultValue: nil,
		Required:     false,
		Disabled:     false,
		MaxLength:    nil,
		MinLength:    nil,
	}

	for _, o := range opts {
		o.Apply(textInputOpts)
	}

	sess := b.session
	if sess == nil {
		return ""
	}
	page := b.page
	if page == nil {
		return ""
	}
	cursor := b.cursor
	if cursor == nil {
		return ""
	}
	path := cursor.getPath()

	widgetID := b.generatePageID(state.WidgetTypeTextInput, path)
	textInputState := sess.State.GetTextInput(widgetID)
	if textInputState == nil {
		textInputState = &state.TextInputState{
			ID:    widgetID,
			Value: textInputOpts.DefaultValue,
		}
	}
	textInputState.Label = textInputOpts.Label
	textInputState.Placeholder = textInputOpts.Placeholder
	textInputState.DefaultValue = textInputOpts.DefaultValue
	textInputState.Required = textInputOpts.Required
	textInputState.Disabled = textInputOpts.Disabled
	textInputState.MaxLength = textInputOpts.MaxLength
	textInputState.MinLength = textInputOpts.MinLength
	sess.State.Set(widgetID, textInputState)

	textInput := convertStateToTextInputProto(textInputState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_TextInput{
				TextInput: textInput,
			},
		},
	})

	cursor.next()

	return conv.SafeValue(textInputState.Value)
}

func convertStateToTextInputProto(state *state.TextInputState) *widgetv1.TextInput {
	if state == nil {
		return nil
	}
	return &widgetv1.TextInput{
		Value:        state.Value,
		Label:        state.Label,
		Placeholder:  state.Placeholder,
		DefaultValue: state.DefaultValue,
		Required:     state.Required,
		Disabled:     state.Disabled,
		MaxLength:    state.MaxLength,
		MinLength:    state.MinLength,
	}
}

func convertTextInputProtoToState(id uuid.UUID, data *widgetv1.TextInput) *state.TextInputState {
	if data == nil {
		return nil
	}
	return &state.TextInputState{
		ID:           id,
		Value:        data.Value,
		Label:        data.Label,
		Placeholder:  data.Placeholder,
		DefaultValue: data.DefaultValue,
		Required:     data.Required,
		Disabled:     data.Disabled,
		MaxLength:    data.MaxLength,
		MinLength:    data.MinLength,
	}
}
</file>

<file path="timeinput_test.go">
package sourcetool

import (
	"context"
	"testing"
	"time"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/conv"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/internal/websocket/mock"
	"github.com/trysourcetool/sourcetool-go/timeinput"
)

func TestConvertStateToTimeInputProto(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	now := time.Now()

	timeInputState := &state.TimeInputState{
		ID:           id,
		Label:        "Test TimeInput",
		Value:        &now,
		Placeholder:  "Select time",
		DefaultValue: &now,
		Required:     true,
		Disabled:     false,
		Location:     time.Local,
	}

	data := convertStateToTimeInputProto(timeInputState)

	if data == nil {
		t.Fatal("convertStateToTimeInputProto returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", data.Label, timeInputState.Label},
		{"Value", conv.SafeValue(data.Value), timeInputState.Value.Format(time.TimeOnly)},
		{"Placeholder", data.Placeholder, timeInputState.Placeholder},
		{"DefaultValue", conv.SafeValue(data.DefaultValue), timeInputState.DefaultValue.Format(time.TimeOnly)},
		{"Required", data.Required, timeInputState.Required},
		{"Disabled", data.Disabled, timeInputState.Disabled},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertTimeInputProtoToState(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	now := time.Now()
	timeStr := now.Format(time.TimeOnly)

	data := &widgetv1.TimeInput{
		Label:        "Test TimeInput",
		Value:        conv.NilValue(timeStr),
		Placeholder:  "Select time",
		DefaultValue: conv.NilValue(timeStr),
		Required:     true,
		Disabled:     false,
	}

	state, err := convertTimeInputProtoToState(id, data, time.Local)
	if err != nil {
		t.Fatalf("convertTimeInputProtoToState returned error: %v", err)
	}

	if state == nil {
		t.Fatal("convertTimeInputProtoToState returned nil")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"ID", state.ID, id},
		{"Label", state.Label, data.Label},
		{"Value", state.Value.Format(time.TimeOnly), conv.SafeValue(data.Value)},
		{"Placeholder", state.Placeholder, data.Placeholder},
		{"DefaultValue", state.DefaultValue.Format(time.TimeOnly), conv.SafeValue(data.DefaultValue)},
		{"Required", state.Required, data.Required},
		{"Disabled", state.Disabled, data.Disabled},
		{"Location", state.Location.String(), time.Local.String()},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}
}

func TestConvertTimeInputProtoToState_InvalidTime(t *testing.T) {
	id := uuid.Must(uuid.NewV4())
	data := &widgetv1.TimeInput{
		Value: conv.NilValue("invalid-time"),
	}

	_, err := convertTimeInputProtoToState(id, data, time.Local)
	if err == nil {
		t.Error("Expected error for invalid time, got nil")
	}
}

func TestTimeInput(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test TimeInput"
	now := time.Now()
	placeholder := "Select time"
	location := *time.UTC

	value := builder.TimeInput(label,
		timeinput.WithDefaultValue(now),
		timeinput.WithPlaceholder(placeholder),
		timeinput.WithRequired(true),
		timeinput.WithDisabled(true),
		timeinput.WithLocation(location),
	)

	if value == nil {
		t.Fatal("TimeInput returned nil")
	}
	if !value.Equal(now) {
		t.Errorf("TimeInput value = %v, want %v", value, now)
	}

	messages := mockWS.Messages()
	if len(messages) != 1 {
		t.Errorf("WebSocket messages count = %d, want 1", len(messages))
	}
	msg := messages[0]
	if v := msg.GetRenderWidget(); v == nil {
		t.Fatal("WebSocket message type = nil, want RenderWidget")
	}

	widgetID := builder.generatePageID(state.WidgetTypeTimeInput, []int{0})
	state := sess.State.GetTimeInput(widgetID)
	if state == nil {
		t.Fatal("TimeInput state not found")
	}

	tests := []struct {
		name string
		got  any
		want any
	}{
		{"Label", state.Label, label},
		{"Placeholder", state.Placeholder, placeholder},
		{"Required", state.Required, true},
		{"Disabled", state.Disabled, true},
		{"Location", state.Location.String(), location.String()},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.got != tt.want {
				t.Errorf("got %v, want %v", tt.got, tt.want)
			}
		})
	}

	if !state.Value.Equal(*value) {
		t.Errorf("Value = %v, want %v", state.Value, value)
	}
	if !state.DefaultValue.Equal(now) {
		t.Errorf("DefaultValue = %v, want %v", state.DefaultValue, now)
	}
}

func TestTimeInput_DefaultValues(t *testing.T) {
	sessionID := uuid.Must(uuid.NewV4())
	pageID := uuid.Must(uuid.NewV4())
	sess := session.New(sessionID, pageID)

	mockWS := mock.NewClient()

	builder := &uiBuilder{
		context: context.Background(),
		session: sess,
		cursor:  newCursor(),
		page: &page{
			id: pageID,
		},
		runtime: &runtime{
			wsClient: mockWS,
		},
	}

	label := "Test TimeInput"

	builder.TimeInput(label)

	widgetID := builder.generatePageID(state.WidgetTypeTimeInput, []int{0})
	state := sess.State.GetTimeInput(widgetID)
	if state == nil {
		t.Fatal("TimeInput state not found")
	}

	if state.Location != time.Local {
		t.Errorf("Default Location = %v, want %v", state.Location, time.Local)
	}
	if state.Required {
		t.Error("Default Required = true, want false")
	}
	if state.Disabled {
		t.Error("Default Disabled = true, want false")
	}
}
</file>

<file path="timeinput.go">
package sourcetool

import (
	"fmt"
	"time"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/internal/conv"
	"github.com/trysourcetool/sourcetool-go/internal/options"
	websocketv1 "github.com/trysourcetool/sourcetool-go/internal/pb/websocket/v1"
	widgetv1 "github.com/trysourcetool/sourcetool-go/internal/pb/widget/v1"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/timeinput"
)

func (b *uiBuilder) TimeInput(label string, opts ...timeinput.Option) *time.Time {
	timeInputOpts := &options.TimeInputOptions{
		Label:        label,
		Placeholder:  "",
		DefaultValue: nil,
		Required:     false,
		Disabled:     false,
		Location:     time.Local,
	}

	for _, o := range opts {
		o.Apply(timeInputOpts)
	}

	sess := b.session
	if sess == nil {
		return nil
	}
	page := b.page
	if page == nil {
		return nil
	}
	cursor := b.cursor
	if cursor == nil {
		return nil
	}
	path := cursor.getPath()

	widgetID := b.generatePageID(state.WidgetTypeTimeInput, path)
	timeInputState := sess.State.GetTimeInput(widgetID)
	if timeInputState == nil {
		timeInputState = &state.TimeInputState{
			ID:    widgetID,
			Value: timeInputOpts.DefaultValue,
		}
	}
	timeInputState.Label = timeInputOpts.Label
	timeInputState.Placeholder = timeInputOpts.Placeholder
	timeInputState.DefaultValue = timeInputOpts.DefaultValue
	timeInputState.Required = timeInputOpts.Required
	timeInputState.Disabled = timeInputOpts.Disabled
	timeInputState.Location = timeInputOpts.Location
	sess.State.Set(widgetID, timeInputState)

	timeInput := convertStateToTimeInputProto(timeInputState)
	b.runtime.wsClient.Enqueue(uuid.Must(uuid.NewV4()).String(), &websocketv1.RenderWidget{
		SessionId: sess.ID.String(),
		PageId:    page.id.String(),
		Path:      convertPathToInt32Slice(path),
		Widget: &widgetv1.Widget{
			Id: widgetID.String(),
			Type: &widgetv1.Widget_TimeInput{
				TimeInput: timeInput,
			},
		},
	})

	cursor.next()

	return timeInputState.Value
}

func convertTimeInputProtoToState(id uuid.UUID, data *widgetv1.TimeInput, location *time.Location) (*state.TimeInputState, error) {
	if data == nil {
		return nil, nil
	}

	parseTime := func(timeStr string) (*time.Time, error) {
		if timeStr == "" {
			return nil, nil
		}
		t, err := time.ParseInLocation(time.TimeOnly, timeStr, location)
		if err != nil {
			return nil, fmt.Errorf("failed to parse time %q: %v", timeStr, err)
		}
		return &t, nil
	}

	value, err := parseTime(conv.SafeValue(data.Value))
	if err != nil {
		return nil, err
	}

	defaultValue, err := parseTime(conv.SafeValue(data.DefaultValue))
	if err != nil {
		return nil, err
	}

	return &state.TimeInputState{
		ID:           id,
		Value:        value,
		Label:        data.Label,
		DefaultValue: defaultValue,
		Placeholder:  data.Placeholder,
		Required:     data.Required,
		Disabled:     data.Disabled,
		Location:     location,
	}, nil
}

func convertStateToTimeInputProto(state *state.TimeInputState) *widgetv1.TimeInput {
	if state == nil {
		return nil
	}
	var value, defaultValue string
	if state.Value != nil {
		value = state.Value.Format(time.TimeOnly)
	}
	if state.DefaultValue != nil {
		defaultValue = state.DefaultValue.Format(time.TimeOnly)
	}
	return &widgetv1.TimeInput{
		Value:        conv.NilValue(value),
		Label:        state.Label,
		Placeholder:  state.Placeholder,
		DefaultValue: conv.NilValue(defaultValue),
		Required:     state.Required,
		Disabled:     state.Disabled,
	}
}
</file>

<file path="uibuilder_test.go">
package sourcetool

import (
	"context"
	"testing"
)

func TestCursor_PathManagement(t *testing.T) {
	c := newCursor()

	// Test initial path
	initialPath := c.getPath()
	if len(initialPath) != 1 || initialPath[0] != 0 {
		t.Errorf("initial path = %v, want [0]", initialPath)
	}

	// Test next()
	c.next()
	nextPath := c.getPath()
	if len(nextPath) != 1 || nextPath[0] != 1 {
		t.Errorf("path after next() = %v, want [1]", nextPath)
	}

	// Add parent path
	c.parentPath = append(c.parentPath, 1)
	parentPath := c.getPath()
	if len(parentPath) != 2 || parentPath[0] != 1 || parentPath[1] != 1 {
		t.Errorf("path with parent = %v, want [1,1]", parentPath)
	}
}

func TestPath_String(t *testing.T) {
	tests := []struct {
		path path
		want string
	}{
		{path{0}, "0"},
		{path{1, 2, 3}, "123"},
		{path{0, 1, 0}, "010"},
	}

	for _, tt := range tests {
		t.Run(tt.want, func(t *testing.T) {
			if got := tt.path.String(); got != tt.want {
				t.Errorf("path.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUIBuilder_Context(t *testing.T) {
	ctx := context.Background()
	builder := &uiBuilder{
		context: ctx,
	}

	if got := builder.Context(); got != ctx {
		t.Errorf("Context() = %v, want %v", got, ctx)
	}
}
</file>

<file path="uibuilder.go">
package sourcetool

import (
	"context"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool-go/button"
	"github.com/trysourcetool/sourcetool-go/checkbox"
	"github.com/trysourcetool/sourcetool-go/checkboxgroup"
	"github.com/trysourcetool/sourcetool-go/columns"
	"github.com/trysourcetool/sourcetool-go/dateinput"
	"github.com/trysourcetool/sourcetool-go/datetimeinput"
	"github.com/trysourcetool/sourcetool-go/form"
	"github.com/trysourcetool/sourcetool-go/internal/session"
	"github.com/trysourcetool/sourcetool-go/internal/session/state"
	"github.com/trysourcetool/sourcetool-go/multiselect"
	"github.com/trysourcetool/sourcetool-go/numberinput"
	"github.com/trysourcetool/sourcetool-go/radio"
	"github.com/trysourcetool/sourcetool-go/selectbox"
	"github.com/trysourcetool/sourcetool-go/table"
	"github.com/trysourcetool/sourcetool-go/textarea"
	"github.com/trysourcetool/sourcetool-go/textinput"
	"github.com/trysourcetool/sourcetool-go/timeinput"
)

type UIBuilder interface {
	Context() context.Context
	Markdown(string)
	TextInput(string, ...textinput.Option) string
	NumberInput(string, ...numberinput.Option) *float64
	DateInput(string, ...dateinput.Option) *time.Time
	DateTimeInput(string, ...datetimeinput.Option) *time.Time
	TimeInput(string, ...timeinput.Option) *time.Time
	Selectbox(string, ...selectbox.Option) *selectbox.Value
	MultiSelect(string, ...multiselect.Option) *multiselect.Value
	Radio(string, ...radio.Option) *radio.Value
	Checkbox(string, ...checkbox.Option) bool
	CheckboxGroup(string, ...checkboxgroup.Option) *checkboxgroup.Value
	TextArea(string, ...textarea.Option) string
	Table(any, ...table.Option) table.Value
	Button(string, ...button.Option) bool
	Form(string, ...form.Option) (UIBuilder, bool)
	Columns(int, ...columns.Option) []UIBuilder
}

type uiBuilder struct {
	runtime *runtime
	context context.Context
	cursor  *cursor
	session *session.Session
	page    *page
}

func (b *uiBuilder) Context() context.Context {
	return b.context
}

func (b *uiBuilder) generatePageID(widgetType state.WidgetType, path []int) uuid.UUID {
	if b.page == nil {
		return uuid.Nil
	}
	strPath := make([]string, len(path))
	for i, v := range path {
		strPath[i] = strconv.Itoa(v)
	}
	return uuid.NewV5(b.page.id, widgetType.String()+"-"+strings.Join(strPath, "_"))
}

type path []int

func (p path) String() string {
	strPath := make([]string, len(p))
	for i, num := range p {
		strPath[i] = fmt.Sprint(num)
	}
	return strings.Join(strPath, "")
}

type cursor struct {
	parentPath []int
	index      int
}

func newCursor() *cursor {
	return &cursor{
		parentPath: []int{},
		index:      0,
	}
}

func (c *cursor) getPath() path {
	path := make([]int, len(c.parentPath))
	copy(path, c.parentPath)
	path = append(path, c.index)
	return path
}

func (c *cursor) next() {
	c.index++
}
</file>

<file path=".gitignore">
.DS_Store
.env
</file>

<file path="README.md">
# Sourcetool Go SDK

[![Go Reference](https://pkg.go.dev/badge/github.com/trysourcetool/sourcetool-go.svg)](https://pkg.go.dev/github.com/trysourcetool/sourcetool-go)
[![Go Report Card](https://goreportcard.com/badge/github.com/trysourcetool/sourcetool-go)](https://goreportcard.com/report/github.com/trysourcetool/sourcetool-go)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

Sourcetool Go SDK is a powerful toolkit for building internal tools with just backend code. It provides a rich set of UI components and handles all the frontend complexities, allowing developers to focus on business logic implementation.

## Features

- 🚀 **Backend-Only Development**: Build full-featured internal tools without writing any frontend code
- 🎨 **Rich UI Components**: Comprehensive set of pre-built components (forms, tables, inputs, etc.)
- ⚡ **Real-time Updates**: Built-in WebSocket support for live data synchronization
- 🔒 **Type-Safe**: Fully typed API for reliable development
- 🛠 **Flexible Backend**: Freedom to implement any business logic in pure Go

## Installation

```bash
go get github.com/trysourcetool/sourcetool-go
```

## Quick Start

### Prerequisites

1. Get your API key from [Sourcetool Dashboard](https://trysourcetool.com)
2. Install Go 1.18 or later

### Basic Example

Here's a simple example of creating a user management page:

```go
package main

import (
    "github.com/trysourcetool/sourcetool-go"
    "github.com/trysourcetool/sourcetool-go/textinput"
    "github.com/trysourcetool/sourcetool-go/table"
)

func listUsersPage(ui sourcetool.UIBuilder) error {
    ui.Markdown("## Users")

    // Search form
    name := ui.TextInput("Name", textinput.Placeholder("Enter name to search"))
    
    // Display users table
    users, err := listUsers(name)
    if err != nil {
        return err
    }
    
    ui.Table(users, table.Header("Users List"))
    
    return nil
}

func main() {
    st := sourcetool.New("your-api-key")
    
    // Register pages
    st.Page("/users", "Users List", listUsersPage)
    
    if err := st.Listen(); err != nil {
        log.Fatal(err)
    }
}
```

## Available Components

Sourcetool provides a wide range of UI components:

### Input Components
- TextInput: Single-line text input
- TextArea: Multi-line text input
- NumberInput: Numeric input with validation
- DateInput: Date picker
- DateTimeInput: Date and time picker
- TimeInput: Time picker

### Selection Components
- Selectbox: Single-select dropdown
- MultiSelect: Multi-select dropdown
- Radio: Radio button group
- Checkbox: Single checkbox
- CheckboxGroup: Group of checkboxes

### Layout Components
- Columns: Multi-column layout
- Form: Form container with submit button
- Table: Data table with sorting and selection

### Display Components
- Markdown: Formatted text display

### Interactive Components
- Button: Clickable button

## Component Options

Each component supports various options for customization:

```go
// TextInput with options
ui.TextInput("Username",
    textinput.Placeholder("Enter username"),
    textinput.Required(true),
    textinput.MaxLength(50),
)

// Table with options
ui.Table(data,
    table.Header("Users"),
    table.OnSelect(table.SelectionBehaviorRerun),
    table.RowSelection(table.SelectionModeSingle),
)
```

## Advanced Usage

### Error Handling

Sourcetool provides robust error handling:

```go
func userProfilePage(ui sourcetool.UIBuilder) error {
    user, err := fetchUserProfile()
    if err != nil {
        // Display error message to the user
        ui.Markdown("⚠️ Error: Failed to load user profile")
        return err
    }
    
    ui.Markdown(fmt.Sprintf("## Welcome, %s!", user.Name))
    return nil
}
```

### Complex Forms

Example of a form with multiple fields and validation:

```go
func createUserPage(ui sourcetool.UIBuilder) error {
    form, submitted := ui.Form("Create User", form.ClearOnSubmit(true))
    
    name := form.TextInput("Name", 
        textinput.Required(true),
        textinput.MinLength(2),
        textinput.MaxLength(50),
    )
    
    email := form.TextInput("Email",
        textinput.Required(true),
        textinput.Placeholder("user@example.com"),
    )
    
    role := form.Selectbox("Role",
        selectbox.Options("Admin", "User", "Guest"),
        selectbox.Required(true),
    )
    
    if submitted {
        user := User{
            Name: name,
            Email: email,
            Role: role.Value,
        }
        if err := createUser(&user); err != nil {
            return err
        }
    }
    
    return nil
}
```

## Documentation

For detailed documentation and examples, visit our [documentation site](https://docs.trysourcetool.com).

## Upgrading

When upgrading to a new version:

1. Check the [changelog](https://github.com/trysourcetool/sourcetool-go/releases) for breaking changes
2. Update your dependencies:
   ```bash
   go get -u github.com/trysourcetool/sourcetool-go
   ```
3. Run tests to ensure compatibility
4. Review deprecated features and update accordingly

## Development

### Setup

1. Clone the repository:
   ```bash
   git clone https://github.com/trysourcetool/sourcetool-go.git
   cd sourcetool-go
   ```

2. Install dependencies:
   ```bash
   go mod download
   ```

### Testing

```bash
# Run all tests
go test ./...

# Run tests with coverage
go test -cover ./...

# Run tests for a specific package
go test ./internal/websocket/...
```

## Contributing

We welcome contributions! Here's how you can help:

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Follow standard Go formatting guidelines
4. Add tests for new features
5. Update documentation as needed
6. Commit your changes (`git commit -m 'Add some amazing feature'`)
7. Push to the branch (`git push origin feature/amazing-feature`)
8. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
</file>

</files>
