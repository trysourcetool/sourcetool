This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
cmd/
  server/
    main.go
config/
  config_test.go
  config.go
devtools/
  cmd/
    db/
      main.go
  create_migrate.sh
docs/
  docs.go
  swagger.json
  swagger.yaml
ee/
  cmd/
    server/
      main.go
  internal/
    app/
      apikey/
        service.go
      auth/
        service.go
      environment/
        service.go
      group/
        service.go
        validate.go
      hostinstance/
        service.go
      organization/
        service.go
      page/
        service.go
      user/
        service.go
      ws/
        service.go
    infra/
      postgres/
        apikey/
          repository.go
        environment/
          repository.go
        group/
          repository.go
        hostinstance/
          repository.go
        organization/
          repository.go
        page/
          repository.go
        session/
          repository.go
        user/
          repository.go
        repository.go
    transport/
      http/
        v1/
          middleware.go
          router.go
      ws/
        middleware.go
        router.go
      router.go
  .gitignore
  LICENSE
fixtures/
  fixtures.go
internal/
  app/
    apikey/
      service.go
    auth/
      email.go
      google.go
      service.go
      sign.go
      token_test.go
      token.go
      url_test.go
      url.go
    dto/
      apikey.go
      auth.go
      environment.go
      group.go
      hostinstance.go
      organization.go
      page.go
      session.go
      user.go
      ws.go
    environment/
      service.go
      validate.go
    group/
      service.go
    hostinstance/
      service.go
    organization/
      reserved_subdomains.go
      service.go
    page/
      service.go
    permission/
      checker.go
    port/
      dependencies.go
      mailer.go
      pubsub.go
      repository.go
      wsmanager.go
    user/
      email.go
      service.go
      sign.go
      url_test.go
      url.go
    ws/
      service.go
  ctxdata/
    internal.go
  domain/
    apikey/
      apikey.go
      repository.go
    auth/
      auth.go
    environment/
      environment.go
      repository.go
    group/
      group.go
      repository.go
    hostinstance/
      hostinstance.go
      repository.go
    organization/
      organization.go
      repository.go
    page/
      page.go
      repository.go
    permission/
      permission.go
    session/
      repository.go
      session.go
    user/
      repository.go
      user.go
  infra/
    postgres/
      apikey/
        repository.go
      db/
        db.go
      environment/
        repository.go
      group/
        repository.go
      hostinstance/
        repository.go
      organization/
        repository.go
      page/
        repository.go
      session/
        repository.go
      user/
        repository.go
      migrate.go
      postgres.go
      repository.go
    redis/
      client.go
    smtp/
      mailer.go
    wsmanager/
      ping.go
      subscriber.go
      types.go
      wsmanager.go
  jwt/
    claims.go
    jwt.go
  pb/
    go/
      exception/
        v1/
          exception.pb.go
      page/
        v1/
          page.pb.go
      redis/
        v1/
          redis.pb.go
      websocket/
        v1/
          message.pb.go
      widget/
        v1/
          widget.pb.go
  transport/
    http/
      v1/
        handlers/
          apikey.go
          auth.go
          cookie.go
          environment.go
          group.go
          hostinstance.go
          organization.go
          page.go
          user.go
        mapper/
          apikey.go
          auth.go
          environment.go
          group.go
          hostinstance.go
          organization.go
          page.go
          user.go
        requests/
          apikey.go
          auth.go
          environment.go
          group.go
          hostinstance.go
          organization.go
          page.go
          user.go
        responses/
          apikey.go
          auth.go
          environment.go
          group.go
          hostinstance.go
          organization.go
          page.go
          status.go
          user.go
        middleware.go
        router.go
    ws/
      handlers/
        handlers.go
      message/
        message.go
      middleware.go
      router.go
    router.go
    static.go
logger/
  logger.go
migrations/
  000001_initial_schema.down.sql
  000001_initial_schema.up.sql
pkg/
  errdefs/
    errdefs.go
  httpx/
    httpx_test.go
    internal.go
  internal/
    internal.go
  urlx/
    urlx.go
.dockerignore
.gitignore
.golangci.yml
go.mod
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cmd/server/main.go">
package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	_ "github.com/lib/pq"
	"go.uber.org/zap"
	"golang.org/x/sync/errgroup"

	"github.com/trysourcetool/sourcetool/backend/config"
	_ "github.com/trysourcetool/sourcetool/backend/docs"
	"github.com/trysourcetool/sourcetool/backend/fixtures"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/redis"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/smtp"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/wsmanager"
	"github.com/trysourcetool/sourcetool/backend/internal/transport"
	"github.com/trysourcetool/sourcetool/backend/logger"
)

func init() {
	config.Init()
	logger.Init()
}

// @title Sourcetool API
// @version 1.0
// @description Sourcetool's API documentation
// @termsOfService http://swagger.io/terms/
// @host https://api.trysourcetool.com
// @BasePath /api/v1.
func main() {
	ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer cancel()

	db, err := postgres.New()
	if err != nil {
		logger.Logger.Fatal("failed to open postgres", zap.Error(err))
	}

	logger.Logger.Sugar().Infof("Connected to Postgres at %s:%s", config.Config.Postgres.Host, config.Config.Postgres.Port)

	redisClient, err := redis.NewClientCE()
	if err != nil {
		logger.Logger.Fatal("failed to open redis", zap.Error(err))
	}

	logger.Logger.Sugar().Infof("Connected to Redis at %s:%s", config.Config.Redis.Host, config.Config.Redis.Port)

	repo := postgres.NewRepositoryCE(db)
	smtpMailer := smtp.NewMailerCE()
	wsManager := wsmanager.NewManager(ctx, repo, redisClient)

	// Initialize infra dependency container
	dep := port.NewDependencies(repo, smtpMailer, redisClient, wsManager)

	if config.Config.Env == config.EnvLocal {
		if err := fixtures.Load(ctx, dep.Repository); err != nil {
			logger.Logger.Fatal(err.Error())
		}
	}

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
		logger.Logger.Info(fmt.Sprintf("Defaulting to port %s\n", port))
	}

	srv := &http.Server{
		ReadHeaderTimeout: 10 * time.Second,
		ReadTimeout:       10 * time.Second,
		WriteTimeout:      600 * time.Second,
		Handler:           transport.NewRouter(dep).Build(),
		Addr:              fmt.Sprintf(":%s", port),
	}

	eg, egCtx := errgroup.WithContext(ctx)
	eg.Go(func() error {
		logger.Logger.Info(fmt.Sprintf("Listening on port %s\n", port))
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			return fmt.Errorf("HTTP server error: %v", err)
		}
		return nil
	})
	eg.Go(func() error {
		<-egCtx.Done()
		logger.Logger.Info("Shutting down server...")

		shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer shutdownCancel()

		// Attempt to gracefully shut down the server first.
		var shutdownErr error
		if err := srv.Shutdown(shutdownCtx); err != nil {
			logger.Logger.Error("Server shutdown error", zap.Error(err))
			shutdownErr = fmt.Errorf("server shutdown: %v", err)
		}

		if err := wsManager.Close(); err != nil {
			logger.Logger.Sugar().Errorf("WebSocket manager graceful shutdown failed: %v", err)
		} else {
			logger.Logger.Sugar().Info("WebSocket manager gracefully stopped")
		}

		if err := redisClient.Close(); err != nil {
			logger.Logger.Sugar().Errorf("Redis client close failed: %v", err)
		} else {
			logger.Logger.Sugar().Info("Redis client gracefully stopped")
		}

		if err := db.Close(); err != nil {
			logger.Logger.Sugar().Errorf("DB connection close failed: %v", err)
		} else {
			logger.Logger.Sugar().Info("DB connection gracefully stopped")
		}

		logger.Logger.Info("Server shutdown complete")
		// Return the server shutdown error if it happened.
		return shutdownErr
	})

	if err := eg.Wait(); err != nil && err != http.ErrServerClosed {
		logger.Logger.Error(fmt.Sprintf("Error during shutdown: %v", err))
		os.Exit(1)
	}
}
</file>

<file path="config/config_test.go">
package config

import (
	"strings"
	"testing"
)

func TestConfig_HostnameAndDomain(t *testing.T) {
	tests := []struct {
		name           string
		baseURL        string
		isCloudEdition bool
		subdomain      string
		wantAuthHost   string
		wantOrgHost    string
		wantAuthDomain string
		wantOrgDomain  string
	}{
		{
			name:           "local environment",
			baseURL:        "http://localhost:3000",
			isCloudEdition: false,
			subdomain:      "test",
			wantAuthHost:   "localhost:3000",
			wantOrgHost:    "localhost:3000",
			wantAuthDomain: "localhost",
			wantOrgDomain:  "localhost",
		},
		{
			name:           "non-cloud edition with custom domain",
			baseURL:        "https://custom-domain.com:8080",
			isCloudEdition: false,
			subdomain:      "test",
			wantAuthHost:   "custom-domain.com:8080",
			wantOrgHost:    "custom-domain.com:8080",
			wantAuthDomain: "custom-domain.com",
			wantOrgDomain:  "custom-domain.com",
		},
		{
			name:           "cloud edition",
			baseURL:        "https://example.com",
			isCloudEdition: true,
			subdomain:      "test",
			wantAuthHost:   "auth.example.com",
			wantOrgHost:    "test.example.com",
			wantAuthDomain: "auth.example.com",
			wantOrgDomain:  "test.example.com",
		},
		{
			name:           "cloud edition with port",
			baseURL:        "https://example.com:8080",
			isCloudEdition: true,
			subdomain:      "test",
			wantAuthHost:   "auth.example.com:8080",
			wantOrgHost:    "test.example.com:8080",
			wantAuthDomain: "auth.example.com",
			wantOrgDomain:  "test.example.com",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cfg := &Cfg{
				BaseURL:        tt.baseURL,
				IsCloudEdition: tt.isCloudEdition,
			}

			// Parse BaseURL to set Protocol and BaseHostname
			baseURLParts := strings.Split(tt.baseURL, "://")
			if len(baseURLParts) != 2 {
				t.Fatalf("invalid BASE_URL format: %s", tt.baseURL)
			}
			cfg.Protocol = baseURLParts[0]
			cfg.BaseHostname = baseURLParts[1]
			cfg.SSL = cfg.Protocol == "https"

			hostnameParts := strings.Split(cfg.BaseHostname, ":")
			cfg.BaseDomain = hostnameParts[0]

			// Test AuthHostname
			if got := cfg.AuthHostname(); got != tt.wantAuthHost {
				t.Errorf("AuthHostname() = %v, want %v", got, tt.wantAuthHost)
			}

			// Test OrgHostname
			if got := cfg.OrgHostname(tt.subdomain); got != tt.wantOrgHost {
				t.Errorf("OrgHostname() = %v, want %v", got, tt.wantOrgHost)
			}

			// Test AuthDomain
			if got := cfg.AuthDomain(); got != tt.wantAuthDomain {
				t.Errorf("AuthDomain() = %v, want %v", got, tt.wantAuthDomain)
			}

			// Test OrgDomain
			if got := cfg.OrgDomain(tt.subdomain); got != tt.wantOrgDomain {
				t.Errorf("OrgDomain() = %v, want %v", got, tt.wantOrgDomain)
			}

			// Test AuthBaseURL
			wantAuthBaseURL := cfg.Protocol + "://" + tt.wantAuthHost
			if got := cfg.AuthBaseURL(); got != wantAuthBaseURL {
				t.Errorf("AuthBaseURL() = %v, want %v", got, wantAuthBaseURL)
			}

			// Test OrgBaseURL
			wantOrgBaseURL := cfg.Protocol + "://" + tt.wantOrgHost
			if got := cfg.OrgBaseURL(tt.subdomain); got != wantOrgBaseURL {
				t.Errorf("OrgBaseURL() = %v, want %v", got, wantOrgBaseURL)
			}

			// Test WebSocketOrgBaseURL
			wantWSOrgBaseURL := "ws"
			if cfg.SSL {
				wantWSOrgBaseURL = "wss"
			}
			wantWSOrgBaseURL += "://" + tt.wantOrgHost
			if got := cfg.WebSocketOrgBaseURL(tt.subdomain); got != wantWSOrgBaseURL {
				t.Errorf("WebSocketOrgBaseURL() = %v, want %v", got, wantWSOrgBaseURL)
			}
		})
	}
}
</file>

<file path="config/config.go">
package config

import (
	"log"
	"regexp"
	"strings"

	"github.com/caarlos0/env/v11"
)

var Config *Cfg

const (
	EnvLocal   = "local"
	EnvStaging = "staging"
	EnvProd    = "prod"
)

type Cfg struct {
	Env            string `env:"ENV"`
	BaseURL        string `env:"BASE_URL"`
	SSL            bool   `env:"-"`
	Protocol       string `env:"-"`
	BaseDomain     string `env:"-"`
	BaseHostname   string `env:"-"`
	IsCloudEdition bool   `env:"-"`
	EncryptionKey  string `env:"ENCRYPTION_KEY"`
	Jwt            struct {
		Key string `env:"JWT_KEY"`
	}
	Postgres struct {
		User     string `env:"POSTGRES_USER"`
		Password string `env:"POSTGRES_PASSWORD"`
		DB       string `env:"POSTGRES_DB"`
		Host     string `env:"POSTGRES_HOST"`
		Port     string `env:"POSTGRES_PORT"`
	}
	Redis struct {
		Host     string `env:"REDIS_HOST"`
		Port     string `env:"REDIS_PORT"`
		Password string `env:"REDIS_PASSWORD"`
	}
	Google struct {
		OAuth struct {
			ClientID     string `env:"GOOGLE_OAUTH_CLIENT_ID"`
			ClientSecret string `env:"GOOGLE_OAUTH_CLIENT_SECRET"`
		}
	}
	SMTP struct {
		Host      string `env:"SMTP_HOST"`
		Port      string `env:"SMTP_PORT"`
		Username  string `env:"SMTP_USERNAME"`
		Password  string `env:"SMTP_PASSWORD"`
		FromEmail string `env:"SMTP_FROM_EMAIL"`
	}
}

func Init() {
	cfg := new(Cfg)
	envOpts := env.Options{RequiredIfNoDef: true}
	if err := env.ParseWithOptions(cfg, envOpts); err != nil {
		log.Fatal("[INIT] config: ", err)
	}

	cfg.BaseURL = strings.TrimRight(cfg.BaseURL, "/")

	cfg.IsCloudEdition = isCloudEdition(cfg.BaseURL)

	baseURLParts := strings.Split(cfg.BaseURL, "://")
	if len(baseURLParts) != 2 {
		log.Fatal("[INIT] invalid BASE_URL format: ", cfg.BaseURL)
	}
	cfg.Protocol = baseURLParts[0]
	cfg.BaseHostname = baseURLParts[1]
	cfg.SSL = cfg.Protocol == "https"

	hostnameParts := strings.Split(cfg.BaseHostname, ":")
	cfg.BaseDomain = hostnameParts[0]

	Config = cfg
}

// AuthHostname returns the hostname for the Auth domain.
func (c *Cfg) AuthHostname() string {
	if c.IsCloudEdition {
		return "auth." + c.BaseHostname
	}
	return c.BaseHostname
}

// OrgHostname returns the hostname for the organization.
func (c *Cfg) OrgHostname(subdomain string) string {
	if c.IsCloudEdition {
		return subdomain + "." + c.BaseHostname
	}
	return c.BaseHostname
}

// AuthDomain returns the domain for the Auth domain.
func (c *Cfg) AuthDomain() string {
	if c.IsCloudEdition {
		return "auth." + c.BaseDomain
	}
	return c.BaseDomain
}

// OrgDomain returns the domain for the organization.
func (c *Cfg) OrgDomain(subdomain string) string {
	if c.IsCloudEdition {
		return subdomain + "." + c.BaseDomain
	}
	return c.BaseDomain
}

// AuthBaseURL returns the base URL for the Auth domain.
func (c *Cfg) AuthBaseURL() string {
	return c.Protocol + "://" + c.AuthHostname()
}

// OrgBaseURL returns the base URL for the organization domain.
func (c *Cfg) OrgBaseURL(subdomain string) string {
	return c.Protocol + "://" + c.OrgHostname(subdomain)
}

// WebSocketOrgBaseURL returns the base URL for the organization domain for WebSocket connections.
func (c *Cfg) WebSocketOrgBaseURL(subdomain string) string {
	if c.SSL {
		return "wss://" + c.OrgHostname(subdomain)
	}
	return "ws://" + c.OrgHostname(subdomain)
}

func isCloudEdition(baseURL string) bool {
	cloudDomainRegex := regexp.MustCompile(`^https?://(?:([^.]+)\.)?trysourcetool\.com(?::\d+)?$`)
	matches := cloudDomainRegex.FindStringSubmatch(baseURL)
	return len(matches) > 1
}
</file>

<file path="devtools/cmd/db/main.go">
package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"

	_ "github.com/lib/pq"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres"
	"github.com/trysourcetool/sourcetool/backend/logger"
)

func init() {
	config.Init()
	logger.Init()
}

func main() {
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "usage: db [cmd] [args...]\n")
		fmt.Fprintf(flag.CommandLine.Output(), "Commands:\n")
		fmt.Fprintf(flag.CommandLine.Output(), "  migrate [dir]: runs all migrations (default dir: migrations)\n")
	}

	flag.Parse()
	if flag.NArg() < 1 {
		flag.Usage()
		os.Exit(1)
	}

	ctx := context.Background()
	if err := run(ctx, flag.Args()[0]); err != nil {
		log.Fatal(err)
	}
}

func run(ctx context.Context, cmd string) error {
	switch cmd {
	case "migrate":
		dir := "migrations"
		if flag.NArg() > 1 {
			dir = flag.Arg(1)
		}
		return migrate(dir)
	default:
		return fmt.Errorf("unsupported arg: %q", cmd)
	}
}

func migrate(dir string) error {
	return postgres.Migrate(dir)
}
</file>

<file path="devtools/create_migrate.sh">
migrate create -ext sql -dir migrations -seq $1
HEADER="BEGIN;

-- Write your migration here.

END;"
for f in $(ls migrations | tail -n 2); do echo "$HEADER" >> "migrations/$f"; done
</file>

<file path="docs/docs.go">
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/apiKeys": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "apiKeys"
                ],
                "operationId": "list-apikeys",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ListAPIKeysResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "apiKeys"
                ],
                "operationId": "create-apikey",
                "parameters": [
                    {
                        "description": "API key creation data including name and expiration",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.CreateAPIKeyRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.CreateAPIKeyResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/apiKeys/{apiKeyID}": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "apiKeys"
                ],
                "operationId": "get-apikey",
                "parameters": [
                    {
                        "type": "string",
                        "description": "API Key ID",
                        "name": "apiKeyID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.GetAPIKeyResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "apiKeys"
                ],
                "operationId": "update-apikey",
                "parameters": [
                    {
                        "description": "API key update data including name and status",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateAPIKeyRequest"
                        }
                    },
                    {
                        "type": "string",
                        "description": "API Key ID to update",
                        "name": "apiKeyID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateAPIKeyResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "404": {
                        "description": "API key not found",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "delete": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "apiKeys"
                ],
                "operationId": "delete-apikey",
                "parameters": [
                    {
                        "type": "string",
                        "description": "API Key ID",
                        "name": "apiKeyID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.DeleteAPIKeyResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/google/authenticate": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "authenticate-with-google",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.AuthenticateWithGoogleResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/google/register": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "register-with-google",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RegisterWithGoogleResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/google/request": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "request-google-auth-link",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestGoogleAuthLinkResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/invitations/google/request": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "request-invitation-google-auth-link",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestInvitationGoogleAuthLinkResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/invitations/magic/authenticate": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "authenticate-with-invitation-magic-link",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.AuthenticateWithInvitationMagicLinkRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.AuthenticateWithInvitationMagicLinkResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/invitations/magic/register": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "register-with-invitation-magic-link",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.RegisterWithInvitationMagicLinkRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RegisterWithInvitationMagicLinkResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/invitations/magic/request": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "request-invitation-magic-link",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestInvitationMagicLinkResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "logout",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.StatusResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/magic/authenticate": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "authenticate-with-magic-link",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.AuthenticateWithMagicLinkRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.AuthenticateWithMagicLinkResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/magic/register": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "register-with-magic-link",
                "parameters": [
                    {
                        "description": "Registration data with magic link token",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.RegisterWithMagicLinkRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RegisterWithMagicLinkResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "401": {
                        "description": "Invalid or expired magic link token",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/magic/request": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "request-magic-link",
                "parameters": [
                    {
                        "description": "Email address for magic link",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.RequestMagicLinkRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestMagicLinkResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid email format",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "404": {
                        "description": "User not found",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/refresh": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "refresh-token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RefreshTokenResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/save": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "save-auth",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.SaveAuthRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.SaveAuthResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/token/obtain": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "obtain-auth-token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ObtainAuthTokenResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/environments": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "environments"
                ],
                "operationId": "list-environments",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ListEnvironmentsResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "environments"
                ],
                "operationId": "create-environment",
                "parameters": [
                    {
                        "description": "Environment creation data including name and configuration",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.CreateEnvironmentRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.CreateEnvironmentResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/environments/{environmentID}": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "environments"
                ],
                "operationId": "get-environment",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Environment ID",
                        "name": "environmentID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.GetEnvironmentResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "environments"
                ],
                "operationId": "update-environment",
                "parameters": [
                    {
                        "description": "Environment update data including name and configuration",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateEnvironmentRequest"
                        }
                    },
                    {
                        "type": "string",
                        "description": "Environment ID to update",
                        "name": "environmentID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateEnvironmentResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "404": {
                        "description": "Environment not found",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "delete": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "environments"
                ],
                "operationId": "delete-environment",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Environment ID",
                        "name": "environmentID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.DeleteEnvironmentResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/groups": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "operationId": "list-groups",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ListGroupsResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "operationId": "create-group",
                "parameters": [
                    {
                        "description": "Group creation data including name and members",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.CreateGroupRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.CreateGroupResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/groups/{groupID}": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "operationId": "get-group",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Group ID",
                        "name": "groupID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.GetGroupResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "operationId": "update-group",
                "parameters": [
                    {
                        "description": "Group update data including name and members",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateGroupRequest"
                        }
                    },
                    {
                        "type": "string",
                        "description": "Group ID to update",
                        "name": "groupID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateGroupResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "404": {
                        "description": "Group not found",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "delete": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "operationId": "delete-group",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Group ID",
                        "name": "groupID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.DeleteGroupResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/hostInstances/ping": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "hostInstances"
                ],
                "operationId": "ping-host-instance",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Page ID",
                        "name": "pageId",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.PingHostInstanceResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/organizations": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "organizations"
                ],
                "operationId": "create-organization",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.CreateOrganizationRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.CreateOrganizationResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/organizations/checkSubdomainAvailability": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "organizations"
                ],
                "operationId": "check-organization-subdomain-availability",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Subdomain to check for availability",
                        "name": "subdomain",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.StatusResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid subdomain format",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "409": {
                        "description": "Subdomain already exists",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/pages": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "pages"
                ],
                "operationId": "list-pages",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Environment ID",
                        "name": "environmentId",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ListPagesResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "list-users",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ListUsersResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users/invitations": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "create-user-invitations",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.CreateUserInvitationsRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.CreateUserInvitationsResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users/invitations/{invitationID}/resend": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "resend-user-invitation",
                "parameters": [
                    {
                        "type": "string",
                        "description": " ",
                        "name": "invitationID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ResendUserInvitationResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users/me": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "get-me",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.GetMeResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "update-me",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateMeRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateMeResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users/me/email": {
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "update-me-email",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateMeEmailRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateMeEmailResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users/me/email/instructions": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "send-update-me-email-instructions",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.SendUpdateMeEmailInstructionsRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.StatusResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users/{userID}": {
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "update-user",
                "parameters": [
                    {
                        "type": "string",
                        "description": " ",
                        "name": "userID",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateUserRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateUserResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "delete": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "delete-user",
                "parameters": [
                    {
                        "type": "string",
                        "description": " ",
                        "name": "userID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.StatusResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "errdefs.Error": {
            "type": "object",
            "properties": {
                "detail": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {}
                },
                "status": {
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "requests.AuthenticateWithInvitationMagicLinkRequest": {
            "type": "object",
            "required": [
                "token"
            ],
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "requests.AuthenticateWithMagicLinkRequest": {
            "type": "object",
            "required": [
                "token"
            ],
            "properties": {
                "firstName": {
                    "type": "string"
                },
                "lastName": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "requests.CreateAPIKeyRequest": {
            "type": "object",
            "required": [
                "environmentId",
                "name"
            ],
            "properties": {
                "environmentId": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "requests.CreateEnvironmentRequest": {
            "type": "object",
            "required": [
                "color",
                "name",
                "slug"
            ],
            "properties": {
                "color": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "slug": {
                    "type": "string"
                }
            }
        },
        "requests.CreateGroupRequest": {
            "type": "object",
            "required": [
                "name",
                "slug",
                "userIds"
            ],
            "properties": {
                "name": {
                    "type": "string"
                },
                "slug": {
                    "type": "string"
                },
                "userIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "requests.CreateOrganizationRequest": {
            "type": "object",
            "required": [
                "subdomain"
            ],
            "properties": {
                "subdomain": {
                    "type": "string"
                }
            }
        },
        "requests.CreateUserInvitationsRequest": {
            "type": "object",
            "required": [
                "emails",
                "role"
            ],
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "role": {
                    "type": "string",
                    "enum": [
                        "admin",
                        "developer",
                        "member"
                    ]
                }
            }
        },
        "requests.RegisterWithInvitationMagicLinkRequest": {
            "type": "object",
            "required": [
                "firstName",
                "lastName",
                "token"
            ],
            "properties": {
                "firstName": {
                    "type": "string"
                },
                "lastName": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "requests.RegisterWithMagicLinkRequest": {
            "type": "object",
            "properties": {
                "firstName": {
                    "type": "string"
                },
                "lastName": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "requests.RequestMagicLinkRequest": {
            "type": "object",
            "required": [
                "email"
            ],
            "properties": {
                "email": {
                    "type": "string"
                }
            }
        },
        "requests.SaveAuthRequest": {
            "type": "object",
            "required": [
                "token"
            ],
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "requests.SendUpdateMeEmailInstructionsRequest": {
            "type": "object",
            "required": [
                "email",
                "emailConfirmation"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "emailConfirmation": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateAPIKeyRequest": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateEnvironmentRequest": {
            "type": "object",
            "required": [
                "color",
                "name"
            ],
            "properties": {
                "color": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateGroupRequest": {
            "type": "object",
            "required": [
                "name",
                "userIds"
            ],
            "properties": {
                "name": {
                    "type": "string"
                },
                "userIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "requests.UpdateMeEmailRequest": {
            "type": "object",
            "required": [
                "token"
            ],
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateMeRequest": {
            "type": "object",
            "properties": {
                "firstName": {
                    "type": "string"
                },
                "lastName": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateUserRequest": {
            "type": "object",
            "properties": {
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "role": {
                    "type": "string",
                    "enum": [
                        "admin",
                        "developer",
                        "member"
                    ]
                }
            }
        },
        "responses.APIKeyResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "environment": {
                    "$ref": "#/definitions/responses.EnvironmentResponse"
                },
                "id": {
                    "type": "string"
                },
                "key": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "responses.AuthenticateWithGoogleResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "hasMultipleOrganizations": {
                    "type": "boolean"
                },
                "hasOrganization": {
                    "type": "boolean"
                },
                "isNewUser": {
                    "type": "boolean"
                },
                "lastName": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "responses.AuthenticateWithInvitationMagicLinkResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                },
                "isNewUser": {
                    "type": "boolean"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "responses.AuthenticateWithMagicLinkResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                },
                "hasOrganization": {
                    "type": "boolean"
                },
                "isNewUser": {
                    "type": "boolean"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "responses.CreateAPIKeyResponse": {
            "type": "object",
            "properties": {
                "apiKey": {
                    "$ref": "#/definitions/responses.APIKeyResponse"
                }
            }
        },
        "responses.CreateEnvironmentResponse": {
            "type": "object",
            "properties": {
                "environment": {
                    "$ref": "#/definitions/responses.EnvironmentResponse"
                }
            }
        },
        "responses.CreateGroupResponse": {
            "type": "object",
            "properties": {
                "group": {
                    "$ref": "#/definitions/responses.GroupResponse"
                }
            }
        },
        "responses.CreateOrganizationResponse": {
            "type": "object",
            "properties": {
                "organization": {
                    "$ref": "#/definitions/responses.OrganizationResponse"
                }
            }
        },
        "responses.CreateUserInvitationsResponse": {
            "type": "object",
            "properties": {
                "userInvitations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserInvitationResponse"
                    }
                }
            }
        },
        "responses.DeleteAPIKeyResponse": {
            "type": "object",
            "properties": {
                "apiKey": {
                    "$ref": "#/definitions/responses.APIKeyResponse"
                }
            }
        },
        "responses.DeleteEnvironmentResponse": {
            "type": "object",
            "properties": {
                "environment": {
                    "$ref": "#/definitions/responses.EnvironmentResponse"
                }
            }
        },
        "responses.DeleteGroupResponse": {
            "type": "object",
            "properties": {
                "group": {
                    "$ref": "#/definitions/responses.GroupResponse"
                }
            }
        },
        "responses.EnvironmentResponse": {
            "type": "object",
            "properties": {
                "color": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "slug": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "responses.GetAPIKeyResponse": {
            "type": "object",
            "properties": {
                "apiKey": {
                    "$ref": "#/definitions/responses.APIKeyResponse"
                }
            }
        },
        "responses.GetEnvironmentResponse": {
            "type": "object",
            "properties": {
                "environment": {
                    "$ref": "#/definitions/responses.EnvironmentResponse"
                }
            }
        },
        "responses.GetGroupResponse": {
            "type": "object",
            "properties": {
                "group": {
                    "$ref": "#/definitions/responses.GroupResponse"
                }
            }
        },
        "responses.GetMeResponse": {
            "type": "object",
            "properties": {
                "user": {
                    "$ref": "#/definitions/responses.UserResponse"
                }
            }
        },
        "responses.GroupPageResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "groupId": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "pageId": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "responses.GroupResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "slug": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "responses.HostInstanceResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "sdkName": {
                    "type": "string"
                },
                "sdkVersion": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "responses.ListAPIKeysResponse": {
            "type": "object",
            "properties": {
                "devKey": {
                    "$ref": "#/definitions/responses.APIKeyResponse"
                },
                "liveKeys": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.APIKeyResponse"
                    }
                }
            }
        },
        "responses.ListEnvironmentsResponse": {
            "type": "object",
            "properties": {
                "environments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.EnvironmentResponse"
                    }
                }
            }
        },
        "responses.ListGroupsResponse": {
            "type": "object",
            "properties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.GroupResponse"
                    }
                },
                "userGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserGroupResponse"
                    }
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserResponse"
                    }
                }
            }
        },
        "responses.ListPagesResponse": {
            "type": "object",
            "properties": {
                "groupPages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.GroupPageResponse"
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.GroupResponse"
                    }
                },
                "pages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.PageResponse"
                    }
                },
                "userGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserGroupResponse"
                    }
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserResponse"
                    }
                }
            }
        },
        "responses.ListUsersResponse": {
            "type": "object",
            "properties": {
                "userInvitations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserInvitationResponse"
                    }
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserResponse"
                    }
                }
            }
        },
        "responses.ObtainAuthTokenResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "responses.OrganizationResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "subdomain": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                },
                "webSocketEndpoint": {
                    "type": "string"
                }
            }
        },
        "responses.PageResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "route": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "responses.PingHostInstanceResponse": {
            "type": "object",
            "properties": {
                "hostInstance": {
                    "$ref": "#/definitions/responses.HostInstanceResponse"
                }
            }
        },
        "responses.RefreshTokenResponse": {
            "type": "object",
            "properties": {
                "expiresAt": {
                    "type": "string"
                }
            }
        },
        "responses.RegisterWithGoogleResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                },
                "hasOrganization": {
                    "type": "boolean"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "responses.RegisterWithInvitationMagicLinkResponse": {
            "type": "object",
            "properties": {
                "expiresAt": {
                    "type": "string"
                }
            }
        },
        "responses.RegisterWithMagicLinkResponse": {
            "type": "object",
            "properties": {
                "expiresAt": {
                    "type": "string"
                },
                "hasOrganization": {
                    "type": "boolean"
                }
            }
        },
        "responses.RequestGoogleAuthLinkResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                }
            }
        },
        "responses.RequestInvitationGoogleAuthLinkResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                }
            }
        },
        "responses.RequestInvitationMagicLinkResponse": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                }
            }
        },
        "responses.RequestMagicLinkResponse": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "isNew": {
                    "type": "boolean"
                }
            }
        },
        "responses.ResendUserInvitationResponse": {
            "type": "object",
            "properties": {
                "userInvitation": {
                    "$ref": "#/definitions/responses.UserInvitationResponse"
                }
            }
        },
        "responses.SaveAuthResponse": {
            "type": "object",
            "properties": {
                "expiresAt": {
                    "type": "string"
                },
                "redirectUrl": {
                    "type": "string"
                }
            }
        },
        "responses.StatusResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "responses.UpdateAPIKeyResponse": {
            "type": "object",
            "properties": {
                "apiKey": {
                    "$ref": "#/definitions/responses.APIKeyResponse"
                }
            }
        },
        "responses.UpdateEnvironmentResponse": {
            "type": "object",
            "properties": {
                "environment": {
                    "$ref": "#/definitions/responses.EnvironmentResponse"
                }
            }
        },
        "responses.UpdateGroupResponse": {
            "type": "object",
            "properties": {
                "group": {
                    "$ref": "#/definitions/responses.GroupResponse"
                }
            }
        },
        "responses.UpdateMeEmailResponse": {
            "type": "object",
            "properties": {
                "user": {
                    "$ref": "#/definitions/responses.UserResponse"
                }
            }
        },
        "responses.UpdateMeResponse": {
            "type": "object",
            "properties": {
                "user": {
                    "$ref": "#/definitions/responses.UserResponse"
                }
            }
        },
        "responses.UpdateUserResponse": {
            "type": "object",
            "properties": {
                "user": {
                    "$ref": "#/definitions/responses.UserResponse"
                }
            }
        },
        "responses.UserGroupResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "groupId": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                },
                "userId": {
                    "type": "string"
                }
            }
        },
        "responses.UserInvitationResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                }
            }
        },
        "responses.UserResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "lastName": {
                    "type": "string"
                },
                "organization": {
                    "$ref": "#/definitions/responses.OrganizationResponse"
                },
                "role": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "https://api.trysourcetool.com",
	BasePath:         "/api/v1.",
	Schemes:          []string{},
	Title:            "Sourcetool API",
	Description:      "Sourcetool's API documentation",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}
</file>

<file path="docs/swagger.json">
{
    "swagger": "2.0",
    "info": {
        "description": "Sourcetool's API documentation",
        "title": "Sourcetool API",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {},
        "version": "1.0"
    },
    "host": "https://api.trysourcetool.com",
    "basePath": "/api/v1.",
    "paths": {
        "/apiKeys": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "apiKeys"
                ],
                "operationId": "list-apikeys",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ListAPIKeysResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "apiKeys"
                ],
                "operationId": "create-apikey",
                "parameters": [
                    {
                        "description": "API key creation data including name and expiration",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.CreateAPIKeyRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.CreateAPIKeyResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/apiKeys/{apiKeyID}": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "apiKeys"
                ],
                "operationId": "get-apikey",
                "parameters": [
                    {
                        "type": "string",
                        "description": "API Key ID",
                        "name": "apiKeyID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.GetAPIKeyResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "apiKeys"
                ],
                "operationId": "update-apikey",
                "parameters": [
                    {
                        "description": "API key update data including name and status",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateAPIKeyRequest"
                        }
                    },
                    {
                        "type": "string",
                        "description": "API Key ID to update",
                        "name": "apiKeyID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateAPIKeyResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "404": {
                        "description": "API key not found",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "delete": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "apiKeys"
                ],
                "operationId": "delete-apikey",
                "parameters": [
                    {
                        "type": "string",
                        "description": "API Key ID",
                        "name": "apiKeyID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.DeleteAPIKeyResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/google/authenticate": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "authenticate-with-google",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.AuthenticateWithGoogleResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/google/register": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "register-with-google",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RegisterWithGoogleResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/google/request": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "request-google-auth-link",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestGoogleAuthLinkResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/invitations/google/request": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "request-invitation-google-auth-link",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestInvitationGoogleAuthLinkResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/invitations/magic/authenticate": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "authenticate-with-invitation-magic-link",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.AuthenticateWithInvitationMagicLinkRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.AuthenticateWithInvitationMagicLinkResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/invitations/magic/register": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "register-with-invitation-magic-link",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.RegisterWithInvitationMagicLinkRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RegisterWithInvitationMagicLinkResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/invitations/magic/request": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "request-invitation-magic-link",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestInvitationMagicLinkResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "logout",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.StatusResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/magic/authenticate": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "authenticate-with-magic-link",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.AuthenticateWithMagicLinkRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.AuthenticateWithMagicLinkResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/magic/register": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "register-with-magic-link",
                "parameters": [
                    {
                        "description": "Registration data with magic link token",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.RegisterWithMagicLinkRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RegisterWithMagicLinkResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "401": {
                        "description": "Invalid or expired magic link token",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/magic/request": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "request-magic-link",
                "parameters": [
                    {
                        "description": "Email address for magic link",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.RequestMagicLinkRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestMagicLinkResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid email format",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "404": {
                        "description": "User not found",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/refresh": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "refresh-token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RefreshTokenResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/save": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "save-auth",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.SaveAuthRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.SaveAuthResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/auth/token/obtain": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "operationId": "obtain-auth-token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ObtainAuthTokenResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/environments": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "environments"
                ],
                "operationId": "list-environments",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ListEnvironmentsResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "environments"
                ],
                "operationId": "create-environment",
                "parameters": [
                    {
                        "description": "Environment creation data including name and configuration",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.CreateEnvironmentRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.CreateEnvironmentResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/environments/{environmentID}": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "environments"
                ],
                "operationId": "get-environment",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Environment ID",
                        "name": "environmentID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.GetEnvironmentResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "environments"
                ],
                "operationId": "update-environment",
                "parameters": [
                    {
                        "description": "Environment update data including name and configuration",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateEnvironmentRequest"
                        }
                    },
                    {
                        "type": "string",
                        "description": "Environment ID to update",
                        "name": "environmentID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateEnvironmentResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "404": {
                        "description": "Environment not found",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "delete": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "environments"
                ],
                "operationId": "delete-environment",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Environment ID",
                        "name": "environmentID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.DeleteEnvironmentResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/groups": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "operationId": "list-groups",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ListGroupsResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "operationId": "create-group",
                "parameters": [
                    {
                        "description": "Group creation data including name and members",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.CreateGroupRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.CreateGroupResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/groups/{groupID}": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "operationId": "get-group",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Group ID",
                        "name": "groupID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.GetGroupResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "operationId": "update-group",
                "parameters": [
                    {
                        "description": "Group update data including name and members",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateGroupRequest"
                        }
                    },
                    {
                        "type": "string",
                        "description": "Group ID to update",
                        "name": "groupID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateGroupResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "403": {
                        "description": "Insufficient permissions",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "404": {
                        "description": "Group not found",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "delete": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "operationId": "delete-group",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Group ID",
                        "name": "groupID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.DeleteGroupResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/hostInstances/ping": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "hostInstances"
                ],
                "operationId": "ping-host-instance",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Page ID",
                        "name": "pageId",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.PingHostInstanceResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/organizations": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "organizations"
                ],
                "operationId": "create-organization",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.CreateOrganizationRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.CreateOrganizationResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/organizations/checkSubdomainAvailability": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "organizations"
                ],
                "operationId": "check-organization-subdomain-availability",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Subdomain to check for availability",
                        "name": "subdomain",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.StatusResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid subdomain format",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "409": {
                        "description": "Subdomain already exists",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/pages": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "pages"
                ],
                "operationId": "list-pages",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Environment ID",
                        "name": "environmentId",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ListPagesResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "list-users",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ListUsersResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users/invitations": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "create-user-invitations",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.CreateUserInvitationsRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.CreateUserInvitationsResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users/invitations/{invitationID}/resend": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "resend-user-invitation",
                "parameters": [
                    {
                        "type": "string",
                        "description": " ",
                        "name": "invitationID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ResendUserInvitationResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users/me": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "get-me",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.GetMeResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "update-me",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateMeRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateMeResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users/me/email": {
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "update-me-email",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateMeEmailRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateMeEmailResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users/me/email/instructions": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "send-update-me-email-instructions",
                "parameters": [
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.SendUpdateMeEmailInstructionsRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.StatusResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        },
        "/users/{userID}": {
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "update-user",
                "parameters": [
                    {
                        "type": "string",
                        "description": " ",
                        "name": "userID",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": " ",
                        "name": "Body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateUserRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateUserResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            },
            "delete": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "operationId": "delete-user",
                "parameters": [
                    {
                        "type": "string",
                        "description": " ",
                        "name": "userID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.StatusResponse"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/errdefs.Error"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "errdefs.Error": {
            "type": "object",
            "properties": {
                "detail": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {}
                },
                "status": {
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "requests.AuthenticateWithInvitationMagicLinkRequest": {
            "type": "object",
            "required": [
                "token"
            ],
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "requests.AuthenticateWithMagicLinkRequest": {
            "type": "object",
            "required": [
                "token"
            ],
            "properties": {
                "firstName": {
                    "type": "string"
                },
                "lastName": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "requests.CreateAPIKeyRequest": {
            "type": "object",
            "required": [
                "environmentId",
                "name"
            ],
            "properties": {
                "environmentId": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "requests.CreateEnvironmentRequest": {
            "type": "object",
            "required": [
                "color",
                "name",
                "slug"
            ],
            "properties": {
                "color": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "slug": {
                    "type": "string"
                }
            }
        },
        "requests.CreateGroupRequest": {
            "type": "object",
            "required": [
                "name",
                "slug",
                "userIds"
            ],
            "properties": {
                "name": {
                    "type": "string"
                },
                "slug": {
                    "type": "string"
                },
                "userIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "requests.CreateOrganizationRequest": {
            "type": "object",
            "required": [
                "subdomain"
            ],
            "properties": {
                "subdomain": {
                    "type": "string"
                }
            }
        },
        "requests.CreateUserInvitationsRequest": {
            "type": "object",
            "required": [
                "emails",
                "role"
            ],
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "role": {
                    "type": "string",
                    "enum": [
                        "admin",
                        "developer",
                        "member"
                    ]
                }
            }
        },
        "requests.RegisterWithInvitationMagicLinkRequest": {
            "type": "object",
            "required": [
                "firstName",
                "lastName",
                "token"
            ],
            "properties": {
                "firstName": {
                    "type": "string"
                },
                "lastName": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "requests.RegisterWithMagicLinkRequest": {
            "type": "object",
            "properties": {
                "firstName": {
                    "type": "string"
                },
                "lastName": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "requests.RequestMagicLinkRequest": {
            "type": "object",
            "required": [
                "email"
            ],
            "properties": {
                "email": {
                    "type": "string"
                }
            }
        },
        "requests.SaveAuthRequest": {
            "type": "object",
            "required": [
                "token"
            ],
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "requests.SendUpdateMeEmailInstructionsRequest": {
            "type": "object",
            "required": [
                "email",
                "emailConfirmation"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "emailConfirmation": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateAPIKeyRequest": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateEnvironmentRequest": {
            "type": "object",
            "required": [
                "color",
                "name"
            ],
            "properties": {
                "color": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateGroupRequest": {
            "type": "object",
            "required": [
                "name",
                "userIds"
            ],
            "properties": {
                "name": {
                    "type": "string"
                },
                "userIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "requests.UpdateMeEmailRequest": {
            "type": "object",
            "required": [
                "token"
            ],
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateMeRequest": {
            "type": "object",
            "properties": {
                "firstName": {
                    "type": "string"
                },
                "lastName": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateUserRequest": {
            "type": "object",
            "properties": {
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "role": {
                    "type": "string",
                    "enum": [
                        "admin",
                        "developer",
                        "member"
                    ]
                }
            }
        },
        "responses.APIKeyResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "environment": {
                    "$ref": "#/definitions/responses.EnvironmentResponse"
                },
                "id": {
                    "type": "string"
                },
                "key": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "responses.AuthenticateWithGoogleResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "hasMultipleOrganizations": {
                    "type": "boolean"
                },
                "hasOrganization": {
                    "type": "boolean"
                },
                "isNewUser": {
                    "type": "boolean"
                },
                "lastName": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "responses.AuthenticateWithInvitationMagicLinkResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                },
                "isNewUser": {
                    "type": "boolean"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "responses.AuthenticateWithMagicLinkResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                },
                "hasOrganization": {
                    "type": "boolean"
                },
                "isNewUser": {
                    "type": "boolean"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "responses.CreateAPIKeyResponse": {
            "type": "object",
            "properties": {
                "apiKey": {
                    "$ref": "#/definitions/responses.APIKeyResponse"
                }
            }
        },
        "responses.CreateEnvironmentResponse": {
            "type": "object",
            "properties": {
                "environment": {
                    "$ref": "#/definitions/responses.EnvironmentResponse"
                }
            }
        },
        "responses.CreateGroupResponse": {
            "type": "object",
            "properties": {
                "group": {
                    "$ref": "#/definitions/responses.GroupResponse"
                }
            }
        },
        "responses.CreateOrganizationResponse": {
            "type": "object",
            "properties": {
                "organization": {
                    "$ref": "#/definitions/responses.OrganizationResponse"
                }
            }
        },
        "responses.CreateUserInvitationsResponse": {
            "type": "object",
            "properties": {
                "userInvitations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserInvitationResponse"
                    }
                }
            }
        },
        "responses.DeleteAPIKeyResponse": {
            "type": "object",
            "properties": {
                "apiKey": {
                    "$ref": "#/definitions/responses.APIKeyResponse"
                }
            }
        },
        "responses.DeleteEnvironmentResponse": {
            "type": "object",
            "properties": {
                "environment": {
                    "$ref": "#/definitions/responses.EnvironmentResponse"
                }
            }
        },
        "responses.DeleteGroupResponse": {
            "type": "object",
            "properties": {
                "group": {
                    "$ref": "#/definitions/responses.GroupResponse"
                }
            }
        },
        "responses.EnvironmentResponse": {
            "type": "object",
            "properties": {
                "color": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "slug": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "responses.GetAPIKeyResponse": {
            "type": "object",
            "properties": {
                "apiKey": {
                    "$ref": "#/definitions/responses.APIKeyResponse"
                }
            }
        },
        "responses.GetEnvironmentResponse": {
            "type": "object",
            "properties": {
                "environment": {
                    "$ref": "#/definitions/responses.EnvironmentResponse"
                }
            }
        },
        "responses.GetGroupResponse": {
            "type": "object",
            "properties": {
                "group": {
                    "$ref": "#/definitions/responses.GroupResponse"
                }
            }
        },
        "responses.GetMeResponse": {
            "type": "object",
            "properties": {
                "user": {
                    "$ref": "#/definitions/responses.UserResponse"
                }
            }
        },
        "responses.GroupPageResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "groupId": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "pageId": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "responses.GroupResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "slug": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "responses.HostInstanceResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "sdkName": {
                    "type": "string"
                },
                "sdkVersion": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "responses.ListAPIKeysResponse": {
            "type": "object",
            "properties": {
                "devKey": {
                    "$ref": "#/definitions/responses.APIKeyResponse"
                },
                "liveKeys": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.APIKeyResponse"
                    }
                }
            }
        },
        "responses.ListEnvironmentsResponse": {
            "type": "object",
            "properties": {
                "environments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.EnvironmentResponse"
                    }
                }
            }
        },
        "responses.ListGroupsResponse": {
            "type": "object",
            "properties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.GroupResponse"
                    }
                },
                "userGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserGroupResponse"
                    }
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserResponse"
                    }
                }
            }
        },
        "responses.ListPagesResponse": {
            "type": "object",
            "properties": {
                "groupPages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.GroupPageResponse"
                    }
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.GroupResponse"
                    }
                },
                "pages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.PageResponse"
                    }
                },
                "userGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserGroupResponse"
                    }
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserResponse"
                    }
                }
            }
        },
        "responses.ListUsersResponse": {
            "type": "object",
            "properties": {
                "userInvitations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserInvitationResponse"
                    }
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.UserResponse"
                    }
                }
            }
        },
        "responses.ObtainAuthTokenResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "responses.OrganizationResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "subdomain": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                },
                "webSocketEndpoint": {
                    "type": "string"
                }
            }
        },
        "responses.PageResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "route": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "responses.PingHostInstanceResponse": {
            "type": "object",
            "properties": {
                "hostInstance": {
                    "$ref": "#/definitions/responses.HostInstanceResponse"
                }
            }
        },
        "responses.RefreshTokenResponse": {
            "type": "object",
            "properties": {
                "expiresAt": {
                    "type": "string"
                }
            }
        },
        "responses.RegisterWithGoogleResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                },
                "hasOrganization": {
                    "type": "boolean"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "responses.RegisterWithInvitationMagicLinkResponse": {
            "type": "object",
            "properties": {
                "expiresAt": {
                    "type": "string"
                }
            }
        },
        "responses.RegisterWithMagicLinkResponse": {
            "type": "object",
            "properties": {
                "expiresAt": {
                    "type": "string"
                },
                "hasOrganization": {
                    "type": "boolean"
                }
            }
        },
        "responses.RequestGoogleAuthLinkResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                }
            }
        },
        "responses.RequestInvitationGoogleAuthLinkResponse": {
            "type": "object",
            "properties": {
                "authUrl": {
                    "type": "string"
                }
            }
        },
        "responses.RequestInvitationMagicLinkResponse": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                }
            }
        },
        "responses.RequestMagicLinkResponse": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "isNew": {
                    "type": "boolean"
                }
            }
        },
        "responses.ResendUserInvitationResponse": {
            "type": "object",
            "properties": {
                "userInvitation": {
                    "$ref": "#/definitions/responses.UserInvitationResponse"
                }
            }
        },
        "responses.SaveAuthResponse": {
            "type": "object",
            "properties": {
                "expiresAt": {
                    "type": "string"
                },
                "redirectUrl": {
                    "type": "string"
                }
            }
        },
        "responses.StatusResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "responses.UpdateAPIKeyResponse": {
            "type": "object",
            "properties": {
                "apiKey": {
                    "$ref": "#/definitions/responses.APIKeyResponse"
                }
            }
        },
        "responses.UpdateEnvironmentResponse": {
            "type": "object",
            "properties": {
                "environment": {
                    "$ref": "#/definitions/responses.EnvironmentResponse"
                }
            }
        },
        "responses.UpdateGroupResponse": {
            "type": "object",
            "properties": {
                "group": {
                    "$ref": "#/definitions/responses.GroupResponse"
                }
            }
        },
        "responses.UpdateMeEmailResponse": {
            "type": "object",
            "properties": {
                "user": {
                    "$ref": "#/definitions/responses.UserResponse"
                }
            }
        },
        "responses.UpdateMeResponse": {
            "type": "object",
            "properties": {
                "user": {
                    "$ref": "#/definitions/responses.UserResponse"
                }
            }
        },
        "responses.UpdateUserResponse": {
            "type": "object",
            "properties": {
                "user": {
                    "$ref": "#/definitions/responses.UserResponse"
                }
            }
        },
        "responses.UserGroupResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "groupId": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                },
                "userId": {
                    "type": "string"
                }
            }
        },
        "responses.UserInvitationResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                }
            }
        },
        "responses.UserResponse": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "lastName": {
                    "type": "string"
                },
                "organization": {
                    "$ref": "#/definitions/responses.OrganizationResponse"
                },
                "role": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        }
    }
}
</file>

<file path="docs/swagger.yaml">
basePath: /api/v1.
definitions:
  errdefs.Error:
    properties:
      detail:
        type: string
      id:
        type: string
      meta:
        additionalProperties: {}
        type: object
      status:
        type: integer
      title:
        type: string
    type: object
  requests.AuthenticateWithInvitationMagicLinkRequest:
    properties:
      token:
        type: string
    required:
    - token
    type: object
  requests.AuthenticateWithMagicLinkRequest:
    properties:
      firstName:
        type: string
      lastName:
        type: string
      token:
        type: string
    required:
    - token
    type: object
  requests.CreateAPIKeyRequest:
    properties:
      environmentId:
        type: string
      name:
        type: string
    required:
    - environmentId
    - name
    type: object
  requests.CreateEnvironmentRequest:
    properties:
      color:
        type: string
      name:
        type: string
      slug:
        type: string
    required:
    - color
    - name
    - slug
    type: object
  requests.CreateGroupRequest:
    properties:
      name:
        type: string
      slug:
        type: string
      userIds:
        items:
          type: string
        type: array
    required:
    - name
    - slug
    - userIds
    type: object
  requests.CreateOrganizationRequest:
    properties:
      subdomain:
        type: string
    required:
    - subdomain
    type: object
  requests.CreateUserInvitationsRequest:
    properties:
      emails:
        items:
          type: string
        type: array
      role:
        enum:
        - admin
        - developer
        - member
        type: string
    required:
    - emails
    - role
    type: object
  requests.RegisterWithInvitationMagicLinkRequest:
    properties:
      firstName:
        type: string
      lastName:
        type: string
      token:
        type: string
    required:
    - firstName
    - lastName
    - token
    type: object
  requests.RegisterWithMagicLinkRequest:
    properties:
      firstName:
        type: string
      lastName:
        type: string
      token:
        type: string
    type: object
  requests.RequestMagicLinkRequest:
    properties:
      email:
        type: string
    required:
    - email
    type: object
  requests.SaveAuthRequest:
    properties:
      token:
        type: string
    required:
    - token
    type: object
  requests.SendUpdateMeEmailInstructionsRequest:
    properties:
      email:
        type: string
      emailConfirmation:
        type: string
    required:
    - email
    - emailConfirmation
    type: object
  requests.UpdateAPIKeyRequest:
    properties:
      name:
        type: string
    type: object
  requests.UpdateEnvironmentRequest:
    properties:
      color:
        type: string
      name:
        type: string
    required:
    - color
    - name
    type: object
  requests.UpdateGroupRequest:
    properties:
      name:
        type: string
      userIds:
        items:
          type: string
        type: array
    required:
    - name
    - userIds
    type: object
  requests.UpdateMeEmailRequest:
    properties:
      token:
        type: string
    required:
    - token
    type: object
  requests.UpdateMeRequest:
    properties:
      firstName:
        type: string
      lastName:
        type: string
    type: object
  requests.UpdateUserRequest:
    properties:
      groupIds:
        items:
          type: string
        type: array
      role:
        enum:
        - admin
        - developer
        - member
        type: string
    type: object
  responses.APIKeyResponse:
    properties:
      createdAt:
        type: string
      environment:
        $ref: '#/definitions/responses.EnvironmentResponse'
      id:
        type: string
      key:
        type: string
      name:
        type: string
      updatedAt:
        type: string
    type: object
  responses.AuthenticateWithGoogleResponse:
    properties:
      authUrl:
        type: string
      firstName:
        type: string
      hasMultipleOrganizations:
        type: boolean
      hasOrganization:
        type: boolean
      isNewUser:
        type: boolean
      lastName:
        type: string
      token:
        type: string
    type: object
  responses.AuthenticateWithInvitationMagicLinkResponse:
    properties:
      authUrl:
        type: string
      isNewUser:
        type: boolean
      token:
        type: string
    type: object
  responses.AuthenticateWithMagicLinkResponse:
    properties:
      authUrl:
        type: string
      hasOrganization:
        type: boolean
      isNewUser:
        type: boolean
      token:
        type: string
    type: object
  responses.CreateAPIKeyResponse:
    properties:
      apiKey:
        $ref: '#/definitions/responses.APIKeyResponse'
    type: object
  responses.CreateEnvironmentResponse:
    properties:
      environment:
        $ref: '#/definitions/responses.EnvironmentResponse'
    type: object
  responses.CreateGroupResponse:
    properties:
      group:
        $ref: '#/definitions/responses.GroupResponse'
    type: object
  responses.CreateOrganizationResponse:
    properties:
      organization:
        $ref: '#/definitions/responses.OrganizationResponse'
    type: object
  responses.CreateUserInvitationsResponse:
    properties:
      userInvitations:
        items:
          $ref: '#/definitions/responses.UserInvitationResponse'
        type: array
    type: object
  responses.DeleteAPIKeyResponse:
    properties:
      apiKey:
        $ref: '#/definitions/responses.APIKeyResponse'
    type: object
  responses.DeleteEnvironmentResponse:
    properties:
      environment:
        $ref: '#/definitions/responses.EnvironmentResponse'
    type: object
  responses.DeleteGroupResponse:
    properties:
      group:
        $ref: '#/definitions/responses.GroupResponse'
    type: object
  responses.EnvironmentResponse:
    properties:
      color:
        type: string
      createdAt:
        type: string
      id:
        type: string
      name:
        type: string
      slug:
        type: string
      updatedAt:
        type: string
    type: object
  responses.GetAPIKeyResponse:
    properties:
      apiKey:
        $ref: '#/definitions/responses.APIKeyResponse'
    type: object
  responses.GetEnvironmentResponse:
    properties:
      environment:
        $ref: '#/definitions/responses.EnvironmentResponse'
    type: object
  responses.GetGroupResponse:
    properties:
      group:
        $ref: '#/definitions/responses.GroupResponse'
    type: object
  responses.GetMeResponse:
    properties:
      user:
        $ref: '#/definitions/responses.UserResponse'
    type: object
  responses.GroupPageResponse:
    properties:
      createdAt:
        type: string
      groupId:
        type: string
      id:
        type: string
      pageId:
        type: string
      updatedAt:
        type: string
    type: object
  responses.GroupResponse:
    properties:
      createdAt:
        type: string
      id:
        type: string
      name:
        type: string
      slug:
        type: string
      updatedAt:
        type: string
    type: object
  responses.HostInstanceResponse:
    properties:
      createdAt:
        type: string
      id:
        type: string
      sdkName:
        type: string
      sdkVersion:
        type: string
      status:
        type: string
      updatedAt:
        type: string
    type: object
  responses.ListAPIKeysResponse:
    properties:
      devKey:
        $ref: '#/definitions/responses.APIKeyResponse'
      liveKeys:
        items:
          $ref: '#/definitions/responses.APIKeyResponse'
        type: array
    type: object
  responses.ListEnvironmentsResponse:
    properties:
      environments:
        items:
          $ref: '#/definitions/responses.EnvironmentResponse'
        type: array
    type: object
  responses.ListGroupsResponse:
    properties:
      groups:
        items:
          $ref: '#/definitions/responses.GroupResponse'
        type: array
      userGroups:
        items:
          $ref: '#/definitions/responses.UserGroupResponse'
        type: array
      users:
        items:
          $ref: '#/definitions/responses.UserResponse'
        type: array
    type: object
  responses.ListPagesResponse:
    properties:
      groupPages:
        items:
          $ref: '#/definitions/responses.GroupPageResponse'
        type: array
      groups:
        items:
          $ref: '#/definitions/responses.GroupResponse'
        type: array
      pages:
        items:
          $ref: '#/definitions/responses.PageResponse'
        type: array
      userGroups:
        items:
          $ref: '#/definitions/responses.UserGroupResponse'
        type: array
      users:
        items:
          $ref: '#/definitions/responses.UserResponse'
        type: array
    type: object
  responses.ListUsersResponse:
    properties:
      userInvitations:
        items:
          $ref: '#/definitions/responses.UserInvitationResponse'
        type: array
      users:
        items:
          $ref: '#/definitions/responses.UserResponse'
        type: array
    type: object
  responses.ObtainAuthTokenResponse:
    properties:
      authUrl:
        type: string
      token:
        type: string
    type: object
  responses.OrganizationResponse:
    properties:
      createdAt:
        type: string
      id:
        type: string
      subdomain:
        type: string
      updatedAt:
        type: string
      webSocketEndpoint:
        type: string
    type: object
  responses.PageResponse:
    properties:
      createdAt:
        type: string
      id:
        type: string
      name:
        type: string
      route:
        type: string
      updatedAt:
        type: string
    type: object
  responses.PingHostInstanceResponse:
    properties:
      hostInstance:
        $ref: '#/definitions/responses.HostInstanceResponse'
    type: object
  responses.RefreshTokenResponse:
    properties:
      expiresAt:
        type: string
    type: object
  responses.RegisterWithGoogleResponse:
    properties:
      authUrl:
        type: string
      hasOrganization:
        type: boolean
      token:
        type: string
    type: object
  responses.RegisterWithInvitationMagicLinkResponse:
    properties:
      expiresAt:
        type: string
    type: object
  responses.RegisterWithMagicLinkResponse:
    properties:
      expiresAt:
        type: string
      hasOrganization:
        type: boolean
    type: object
  responses.RequestGoogleAuthLinkResponse:
    properties:
      authUrl:
        type: string
    type: object
  responses.RequestInvitationGoogleAuthLinkResponse:
    properties:
      authUrl:
        type: string
    type: object
  responses.RequestInvitationMagicLinkResponse:
    properties:
      email:
        type: string
    type: object
  responses.RequestMagicLinkResponse:
    properties:
      email:
        type: string
      isNew:
        type: boolean
    type: object
  responses.ResendUserInvitationResponse:
    properties:
      userInvitation:
        $ref: '#/definitions/responses.UserInvitationResponse'
    type: object
  responses.SaveAuthResponse:
    properties:
      expiresAt:
        type: string
      redirectUrl:
        type: string
    type: object
  responses.StatusResponse:
    properties:
      code:
        type: integer
      message:
        type: string
    type: object
  responses.UpdateAPIKeyResponse:
    properties:
      apiKey:
        $ref: '#/definitions/responses.APIKeyResponse'
    type: object
  responses.UpdateEnvironmentResponse:
    properties:
      environment:
        $ref: '#/definitions/responses.EnvironmentResponse'
    type: object
  responses.UpdateGroupResponse:
    properties:
      group:
        $ref: '#/definitions/responses.GroupResponse'
    type: object
  responses.UpdateMeEmailResponse:
    properties:
      user:
        $ref: '#/definitions/responses.UserResponse'
    type: object
  responses.UpdateMeResponse:
    properties:
      user:
        $ref: '#/definitions/responses.UserResponse'
    type: object
  responses.UpdateUserResponse:
    properties:
      user:
        $ref: '#/definitions/responses.UserResponse'
    type: object
  responses.UserGroupResponse:
    properties:
      createdAt:
        type: string
      groupId:
        type: string
      id:
        type: string
      updatedAt:
        type: string
      userId:
        type: string
    type: object
  responses.UserInvitationResponse:
    properties:
      createdAt:
        type: string
      email:
        type: string
      id:
        type: string
    type: object
  responses.UserResponse:
    properties:
      createdAt:
        type: string
      email:
        type: string
      firstName:
        type: string
      id:
        type: string
      lastName:
        type: string
      organization:
        $ref: '#/definitions/responses.OrganizationResponse'
      role:
        type: string
      updatedAt:
        type: string
    type: object
host: https://api.trysourcetool.com
info:
  contact: {}
  description: Sourcetool's API documentation
  termsOfService: http://swagger.io/terms/
  title: Sourcetool API
  version: "1.0"
paths:
  /apiKeys:
    get:
      consumes:
      - application/json
      operationId: list-apikeys
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.ListAPIKeysResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - apiKeys
    post:
      consumes:
      - application/json
      operationId: create-apikey
      parameters:
      - description: API key creation data including name and expiration
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.CreateAPIKeyRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.CreateAPIKeyResponse'
        "400":
          description: Invalid request parameters
          schema:
            $ref: '#/definitions/errdefs.Error'
        "403":
          description: Insufficient permissions
          schema:
            $ref: '#/definitions/errdefs.Error'
        "500":
          description: Internal server error
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - apiKeys
  /apiKeys/{apiKeyID}:
    delete:
      consumes:
      - application/json
      operationId: delete-apikey
      parameters:
      - description: API Key ID
        in: path
        name: apiKeyID
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.DeleteAPIKeyResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - apiKeys
    get:
      consumes:
      - application/json
      operationId: get-apikey
      parameters:
      - description: API Key ID
        in: path
        name: apiKeyID
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.GetAPIKeyResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - apiKeys
    put:
      consumes:
      - application/json
      operationId: update-apikey
      parameters:
      - description: API key update data including name and status
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.UpdateAPIKeyRequest'
      - description: API Key ID to update
        in: path
        name: apiKeyID
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.UpdateAPIKeyResponse'
        "400":
          description: Invalid request parameters
          schema:
            $ref: '#/definitions/errdefs.Error'
        "403":
          description: Insufficient permissions
          schema:
            $ref: '#/definitions/errdefs.Error'
        "404":
          description: API key not found
          schema:
            $ref: '#/definitions/errdefs.Error'
        "500":
          description: Internal server error
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - apiKeys
  /auth/google/authenticate:
    post:
      consumes:
      - application/json
      operationId: authenticate-with-google
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.AuthenticateWithGoogleResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/google/register:
    post:
      consumes:
      - application/json
      operationId: register-with-google
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.RegisterWithGoogleResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/google/request:
    post:
      consumes:
      - application/json
      operationId: request-google-auth-link
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.RequestGoogleAuthLinkResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/invitations/google/request:
    post:
      consumes:
      - application/json
      operationId: request-invitation-google-auth-link
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.RequestInvitationGoogleAuthLinkResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/invitations/magic/authenticate:
    post:
      consumes:
      - application/json
      operationId: authenticate-with-invitation-magic-link
      parameters:
      - description: ' '
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.AuthenticateWithInvitationMagicLinkRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.AuthenticateWithInvitationMagicLinkResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/invitations/magic/register:
    post:
      consumes:
      - application/json
      operationId: register-with-invitation-magic-link
      parameters:
      - description: ' '
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.RegisterWithInvitationMagicLinkRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.RegisterWithInvitationMagicLinkResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/invitations/magic/request:
    post:
      consumes:
      - application/json
      operationId: request-invitation-magic-link
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.RequestInvitationMagicLinkResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/logout:
    post:
      consumes:
      - application/json
      operationId: logout
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.StatusResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/magic/authenticate:
    post:
      consumes:
      - application/json
      operationId: authenticate-with-magic-link
      parameters:
      - description: ' '
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.AuthenticateWithMagicLinkRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.AuthenticateWithMagicLinkResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/magic/register:
    post:
      consumes:
      - application/json
      operationId: register-with-magic-link
      parameters:
      - description: Registration data with magic link token
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.RegisterWithMagicLinkRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.RegisterWithMagicLinkResponse'
        "400":
          description: Invalid request parameters
          schema:
            $ref: '#/definitions/errdefs.Error'
        "401":
          description: Invalid or expired magic link token
          schema:
            $ref: '#/definitions/errdefs.Error'
        "500":
          description: Internal server error
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/magic/request:
    post:
      consumes:
      - application/json
      operationId: request-magic-link
      parameters:
      - description: Email address for magic link
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.RequestMagicLinkRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.RequestMagicLinkResponse'
        "400":
          description: Invalid email format
          schema:
            $ref: '#/definitions/errdefs.Error'
        "404":
          description: User not found
          schema:
            $ref: '#/definitions/errdefs.Error'
        "500":
          description: Internal server error
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/refresh:
    post:
      consumes:
      - application/json
      operationId: refresh-token
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.RefreshTokenResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/save:
    post:
      consumes:
      - application/json
      operationId: save-auth
      parameters:
      - description: ' '
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.SaveAuthRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.SaveAuthResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /auth/token/obtain:
    post:
      consumes:
      - application/json
      operationId: obtain-auth-token
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.ObtainAuthTokenResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - auth
  /environments:
    get:
      consumes:
      - application/json
      operationId: list-environments
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.ListEnvironmentsResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - environments
    post:
      consumes:
      - application/json
      operationId: create-environment
      parameters:
      - description: Environment creation data including name and configuration
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.CreateEnvironmentRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.CreateEnvironmentResponse'
        "400":
          description: Invalid request parameters
          schema:
            $ref: '#/definitions/errdefs.Error'
        "403":
          description: Insufficient permissions
          schema:
            $ref: '#/definitions/errdefs.Error'
        "500":
          description: Internal server error
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - environments
  /environments/{environmentID}:
    delete:
      consumes:
      - application/json
      operationId: delete-environment
      parameters:
      - description: Environment ID
        in: path
        name: environmentID
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.DeleteEnvironmentResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - environments
    get:
      consumes:
      - application/json
      operationId: get-environment
      parameters:
      - description: Environment ID
        in: path
        name: environmentID
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.GetEnvironmentResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - environments
    put:
      consumes:
      - application/json
      operationId: update-environment
      parameters:
      - description: Environment update data including name and configuration
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.UpdateEnvironmentRequest'
      - description: Environment ID to update
        in: path
        name: environmentID
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.UpdateEnvironmentResponse'
        "400":
          description: Invalid request parameters
          schema:
            $ref: '#/definitions/errdefs.Error'
        "403":
          description: Insufficient permissions
          schema:
            $ref: '#/definitions/errdefs.Error'
        "404":
          description: Environment not found
          schema:
            $ref: '#/definitions/errdefs.Error'
        "500":
          description: Internal server error
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - environments
  /groups:
    get:
      consumes:
      - application/json
      operationId: list-groups
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.ListGroupsResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - groups
    post:
      consumes:
      - application/json
      operationId: create-group
      parameters:
      - description: Group creation data including name and members
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.CreateGroupRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.CreateGroupResponse'
        "400":
          description: Invalid request parameters
          schema:
            $ref: '#/definitions/errdefs.Error'
        "403":
          description: Insufficient permissions
          schema:
            $ref: '#/definitions/errdefs.Error'
        "500":
          description: Internal server error
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - groups
  /groups/{groupID}:
    delete:
      consumes:
      - application/json
      operationId: delete-group
      parameters:
      - description: Group ID
        in: path
        name: groupID
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.DeleteGroupResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - groups
    get:
      consumes:
      - application/json
      operationId: get-group
      parameters:
      - description: Group ID
        in: path
        name: groupID
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.GetGroupResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - groups
    put:
      consumes:
      - application/json
      operationId: update-group
      parameters:
      - description: Group update data including name and members
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.UpdateGroupRequest'
      - description: Group ID to update
        in: path
        name: groupID
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.UpdateGroupResponse'
        "400":
          description: Invalid request parameters
          schema:
            $ref: '#/definitions/errdefs.Error'
        "403":
          description: Insufficient permissions
          schema:
            $ref: '#/definitions/errdefs.Error'
        "404":
          description: Group not found
          schema:
            $ref: '#/definitions/errdefs.Error'
        "500":
          description: Internal server error
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - groups
  /hostInstances/ping:
    get:
      consumes:
      - application/json
      operationId: ping-host-instance
      parameters:
      - description: Page ID
        in: query
        name: pageId
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.PingHostInstanceResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - hostInstances
  /organizations:
    post:
      consumes:
      - application/json
      operationId: create-organization
      parameters:
      - description: ' '
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.CreateOrganizationRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.CreateOrganizationResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - organizations
  /organizations/checkSubdomainAvailability:
    get:
      consumes:
      - application/json
      operationId: check-organization-subdomain-availability
      parameters:
      - description: Subdomain to check for availability
        in: query
        name: subdomain
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.StatusResponse'
        "400":
          description: Invalid subdomain format
          schema:
            $ref: '#/definitions/errdefs.Error'
        "409":
          description: Subdomain already exists
          schema:
            $ref: '#/definitions/errdefs.Error'
        "500":
          description: Internal server error
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - organizations
  /pages:
    get:
      consumes:
      - application/json
      operationId: list-pages
      parameters:
      - description: Environment ID
        in: query
        name: environmentId
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.ListPagesResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - pages
  /users:
    get:
      consumes:
      - application/json
      operationId: list-users
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.ListUsersResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - users
  /users/{userID}:
    delete:
      consumes:
      - application/json
      operationId: delete-user
      parameters:
      - description: ' '
        in: path
        name: userID
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.StatusResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - users
    put:
      consumes:
      - application/json
      operationId: update-user
      parameters:
      - description: ' '
        in: path
        name: userID
        required: true
        type: string
      - description: ' '
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.UpdateUserRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.UpdateUserResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - users
  /users/invitations:
    post:
      consumes:
      - application/json
      operationId: create-user-invitations
      parameters:
      - description: ' '
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.CreateUserInvitationsRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.CreateUserInvitationsResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - users
  /users/invitations/{invitationID}/resend:
    post:
      consumes:
      - application/json
      operationId: resend-user-invitation
      parameters:
      - description: ' '
        in: path
        name: invitationID
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.ResendUserInvitationResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - users
  /users/me:
    get:
      consumes:
      - application/json
      operationId: get-me
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.GetMeResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - users
    put:
      consumes:
      - application/json
      operationId: update-me
      parameters:
      - description: ' '
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.UpdateMeRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.UpdateMeResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - users
  /users/me/email:
    put:
      consumes:
      - application/json
      operationId: update-me-email
      parameters:
      - description: ' '
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.UpdateMeEmailRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.UpdateMeEmailResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - users
  /users/me/email/instructions:
    post:
      consumes:
      - application/json
      operationId: send-update-me-email-instructions
      parameters:
      - description: ' '
        in: body
        name: Body
        required: true
        schema:
          $ref: '#/definitions/requests.SendUpdateMeEmailInstructionsRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/responses.StatusResponse'
        default:
          description: ""
          schema:
            $ref: '#/definitions/errdefs.Error'
      tags:
      - users
swagger: "2.0"
</file>

<file path="ee/cmd/server/main.go">
package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	_ "github.com/lib/pq"
	"go.uber.org/zap"
	"golang.org/x/sync/errgroup"

	"github.com/trysourcetool/sourcetool/backend/config"
	_ "github.com/trysourcetool/sourcetool/backend/docs"
	ee_postgres "github.com/trysourcetool/sourcetool/backend/ee/internal/infra/postgres"
	ee_transport "github.com/trysourcetool/sourcetool/backend/ee/internal/transport"
	"github.com/trysourcetool/sourcetool/backend/fixtures"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/redis"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/smtp"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/wsmanager"
	"github.com/trysourcetool/sourcetool/backend/logger"
)

func init() {
	config.Init()
	logger.Init()
}

func main() {
	ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer cancel()

	db, err := postgres.New()
	if err != nil {
		logger.Logger.Fatal("failed to open postgres", zap.Error(err))
	}

	logger.Logger.Sugar().Infof("Connected to Postgres at %s:%s", config.Config.Postgres.Host, config.Config.Postgres.Port)

	redisClient, err := redis.NewClientCE()
	if err != nil {
		logger.Logger.Fatal("failed to open redis", zap.Error(err))
	}

	logger.Logger.Sugar().Infof("Connected to Redis at %s:%s", config.Config.Redis.Host, config.Config.Redis.Port)

	// Use the EE version only for the Repository.
	repo := ee_postgres.NewRepositoryEE(db)
	smtpMailer := smtp.NewMailerCE()
	wsManager := wsmanager.NewManager(ctx, repo, redisClient)

	// Initialize infra dependency container
	dep := port.NewDependencies(repo, smtpMailer, redisClient, wsManager)

	if config.Config.Env == config.EnvLocal {
		if err := fixtures.Load(ctx, dep.Repository); err != nil {
			logger.Logger.Fatal(err.Error())
		}
	}

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
		logger.Logger.Info(fmt.Sprintf("Defaulting to port %s\n", port))
	}

	srv := &http.Server{
		ReadHeaderTimeout: 10 * time.Second,
		ReadTimeout:       10 * time.Second,
		WriteTimeout:      600 * time.Second,
		Handler:           ee_transport.NewRouter(dep).Build(),
		Addr:              fmt.Sprintf(":%s", port),
	}

	eg, egCtx := errgroup.WithContext(ctx)
	eg.Go(func() error {
		logger.Logger.Info(fmt.Sprintf("Listening on port %s\n", port))
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			return fmt.Errorf("HTTP server error: %v", err)
		}
		return nil
	})
	eg.Go(func() error {
		<-egCtx.Done()
		logger.Logger.Info("Shutting down server...")

		shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer shutdownCancel()

		var shutdownErr error
		if err := srv.Shutdown(shutdownCtx); err != nil {
			logger.Logger.Error("Server shutdown error", zap.Error(err))
			shutdownErr = fmt.Errorf("server shutdown: %v", err)
		}

		if err := wsManager.Close(); err != nil {
			logger.Logger.Sugar().Errorf("WebSocket manager graceful shutdown failed: %v", err)
		} else {
			logger.Logger.Sugar().Info("WebSocket manager gracefully stopped")
		}

		if err := redisClient.Close(); err != nil {
			logger.Logger.Sugar().Errorf("Redis client close failed: %v", err)
		} else {
			logger.Logger.Sugar().Info("Redis client gracefully stopped")
		}

		if err := db.Close(); err != nil {
			logger.Logger.Sugar().Errorf("DB connection close failed: %v", err)
		} else {
			logger.Logger.Sugar().Info("DB connection gracefully stopped")
		}

		logger.Logger.Info("Server shutdown complete")
		// Return the server shutdown error if it happened.
		return shutdownErr
	})

	if err := eg.Wait(); err != nil && err != http.ErrServerClosed {
		logger.Logger.Error(fmt.Sprintf("Error during shutdown: %v", err))
		os.Exit(1)
	}
}
</file>

<file path="ee/internal/app/apikey/service.go">
package apikey

import (
	"github.com/trysourcetool/sourcetool/backend/internal/app/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
)

type serviceEE struct {
	*port.Dependencies
	*apikey.ServiceCE
}

func NewServiceEE(d *port.Dependencies) *serviceEE {
	return &serviceEE{
		Dependencies: d,
		ServiceCE: apikey.NewServiceCE(
			port.NewDependencies(d.Repository, d.Mailer, d.PubSub, d.WSManager),
		),
	}
}
</file>

<file path="ee/internal/app/auth/service.go">
package auth

import (
	"github.com/trysourcetool/sourcetool/backend/internal/app/auth"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
)

type serviceEE struct {
	*port.Dependencies
	*auth.ServiceCE
}

func NewServiceEE(d *port.Dependencies) *serviceEE {
	return &serviceEE{
		Dependencies: d,
		ServiceCE: auth.NewServiceCE(
			port.NewDependencies(d.Repository, d.Mailer, d.PubSub, d.WSManager),
		),
	}
}
</file>

<file path="ee/internal/app/environment/service.go">
package environment

import (
	"github.com/trysourcetool/sourcetool/backend/internal/app/environment"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
)

type serviceEE struct {
	*port.Dependencies
	*environment.ServiceCE
}

func NewServiceEE(d *port.Dependencies) *serviceEE {
	return &serviceEE{
		Dependencies: d,
		ServiceCE: environment.NewServiceCE(
			port.NewDependencies(d.Repository, d.Mailer, d.PubSub, d.WSManager),
		),
	}
}
</file>

<file path="ee/internal/app/group/service.go">
package group

import (
	"context"
	"errors"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	groupSvc "github.com/trysourcetool/sourcetool/backend/internal/app/group"
	"github.com/trysourcetool/sourcetool/backend/internal/app/permission"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/group"
	domainperm "github.com/trysourcetool/sourcetool/backend/internal/domain/permission"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type serviceEE struct {
	*port.Dependencies
	*groupSvc.ServiceCE
}

func NewServiceEE(d *port.Dependencies) *serviceEE {
	return &serviceEE{
		Dependencies: d,
		ServiceCE: groupSvc.NewServiceCE(
			port.NewDependencies(d.Repository, d.Mailer, d.PubSub, d.WSManager),
		),
	}
}

func (s *serviceEE) Get(ctx context.Context, in dto.GetGroupInput) (*dto.GetGroupOutput, error) {
	currentOrg := internal.CurrentOrganization(ctx)
	groupID, err := uuid.FromString(in.GroupID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}

	group, err := s.Repository.Group().Get(ctx, group.ByOrganizationID(currentOrg.ID), group.ByID(groupID))
	if err != nil {
		return nil, err
	}

	return &dto.GetGroupOutput{
		Group: dto.GroupFromModel(group),
	}, nil
}

func (s *serviceEE) List(ctx context.Context) (*dto.ListGroupsOutput, error) {
	currentOrg := internal.CurrentOrganization(ctx)
	groups, err := s.Repository.Group().List(ctx, group.ByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	users, err := s.Repository.User().List(ctx, user.ByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	userGroups, err := s.Repository.User().ListGroups(ctx, user.GroupByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	userIDs := make([]uuid.UUID, 0, len(users))
	for _, user := range users {
		userIDs = append(userIDs, user.ID)
	}

	orgAccesses, err := s.Repository.User().ListOrganizationAccesses(ctx, user.OrganizationAccessByUserIDs(userIDs))
	if err != nil {
		return nil, err
	}

	orgAccessesMap := make(map[uuid.UUID]*user.UserOrganizationAccess)
	for _, orgAccess := range orgAccesses {
		orgAccessesMap[orgAccess.UserID] = orgAccess
	}

	groupsOut := make([]*dto.Group, 0, len(groups))
	for _, group := range groups {
		groupsOut = append(groupsOut, dto.GroupFromModel(group))
	}

	usersOut := make([]*dto.User, 0, len(users))
	for _, u := range users {
		var role user.UserOrganizationRole
		orgAccess, ok := orgAccessesMap[u.ID]
		if ok {
			role = orgAccess.Role
		}
		usersOut = append(usersOut, dto.UserFromModel(u, nil, role))
	}

	userGroupsOut := make([]*dto.UserGroup, 0, len(userGroups))
	for _, userGroup := range userGroups {
		userGroupsOut = append(userGroupsOut, dto.UserGroupFromModel(userGroup))
	}

	return &dto.ListGroupsOutput{
		Groups:     groupsOut,
		Users:      usersOut,
		UserGroups: userGroupsOut,
	}, nil
}

func (s *serviceEE) Create(ctx context.Context, in dto.CreateGroupInput) (*dto.CreateGroupOutput, error) {
	checker := permission.NewChecker(s.Repository)
	if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditGroup); err != nil {
		return nil, err
	}

	currentOrg := internal.CurrentOrganization(ctx)

	slugExists, err := s.Repository.Group().IsSlugExistsInOrganization(ctx, currentOrg.ID, in.Slug)
	if err != nil {
		return nil, err
	}
	if slugExists {
		return nil, errdefs.ErrGroupSlugAlreadyExists(errors.New("slug already exists"))
	}

	if !validateSlug(in.Slug) {
		return nil, errdefs.ErrInvalidArgument(errors.New("invalid slug"))
	}

	g := &group.Group{
		ID:             uuid.Must(uuid.NewV4()),
		OrganizationID: currentOrg.ID,
		Name:           in.Name,
		Slug:           in.Slug,
	}

	userIDs := make([]uuid.UUID, 0, len(in.UserIDs))
	for _, userID := range in.UserIDs {
		id, err := uuid.FromString(userID)
		if err != nil {
			return nil, errdefs.ErrInvalidArgument(err)
		}
		userIDs = append(userIDs, id)
	}

	userGroups := make([]*user.UserGroup, 0, len(userIDs))
	for _, userID := range userIDs {
		userGroups = append(userGroups, &user.UserGroup{
			ID:      uuid.Must(uuid.NewV4()),
			UserID:  userID,
			GroupID: g.ID,
		})
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.Group().Create(ctx, g); err != nil {
			return err
		}

		if err := tx.User().BulkInsertGroups(ctx, userGroups); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	g, err = s.Repository.Group().Get(ctx, group.ByID(g.ID))
	if err != nil {
		return nil, err
	}

	return &dto.CreateGroupOutput{
		Group: dto.GroupFromModel(g),
	}, nil
}

func (s *serviceEE) Update(ctx context.Context, in dto.UpdateGroupInput) (*dto.UpdateGroupOutput, error) {
	checker := permission.NewChecker(s.Repository)
	if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditGroup); err != nil {
		return nil, err
	}

	currentOrg := internal.CurrentOrganization(ctx)
	groupID, err := uuid.FromString(in.GroupID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}

	g, err := s.Repository.Group().Get(ctx, group.ByID(groupID), group.ByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	if in.Name != nil {
		g.Name = internal.SafeValue(in.Name)
	}

	userIDs := make([]uuid.UUID, 0, len(in.UserIDs))
	for _, userID := range in.UserIDs {
		id, err := uuid.FromString(userID)
		if err != nil {
			return nil, errdefs.ErrInvalidArgument(err)
		}
		userIDs = append(userIDs, id)
	}

	userGroups := make([]*user.UserGroup, 0, len(userIDs))
	for _, userID := range userIDs {
		userGroups = append(userGroups, &user.UserGroup{
			ID:      uuid.Must(uuid.NewV4()),
			UserID:  userID,
			GroupID: g.ID,
		})
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.Group().Update(ctx, g); err != nil {
			return err
		}

		existingGroups, err := tx.User().ListGroups(ctx, user.GroupByGroupID(g.ID))
		if err != nil {
			return err
		}

		if err := tx.User().BulkDeleteGroups(ctx, existingGroups); err != nil {
			return err
		}

		if err := tx.User().BulkInsertGroups(ctx, userGroups); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	g, err = s.Repository.Group().Get(ctx, group.ByID(g.ID))
	if err != nil {
		return nil, err
	}

	return &dto.UpdateGroupOutput{
		Group: dto.GroupFromModel(g),
	}, nil
}

func (s *serviceEE) Delete(ctx context.Context, in dto.DeleteGroupInput) (*dto.DeleteGroupOutput, error) {
	checker := permission.NewChecker(s.Repository)
	if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditGroup); err != nil {
		return nil, err
	}

	currentOrg := internal.CurrentOrganization(ctx)
	groupID, err := uuid.FromString(in.GroupID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}

	g, err := s.Repository.Group().Get(ctx, group.ByID(groupID), group.ByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.Group().Delete(ctx, g); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	return &dto.DeleteGroupOutput{
		Group: dto.GroupFromModel(g),
	}, nil
}
</file>

<file path="ee/internal/app/group/validate.go">
package group

import "regexp"

func validateSlug(s string) bool {
	pattern := `^[a-zA-Z0-9\-_]+$`
	match, _ := regexp.MatchString(pattern, s)
	return match
}
</file>

<file path="ee/internal/app/hostinstance/service.go">
package hostinstance

import (
	"github.com/trysourcetool/sourcetool/backend/internal/app/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
)

type serviceEE struct {
	*port.Dependencies
	*hostinstance.ServiceCE
}

func NewServiceEE(d *port.Dependencies) *serviceEE {
	return &serviceEE{
		Dependencies: d,
		ServiceCE: hostinstance.NewServiceCE(
			port.NewDependencies(d.Repository, d.Mailer, d.PubSub, d.WSManager),
		),
	}
}
</file>

<file path="ee/internal/app/organization/service.go">
package organization

import (
	"github.com/trysourcetool/sourcetool/backend/internal/app/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
)

type serviceEE struct {
	*port.Dependencies
	*organization.ServiceCE
}

func NewServiceEE(d *port.Dependencies) *serviceEE {
	return &serviceEE{
		Dependencies: d,
		ServiceCE: organization.NewServiceCE(
			port.NewDependencies(d.Repository, d.Mailer, d.PubSub, d.WSManager),
		),
	}
}
</file>

<file path="ee/internal/app/page/service.go">
package page

import (
	"context"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	pageSvc "github.com/trysourcetool/sourcetool/backend/internal/app/page"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/group"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/page"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
)

type serviceEE struct {
	*port.Dependencies
	*pageSvc.ServiceCE
}

func NewServiceEE(d *port.Dependencies) *serviceEE {
	return &serviceEE{
		Dependencies: d,
		ServiceCE: pageSvc.NewServiceCE(
			port.NewDependencies(d.Repository, d.Mailer, d.PubSub, d.WSManager),
		),
	}
}

func (s *serviceEE) List(ctx context.Context, in dto.ListPagesInput) (*dto.ListPagesOutput, error) {
	o := internal.CurrentOrganization(ctx)

	envID, err := uuid.FromString(in.EnvironmentID)
	if err != nil {
		return nil, err
	}

	env, err := s.Repository.Environment().Get(ctx, environment.ByID(envID))
	if err != nil {
		return nil, err
	}

	pages, err := s.Repository.Page().List(ctx, page.ByOrganizationID(o.ID), page.ByEnvironmentID(env.ID), page.OrderBy(`array_length(p."path", 1), "path"`))
	if err != nil {
		return nil, err
	}

	groups, err := s.Repository.Group().List(ctx, group.ByOrganizationID(o.ID))
	if err != nil {
		return nil, err
	}

	groupPages, err := s.Repository.Group().ListPages(ctx, group.PageByOrganizationID(o.ID), group.PageByEnvironmentID(env.ID))
	if err != nil {
		return nil, err
	}

	users, err := s.Repository.User().List(ctx, user.ByOrganizationID(o.ID))
	if err != nil {
		return nil, err
	}

	userGroups, err := s.Repository.User().ListGroups(ctx, user.GroupByOrganizationID(o.ID))
	if err != nil {
		return nil, err
	}

	pagesOut := make([]*dto.Page, 0, len(pages))
	for _, page := range pages {
		pagesOut = append(pagesOut, dto.PageFromModel(page))
	}

	groupsOut := make([]*dto.Group, 0, len(groups))
	for _, group := range groups {
		groupsOut = append(groupsOut, dto.GroupFromModel(group))
	}

	groupPagesOut := make([]*dto.GroupPage, 0, len(groupPages))
	for _, groupPage := range groupPages {
		groupPagesOut = append(groupPagesOut, dto.GroupPageFromModel(groupPage))
	}

	usersOut := make([]*dto.User, 0, len(users))
	for _, u := range users {
		usersOut = append(usersOut, dto.UserFromModel(u, nil, user.UserOrganizationRoleUnknown))
	}

	userGroupsOut := make([]*dto.UserGroup, 0, len(userGroups))
	for _, userGroup := range userGroups {
		userGroupsOut = append(userGroupsOut, dto.UserGroupFromModel(userGroup))
	}

	return &dto.ListPagesOutput{
		Pages:      pagesOut,
		Groups:     groupsOut,
		GroupPages: groupPagesOut,
		Users:      usersOut,
		UserGroups: userGroupsOut,
	}, nil
}
</file>

<file path="ee/internal/app/user/service.go">
package user

import (
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/app/user"
)

type serviceEE struct {
	*port.Dependencies
	*user.ServiceCE
}

func NewServiceEE(d *port.Dependencies) *serviceEE {
	return &serviceEE{
		Dependencies: d,
		ServiceCE: user.NewServiceCE(
			port.NewDependencies(d.Repository, d.Mailer, d.PubSub, d.WSManager),
		),
	}
}
</file>

<file path="ee/internal/app/ws/service.go">
package ws

import (
	"context"
	"errors"

	"github.com/gofrs/uuid/v5"
	gorillaws "github.com/gorilla/websocket"

	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	wsSvc "github.com/trysourcetool/sourcetool/backend/internal/app/ws"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/group"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/page"
	websocketv1 "github.com/trysourcetool/sourcetool/backend/internal/pb/go/websocket/v1"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/ws/message"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

type serviceEE struct {
	*port.Dependencies
	*wsSvc.ServiceCE
}

func NewServiceEE(d *port.Dependencies) *serviceEE {
	return &serviceEE{
		Dependencies: d,
		ServiceCE:    wsSvc.NewServiceCE(port.NewDependencies(d.Repository, d.Mailer, d.PubSub, d.WSManager)),
	}
}

func (s *serviceEE) InitializeHost(ctx context.Context, conn *gorillaws.Conn, instanceID string, msg *websocketv1.Message) (*hostinstance.HostInstance, error) {
	in := msg.GetInitializeHost()
	if in == nil {
		return nil, errors.New("invalid message")
	}

	apikey, err := s.Repository.APIKey().Get(ctx, apikey.ByKey(in.ApiKey))
	if err != nil {
		return nil, err
	}

	hostInstanceID, err := uuid.FromString(instanceID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}

	hostInstance, err := s.Repository.HostInstance().Get(ctx, hostinstance.ByID(hostInstanceID))
	if err != nil && !errdefs.IsHostInstanceNotFound(err) {
		return nil, err
	}

	hostExists := hostInstance != nil

	if !hostExists {
		hostInstance = &hostinstance.HostInstance{
			ID:             hostInstanceID,
			OrganizationID: apikey.OrganizationID,
			APIKeyID:       apikey.ID,
		}
	}

	hostInstance.SDKName = in.SdkName
	hostInstance.SDKVersion = in.SdkVersion
	hostInstance.Status = hostinstance.HostInstanceStatusOnline

	existingPages, err := s.Repository.Page().List(ctx, page.ByAPIKeyID(apikey.ID))
	if err != nil {
		return nil, err
	}

	existingPageMap := make(map[string]*page.Page)
	for _, p := range existingPages {
		existingPageMap[p.ID.String()] = p
	}

	var allGroupSlugs []string
	for _, p := range in.Pages {
		allGroupSlugs = append(allGroupSlugs, p.Groups...)
	}
	groups, err := s.Repository.Group().List(ctx, group.ByOrganizationID(apikey.OrganizationID), group.BySlugs(allGroupSlugs))
	if err != nil {
		return nil, err
	}
	groupMap := make(map[string]*group.Group)
	for _, g := range groups {
		groupMap[g.Slug] = g
	}

	requestPageIDs := make(map[string]struct{})
	for _, p := range in.Pages {
		requestPageIDs[p.Id] = struct{}{}
	}

	insertPages := make([]*page.Page, 0)
	updatePages := make([]*page.Page, 0)
	deletePages := make([]*page.Page, 0)
	for _, reqPage := range in.Pages {
		if existingPage, ok := existingPageMap[reqPage.Id]; ok {
			existingPage.Name = reqPage.Name
			existingPage.Route = reqPage.Route
			existingPage.Path = reqPage.Path
			updatePages = append(updatePages, existingPage)
		} else {
			pageID, err := uuid.FromString(reqPage.Id)
			if err != nil {
				return nil, err
			}
			newPage := &page.Page{
				ID:             pageID,
				OrganizationID: apikey.OrganizationID,
				EnvironmentID:  apikey.EnvironmentID,
				APIKeyID:       apikey.ID,
				Name:           reqPage.Name,
				Route:          reqPage.Route,
				Path:           reqPage.Path,
			}
			insertPages = append(insertPages, newPage)
		}
	}

	for _, existingPage := range existingPages {
		if _, exists := requestPageIDs[existingPage.ID.String()]; !exists {
			deletePages = append(deletePages, existingPage)
		}
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if hostExists {
			if err := tx.HostInstance().Update(ctx, hostInstance); err != nil {
				return err
			}
		} else {
			if err := tx.HostInstance().Create(ctx, hostInstance); err != nil {
				return err
			}
		}

		if len(deletePages) > 0 {
			if err := tx.Page().BulkDelete(ctx, deletePages); err != nil {
				return err
			}
		}
		if len(updatePages) > 0 {
			if err := tx.Page().BulkUpdate(ctx, updatePages); err != nil {
				return err
			}
		}
		if len(insertPages) > 0 {
			if err := tx.Page().BulkInsert(ctx, insertPages); err != nil {
				return err
			}
		}

		var pageIDs []uuid.UUID
		pageGroupMap := make(map[uuid.UUID][]string) // pageID -> group slugs
		for _, reqPage := range in.Pages {
			pageID, err := uuid.FromString(reqPage.Id)
			if err != nil {
				return err
			}
			pageIDs = append(pageIDs, pageID)
			pageGroupMap[pageID] = reqPage.Groups
		}

		existingGroupPages, err := tx.Group().ListPages(ctx, group.PageByPageIDs(pageIDs))
		if err != nil {
			return err
		}

		if len(existingGroupPages) > 0 {
			if err := tx.Group().BulkDeletePages(ctx, existingGroupPages); err != nil {
				return err
			}
		}

		var newGroupPages []*group.GroupPage
		for pageID, groupSlugs := range pageGroupMap {
			for _, slug := range groupSlugs {
				g, ok := groupMap[slug]
				if !ok {
					continue
				}
				newGroupPages = append(newGroupPages, &group.GroupPage{
					ID:      uuid.Must(uuid.NewV4()),
					GroupID: g.ID,
					PageID:  pageID,
				})
			}
		}

		if len(newGroupPages) > 0 {
			if err := tx.Group().BulkInsertPages(ctx, newGroupPages); err != nil {
				return err
			}
		}

		return nil
	}); err != nil {
		return nil, err
	}

	s.WSManager.SetConnectedHost(hostInstance, apikey, conn)

	if err := message.SendResponse(conn, &websocketv1.Message{
		Id: msg.Id,
		Type: &websocketv1.Message_InitializeHostCompleted{
			InitializeHostCompleted: &websocketv1.InitializeHostCompleted{
				HostInstanceId: hostInstance.ID.String(),
			},
		},
	}); err != nil {
		return nil, err
	}

	return hostInstance, nil
}
</file>

<file path="ee/internal/infra/postgres/apikey/repository.go">
package apikey

import (
	sq "github.com/Masterminds/squirrel"

	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
)

type repositoryEE struct {
	db      db.DB
	builder sq.StatementBuilderType
	*apikey.RepositoryCE
}

func NewRepositoryEE(db db.DB) *repositoryEE {
	return &repositoryEE{
		db:           db,
		builder:      sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
		RepositoryCE: apikey.NewRepositoryCE(db),
	}
}
</file>

<file path="ee/internal/infra/postgres/environment/repository.go">
package environment

import (
	sq "github.com/Masterminds/squirrel"

	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/environment"
)

type repositoryEE struct {
	db      db.DB
	builder sq.StatementBuilderType
	*environment.RepositoryCE
}

func NewRepositoryEE(db db.DB) *repositoryEE {
	return &repositoryEE{
		db:           db,
		builder:      sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
		RepositoryCE: environment.NewRepositoryCE(db),
	}
}
</file>

<file path="ee/internal/infra/postgres/group/repository.go">
package group

import (
	"context"
	"database/sql"

	sq "github.com/Masterminds/squirrel"
	"github.com/gofrs/uuid/v5"
	"github.com/samber/lo"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/group"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	groupRepo "github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/group"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

type repositoryEE struct {
	db      db.DB
	builder sq.StatementBuilderType
	*groupRepo.RepositoryCE
}

func NewRepositoryEE(db db.DB) *repositoryEE {
	return &repositoryEE{
		db:           db,
		builder:      sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
		RepositoryCE: groupRepo.NewRepositoryCE(db),
	}
}

func (r *repositoryEE) Get(ctx context.Context, queries ...group.Query) (*group.Group, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := group.Group{}
	if err := r.db.GetContext(ctx, &m, query, args...); err != nil {
		if err == sql.ErrNoRows {
			return nil, errdefs.ErrGroupNotFound(err)
		}
		return nil, errdefs.ErrDatabase(err)
	}

	return &m, nil
}

func (r *repositoryEE) List(ctx context.Context, queries ...group.Query) ([]*group.Group, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := make([]*group.Group, 0)
	if err := r.db.SelectContext(ctx, &m, query, args...); err != nil {
		return nil, errdefs.ErrDatabase(err)
	}

	return m, nil
}

func (r *repositoryEE) buildQuery(ctx context.Context, queries ...group.Query) (string, []any, error) {
	q := r.builder.Select(r.columns()...).
		From(`"group" g`)

	q = r.applyQueries(q, queries...)

	query, args, err := q.ToSql()
	if err != nil {
		return "", nil, errdefs.ErrDatabase(err)
	}

	return query, args, err
}

func (r *repositoryEE) applyQueries(b sq.SelectBuilder, queries ...group.Query) sq.SelectBuilder {
	for _, q := range queries {
		switch q := q.(type) {
		case group.ByIDQuery:
			b = b.Where(sq.Eq{`g."id"`: q.ID})
		case group.ByOrganizationIDQuery:
			b = b.Where(sq.Eq{`g."organization_id"`: q.OrganizationID})
		case group.BySlugQuery:
			b = b.Where(sq.Eq{`g."slug"`: q.Slug})
		case group.BySlugsQuery:
			b = b.Where(sq.Eq{`g."slug"`: q.Slugs})
		}
	}

	return b
}

func (r *repositoryEE) Create(ctx context.Context, m *group.Group) error {
	if _, err := r.builder.
		Insert(`"group"`).
		Columns(
			`"id"`,
			`"organization_id"`,
			`"name"`,
			`"slug"`,
		).
		Values(
			m.ID,
			m.OrganizationID,
			m.Name,
			m.Slug,
		).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *repositoryEE) Update(ctx context.Context, m *group.Group) error {
	if _, err := r.builder.
		Update(`"group"`).
		Set(`"name"`, m.Name).
		Set(`"slug"`, m.Slug).
		Where(sq.Eq{`"id"`: m.ID}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *repositoryEE) Delete(ctx context.Context, m *group.Group) error {
	if _, err := r.builder.
		Delete(`"group"`).
		Where(sq.Eq{`"id"`: m.ID}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *repositoryEE) columns() []string {
	return []string{
		`g."id"`,
		`g."organization_id"`,
		`g."name"`,
		`g."slug"`,
		`g."created_at"`,
		`g."updated_at"`,
	}
}

func (r *repositoryEE) IsSlugExistsInOrganization(ctx context.Context, orgID uuid.UUID, slug string) (bool, error) {
	if _, err := r.Get(ctx, group.ByOrganizationID(orgID), group.BySlug(slug)); err != nil {
		if errdefs.IsGroupNotFound(err) {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

func (r *repositoryEE) ListPages(ctx context.Context, queries ...group.PageQuery) ([]*group.GroupPage, error) {
	query, args, err := r.buildPageQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := make([]*group.GroupPage, 0)
	if err := r.db.SelectContext(ctx, &m, query, args...); err != nil {
		return nil, errdefs.ErrDatabase(err)
	}

	return m, nil
}

func (r *repositoryEE) buildPageQuery(ctx context.Context, queries ...group.PageQuery) (string, []any, error) {
	q := r.builder.Select(
		`gp."id"`,
		`gp."group_id"`,
		`gp."page_id"`,
		`gp."created_at"`,
		`gp."updated_at"`,
	).
		From(`"group_page" gp`)

	q = r.applyPageQueries(q, queries...)

	query, args, err := q.ToSql()
	if err != nil {
		return "", nil, errdefs.ErrDatabase(err)
	}

	return query, args, err
}

func (r *repositoryEE) applyPageQueries(b sq.SelectBuilder, queries ...group.PageQuery) sq.SelectBuilder {
	for _, q := range queries {
		switch q := q.(type) {
		case group.PageByOrganizationIDQuery:
			b = b.
				InnerJoin(`"group" g ON g."id" = gp."group_id"`).
				Where(sq.Eq{`g."organization_id"`: q.OrganizationID})
		case group.PageByPageIDsQuery:
			b = b.Where(sq.Eq{`gp."page_id"`: q.PageIDs})
		case group.PageByEnvironmentIDQuery:
			b = b.
				InnerJoin(`"page" p ON p."id" = gp."page_id"`).
				Where(sq.Eq{`p."environment_id"`: q.EnvironmentID})
		}
	}

	return b
}

func (r *repositoryEE) BulkInsertPages(ctx context.Context, pages []*group.GroupPage) error {
	if len(pages) == 0 {
		return nil
	}

	q := r.builder.
		Insert(`group_page`).
		Columns(
			`"id"`,
			`"group_id"`,
			`"page_id"`,
		)

	for _, p := range pages {
		q = q.Values(p.ID, p.GroupID, p.PageID)
	}

	if _, err := q.RunWith(r.db).ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *repositoryEE) BulkUpdatePages(ctx context.Context, pages []*group.GroupPage) error {
	if len(pages) == 0 {
		return nil
	}

	for _, p := range pages {
		if _, err := r.builder.
			Update(`group_page`).
			Set(`"group_id"`, p.GroupID).
			Set(`"page_id"`, p.PageID).
			Where(sq.Eq{`"id"`: p.ID}).
			RunWith(r.db).
			ExecContext(ctx); err != nil {
			return errdefs.ErrDatabase(err)
		}
	}

	return nil
}

func (r *repositoryEE) BulkDeletePages(ctx context.Context, pages []*group.GroupPage) error {
	if len(pages) == 0 {
		return nil
	}

	ids := lo.Map(pages, func(x *group.GroupPage, _ int) uuid.UUID {
		return x.ID
	})

	if _, err := r.builder.
		Delete(`"group_page"`).
		Where(sq.Eq{`"id"`: ids}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}
</file>

<file path="ee/internal/infra/postgres/hostinstance/repository.go">
package hostinstance

import (
	sq "github.com/Masterminds/squirrel"

	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/hostinstance"
)

type repositoryEE struct {
	db      db.DB
	builder sq.StatementBuilderType
	*hostinstance.RepositoryCE
}

func NewRepositoryEE(db db.DB) *repositoryEE {
	return &repositoryEE{
		db:           db,
		builder:      sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
		RepositoryCE: hostinstance.NewRepositoryCE(db),
	}
}
</file>

<file path="ee/internal/infra/postgres/organization/repository.go">
package organization

import (
	sq "github.com/Masterminds/squirrel"

	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/organization"
)

type repositoryEE struct {
	db      db.DB
	builder sq.StatementBuilderType
	*organization.RepositoryCE
}

func NewRepositoryEE(db db.DB) *repositoryEE {
	return &repositoryEE{
		db:           db,
		builder:      sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
		RepositoryCE: organization.NewRepositoryCE(db),
	}
}
</file>

<file path="ee/internal/infra/postgres/page/repository.go">
package page

import (
	sq "github.com/Masterminds/squirrel"

	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/page"
)

type repositoryEE struct {
	db      db.DB
	builder sq.StatementBuilderType
	*page.RepositoryCE
}

func NewRepositoryEE(db db.DB) *repositoryEE {
	return &repositoryEE{
		db:           db,
		builder:      sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
		RepositoryCE: page.NewRepositoryCE(db),
	}
}
</file>

<file path="ee/internal/infra/postgres/session/repository.go">
package session

import (
	sq "github.com/Masterminds/squirrel"

	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/session"
)

type repositoryEE struct {
	db      db.DB
	builder sq.StatementBuilderType
	*session.RepositoryCE
}

func NewRepositoryEE(db db.DB) *repositoryEE {
	return &repositoryEE{
		db:           db,
		builder:      sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
		RepositoryCE: session.NewRepositoryCE(db),
	}
}
</file>

<file path="ee/internal/infra/postgres/user/repository.go">
package user

import (
	sq "github.com/Masterminds/squirrel"

	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/user"
)

type repositoryEE struct {
	db      db.DB
	builder sq.StatementBuilderType
	*user.RepositoryCE
}

func NewRepositoryEE(db db.DB) *repositoryEE {
	return &repositoryEE{
		db:           db,
		builder:      sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
		RepositoryCE: user.NewRepositoryCE(db),
	}
}
</file>

<file path="ee/internal/infra/postgres/repository.go">
package postgres

import (
	"github.com/jmoiron/sqlx"

	apikeyRepo "github.com/trysourcetool/sourcetool/backend/ee/internal/infra/postgres/apikey"
	environmentRepo "github.com/trysourcetool/sourcetool/backend/ee/internal/infra/postgres/environment"
	groupRepo "github.com/trysourcetool/sourcetool/backend/ee/internal/infra/postgres/group"
	hostinstanceRepo "github.com/trysourcetool/sourcetool/backend/ee/internal/infra/postgres/hostinstance"
	organizationRepo "github.com/trysourcetool/sourcetool/backend/ee/internal/infra/postgres/organization"
	pageRepo "github.com/trysourcetool/sourcetool/backend/ee/internal/infra/postgres/page"
	sessionRepo "github.com/trysourcetool/sourcetool/backend/ee/internal/infra/postgres/session"
	userRepo "github.com/trysourcetool/sourcetool/backend/ee/internal/infra/postgres/user"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/group"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/page"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/session"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
)

var _ port.Repository = (*repositoryEE)(nil)

type repositoryEE struct {
	db *sqlx.DB
}

func NewRepositoryEE(db *sqlx.DB) *repositoryEE {
	return &repositoryEE{
		db: db,
	}
}

func (r *repositoryEE) Close() error {
	return r.db.Close()
}

func (r *repositoryEE) RunTransaction(f func(port.Transaction) error) error {
	tx, err := r.db.Beginx()
	if err != nil {
		return err
	}

	t := &transactionEE{db: tx}
	if err := f(t); err != nil {
		if err := tx.Rollback(); err != nil {
			return err
		}
		return err
	}

	if err := tx.Commit(); err != nil {
		return err
	}

	return nil
}

func (r *repositoryEE) APIKey() apikey.Repository {
	return apikeyRepo.NewRepositoryEE(db.NewQueryLogger(r.db))
}

func (r *repositoryEE) Environment() environment.Repository {
	return environmentRepo.NewRepositoryEE(db.NewQueryLogger(r.db))
}

func (r *repositoryEE) Group() group.Repository {
	return groupRepo.NewRepositoryEE(db.NewQueryLogger(r.db))
}

func (r *repositoryEE) HostInstance() hostinstance.Repository {
	return hostinstanceRepo.NewRepositoryEE(db.NewQueryLogger(r.db))
}

func (r *repositoryEE) Organization() organization.Repository {
	return organizationRepo.NewRepositoryEE(db.NewQueryLogger(r.db))
}

func (r *repositoryEE) Page() page.Repository {
	return pageRepo.NewRepositoryEE(db.NewQueryLogger(r.db))
}

func (r *repositoryEE) Session() session.Repository {
	return sessionRepo.NewRepositoryEE(db.NewQueryLogger(r.db))
}

func (r *repositoryEE) User() user.Repository {
	return userRepo.NewRepositoryEE(db.NewQueryLogger(r.db))
}

type transactionEE struct {
	db *sqlx.Tx
}

func (t *transactionEE) APIKey() apikey.Repository {
	return apikeyRepo.NewRepositoryEE(db.NewQueryLogger(t.db))
}

func (t *transactionEE) Environment() environment.Repository {
	return environmentRepo.NewRepositoryEE(db.NewQueryLogger(t.db))
}

func (t *transactionEE) Group() group.Repository {
	return groupRepo.NewRepositoryEE(db.NewQueryLogger(t.db))
}

func (t *transactionEE) HostInstance() hostinstance.Repository {
	return hostinstanceRepo.NewRepositoryEE(db.NewQueryLogger(t.db))
}

func (t *transactionEE) Organization() organization.Repository {
	return organizationRepo.NewRepositoryEE(db.NewQueryLogger(t.db))
}

func (t *transactionEE) Page() page.Repository {
	return pageRepo.NewRepositoryEE(db.NewQueryLogger(t.db))
}

func (t *transactionEE) Session() session.Repository {
	return sessionRepo.NewRepositoryEE(db.NewQueryLogger(t.db))
}

func (t *transactionEE) User() user.Repository {
	return userRepo.NewRepositoryEE(db.NewQueryLogger(t.db))
}
</file>

<file path="ee/internal/transport/http/v1/middleware.go">
package v1

import (
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	v1 "github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1"
)

type MiddlewareEE struct {
	*v1.MiddlewareCE
}

func NewMiddlewareEE(d *port.Dependencies) *MiddlewareEE {
	return &MiddlewareEE{
		MiddlewareCE: v1.NewMiddlewareCE(d.Repository),
	}
}
</file>

<file path="ee/internal/transport/http/v1/router.go">
package v1

import (
	apikeySvc "github.com/trysourcetool/sourcetool/backend/ee/internal/app/apikey"
	authSvc "github.com/trysourcetool/sourcetool/backend/ee/internal/app/auth"
	environmentSvc "github.com/trysourcetool/sourcetool/backend/ee/internal/app/environment"
	groupSvc "github.com/trysourcetool/sourcetool/backend/ee/internal/app/group"
	hostinstanceSvc "github.com/trysourcetool/sourcetool/backend/ee/internal/app/hostinstance"
	organizationSvc "github.com/trysourcetool/sourcetool/backend/ee/internal/app/organization"
	pageSvc "github.com/trysourcetool/sourcetool/backend/ee/internal/app/page"
	userSvc "github.com/trysourcetool/sourcetool/backend/ee/internal/app/user"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	v1 "github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/handlers"
)

func NewRouter(d *port.Dependencies) *v1.Router {
	middleware := NewMiddlewareEE(d)
	apiKeyHandler := handlers.NewAPIKeyHandler(apikeySvc.NewServiceEE(d))
	authHandler := handlers.NewAuthHandler(authSvc.NewServiceEE(d))
	environmentHandler := handlers.NewEnvironmentHandler(environmentSvc.NewServiceEE(d))
	groupHandler := handlers.NewGroupHandler(groupSvc.NewServiceEE(d))
	hostInstanceHandler := handlers.NewHostInstanceHandler(hostinstanceSvc.NewServiceEE(d))
	organizationHandler := handlers.NewOrganizationHandler(organizationSvc.NewServiceEE(d))
	pageHandler := handlers.NewPageHandler(pageSvc.NewServiceEE(d))
	userHandler := handlers.NewUserHandler(userSvc.NewServiceEE(d))
	return v1.NewRouter(
		middleware,
		apiKeyHandler,
		authHandler,
		environmentHandler,
		groupHandler,
		hostInstanceHandler,
		organizationHandler,
		pageHandler,
		userHandler,
	)
}
</file>

<file path="ee/internal/transport/ws/middleware.go">
package ws

import (
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/ws"
)

type MiddlewareEE struct {
	*ws.MiddlewareCE
}

func NewMiddlewareEE(r port.Repository) *MiddlewareEE {
	return &MiddlewareEE{
		MiddlewareCE: ws.NewMiddlewareCE(r),
	}
}
</file>

<file path="ee/internal/transport/ws/router.go">
package ws

import (
	"net/http"

	"github.com/gorilla/websocket"

	wsSvc "github.com/trysourcetool/sourcetool/backend/ee/internal/app/ws"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	wsserver "github.com/trysourcetool/sourcetool/backend/internal/transport/ws"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/ws/handlers"
)

func NewRouter(d *port.Dependencies) *wsserver.Router {
	middleware := NewMiddlewareEE(d.Repository)
	wsHandler := handlers.NewWebSocketHandler(
		websocket.Upgrader{
			CheckOrigin: func(r *http.Request) bool {
				return true
			},
			ReadBufferSize:  1024,
			WriteBufferSize: 1024,
		},
		d.WSManager,
		wsSvc.NewServiceEE(d),
	)
	return wsserver.NewRouter(middleware, wsHandler)
}
</file>

<file path="ee/internal/transport/router.go">
package transport

import (
	"fmt"
	"net/http"
	"os"
	"regexp"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/cors"
	httpSwagger "github.com/swaggo/http-swagger"

	"github.com/trysourcetool/sourcetool/backend/config"
	httpserver "github.com/trysourcetool/sourcetool/backend/ee/internal/transport/http/v1"
	"github.com/trysourcetool/sourcetool/backend/ee/internal/transport/ws"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/transport"
	cehttpserver "github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1"
	cews "github.com/trysourcetool/sourcetool/backend/internal/transport/ws"
)

type Router struct {
	wsRouter   *cews.Router
	httpRouter *cehttpserver.Router
}

func NewRouter(d *port.Dependencies) *Router {
	return &Router{
		wsRouter:   ws.NewRouter(d),
		httpRouter: httpserver.NewRouter(d),
	}
}

func (r *Router) Build() chi.Router {
	router := chi.NewRouter()
	router.Use(middleware.RequestID)
	router.Use(middleware.Logger)
	router.Use(middleware.Recoverer)
	router.Use(middleware.Timeout(time.Duration(600) * time.Second))
	router.Use(cors.New(cors.Options{
		AllowOriginFunc: func(r *http.Request, origin string) bool {
			var pattern string

			switch config.Config.Env {
			case config.EnvProd:
				pattern = `^https://[a-zA-Z0-9-]+\.trysourcetool\.com$`
			case config.EnvStaging:
				pattern = `^https://[a-zA-Z0-9-]+\.staging\.trysourcetool\.com$`
			case config.EnvLocal:
				pattern = `^(http://[a-zA-Z0-9-]+\.local\.trysourcetool\.com:\d+|http://localhost:\d+)$`
			default:
				return false
			}

			matched, err := regexp.MatchString(pattern, origin)
			if err != nil {
				return false
			}

			return matched
		},
		AllowedMethods: []string{
			http.MethodGet,
			http.MethodPost,
			http.MethodPut,
			http.MethodDelete,
			http.MethodOptions,
		},
		AllowedHeaders:   []string{"*"},
		ExposedHeaders:   []string{},
		AllowCredentials: true,
		MaxAge:           0,
		Debug:            !(config.Config.Env == config.EnvProd),
	}).Handler)

	if config.Config.Env == config.EnvLocal {
		router.Get("/swagger/*", httpSwagger.Handler(
			httpSwagger.URL(fmt.Sprintf("%s/swagger/doc.json", "http://localhost:8080")),
		))
	}

	router.Mount("/ws", r.wsRouter.Build())
	router.Mount("/api", r.httpRouter.Build())

	staticDir := os.Getenv("STATIC_FILES_DIR")
	transport.ServeStaticFiles(router, staticDir)

	return router
}
</file>

<file path="ee/.gitignore">
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
vendor/

# Go workspace file
go.work

# IDE specific files
.idea/
.vscode/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Environment files
.env
.env.local
*.env

# Debug files
debug
*.log

# Binary directory
bin/
dist/

# Local development
tmp/

# DB data
/postgres/data

# Build binary
/sourcetool/backend

# Debug
cookies.txt
</file>

<file path="ee/LICENSE">
The Sourcetool Enterprise Edition (EE) license (the "EE License")
Copyright (c) 2025-present Sourcetool Inc.

With regard to the Sourcetool Software:

This software and associated documentation files (the "Software") may only be
used in production, if you (and any entity that you represent) have agreed to,
and are in compliance with, the Sourcetool Subscription Terms of Service, available
at https://trysourcetool.com/terms/#subscription (the "EE Terms"), or other
agreement governing the use of the Software, as agreed by you and Sourcetool,
and otherwise have a valid Sourcetool Enterprise Edition subscription for the
correct number of user seats. Subject to the foregoing sentence, you are free to
modify this Software and publish patches to the Software. You agree that Sourcetool
and/or its licensors (as applicable) retain all right, title and interest in and
to all such modifications and/or patches, and all such modifications and/or
patches may only be used, copied, modified, displayed, distributed, or otherwise
exploited with a valid Sourcetool Enterprise Edition subscription for the correct
number of user seats. Notwithstanding the foregoing, you may copy and modify
the Software for development and testing purposes, without requiring a
subscription. You agree that Sourcetool and/or its licensors (as applicable) retain
all right, title and interest in and to all such modifications. You are not
granted any other rights beyond what is expressly stated herein. Subject to the
foregoing, it is forbidden to copy, merge, publish, distribute, sublicense,
and/or sell the Software.

This EE License applies only to the part of this Software that is not
distributed as part of Sourcetool Community Edition (CE). Any part of this Software
distributed as part of Sourcetool CE or is served client-side as an image, font,
cascading stylesheet (CSS), file which produces or is compiled, arranged,
augmented, or combined into client-side JavaScript, in whole or in part, is
copyrighted under the Apache License 2.0. The full text of this EE License shall
be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

For all third party components incorporated into the Sourcetool Software, those
components are licensed under the original license provided by the owner of the
applicable component.
</file>

<file path="fixtures/fixtures.go">
package fixtures

import (
	"context"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

func Load(ctx context.Context, repo port.Repository) error {
	if !config.Config.IsCloudEdition {
		return nil
	}

	email := "john.doe@acme.com"
	exists, err := repo.User().IsEmailExists(ctx, email)
	if err != nil {
		return err
	}
	if exists {
		return nil
	}

	_, hashedRefreshToken, err := generateRefreshToken()
	if err != nil {
		return err
	}

	return repo.RunTransaction(func(tx port.Transaction) error {
		u := &user.User{
			ID:               uuid.Must(uuid.NewV4()),
			FirstName:        "John",
			LastName:         "Doe",
			Email:            email,
			RefreshTokenHash: hashedRefreshToken,
		}
		if err := tx.User().Create(ctx, u); err != nil {
			return err
		}

		o := &organization.Organization{
			ID:        uuid.Must(uuid.NewV4()),
			Subdomain: internal.NilValue("acme"),
		}
		if err := tx.Organization().Create(ctx, o); err != nil {
			return err
		}

		if err := tx.User().CreateOrganizationAccess(ctx, &user.UserOrganizationAccess{
			ID:             uuid.Must(uuid.NewV4()),
			UserID:         u.ID,
			OrganizationID: o.ID,
			Role:           user.UserOrganizationRoleAdmin,
		}); err != nil {
			return err
		}

		devEnv := &environment.Environment{
			ID:             uuid.Must(uuid.NewV4()),
			OrganizationID: o.ID,
			Name:           environment.EnvironmentNameDevelopment,
			Slug:           environment.EnvironmentSlugDevelopment,
			Color:          environment.EnvironmentColorDevelopment,
		}
		envs := []*environment.Environment{
			{
				ID:             uuid.Must(uuid.NewV4()),
				OrganizationID: o.ID,
				Name:           environment.EnvironmentNameProduction,
				Slug:           environment.EnvironmentSlugProduction,
				Color:          environment.EnvironmentColorProduction,
			},
			devEnv,
		}

		if err := tx.Environment().BulkInsert(ctx, envs); err != nil {
			return err
		}

		key, err := devEnv.GenerateAPIKey()
		if err != nil {
			return err
		}
		apiKey := &apikey.APIKey{
			ID:             uuid.Must(uuid.NewV4()),
			OrganizationID: o.ID,
			EnvironmentID:  devEnv.ID,
			UserID:         u.ID,
			Name:           "",
			Key:            key,
		}

		if err := tx.APIKey().Create(ctx, apiKey); err != nil {
			return err
		}

		return nil
	})
}

func generateRefreshToken() (plainRefreshToken, hashedRefreshToken string, err error) {
	randomBytes := make([]byte, 32)
	if _, err := rand.Read(randomBytes); err != nil {
		return "", "", err
	}

	plainRefreshToken = base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(randomBytes)

	hash := sha256.Sum256([]byte(plainRefreshToken))
	hashedRefreshToken = hex.EncodeToString(hash[:])

	return plainRefreshToken, hashedRefreshToken, nil
}
</file>

<file path="internal/app/apikey/service.go">
package apikey

import (
	"context"
	"errors"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/app/permission"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
	domainperm "github.com/trysourcetool/sourcetool/backend/internal/domain/permission"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type Service interface {
	Get(context.Context, dto.GetAPIKeyInput) (*dto.GetAPIKeyOutput, error)
	List(context.Context) (*dto.ListAPIKeysOutput, error)
	Create(context.Context, dto.CreateAPIKeyInput) (*dto.CreateAPIKeyOutput, error)
	Update(context.Context, dto.UpdateAPIKeyInput) (*dto.UpdateAPIKeyOutput, error)
	Delete(context.Context, dto.DeleteAPIKeyInput) (*dto.DeleteAPIKeyOutput, error)
}

type ServiceCE struct {
	*port.Dependencies
}

func NewServiceCE(d *port.Dependencies) *ServiceCE {
	return &ServiceCE{Dependencies: d}
}

func (s *ServiceCE) Get(ctx context.Context, in dto.GetAPIKeyInput) (*dto.GetAPIKeyOutput, error) {
	currentOrg := internal.CurrentOrganization(ctx)
	apiKeyID, err := uuid.FromString(in.APIKeyID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}
	apiKey, err := s.Repository.APIKey().Get(ctx, apikey.ByID(apiKeyID), apikey.ByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	env, err := s.Repository.Environment().Get(ctx, environment.ByID(apiKey.EnvironmentID))
	if err != nil {
		return nil, err
	}

	return &dto.GetAPIKeyOutput{
		APIKey: dto.APIKeyFromModel(apiKey, env),
	}, nil
}

func (s *ServiceCE) List(ctx context.Context) (*dto.ListAPIKeysOutput, error) {
	currentOrg := internal.CurrentOrganization(ctx)
	currentUser := internal.CurrentUser(ctx)

	envs, err := s.Repository.Environment().List(ctx, environment.ByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	var devEnv *environment.Environment
	var liveEnvs []*environment.Environment
	for _, env := range envs {
		if env.Slug == environment.EnvironmentSlugDevelopment {
			devEnv = env
		} else {
			liveEnvs = append(liveEnvs, env)
		}
	}

	devKey, err := s.Repository.APIKey().Get(ctx, apikey.ByOrganizationID(currentOrg.ID), apikey.ByEnvironmentID(devEnv.ID), apikey.ByUserID(currentUser.ID))
	if err != nil {
		return nil, err
	}

	liveEnvIDs := make([]uuid.UUID, 0, len(liveEnvs))
	for _, env := range liveEnvs {
		liveEnvIDs = append(liveEnvIDs, env.ID)
	}
	liveKeys, err := s.Repository.APIKey().List(ctx, apikey.ByOrganizationID(currentOrg.ID), apikey.ByEnvironmentIDs(liveEnvIDs))
	if err != nil {
		return nil, err
	}

	liveKeyIDs := make([]uuid.UUID, 0, len(liveKeys))
	for _, key := range liveKeys {
		liveKeyIDs = append(liveKeyIDs, key.ID)
	}

	environments, err := s.Repository.Environment().MapByAPIKeyIDs(ctx, liveKeyIDs)
	if err != nil {
		return nil, err
	}

	liveKeysOut := make([]*dto.APIKey, 0, len(liveKeys))
	for _, apiKey := range liveKeys {
		env, ok := environments[apiKey.ID]
		if !ok {
			return nil, errdefs.ErrEnvironmentNotFound(errors.New("environment not found"))
		}

		liveKeysOut = append(liveKeysOut, dto.APIKeyFromModel(apiKey, env))
	}

	return &dto.ListAPIKeysOutput{
		DevKey:   dto.APIKeyFromModel(devKey, devEnv),
		LiveKeys: liveKeysOut,
	}, nil
}

func (s *ServiceCE) Create(ctx context.Context, in dto.CreateAPIKeyInput) (*dto.CreateAPIKeyOutput, error) {
	currentOrg := internal.CurrentOrganization(ctx)

	envID, err := uuid.FromString(in.EnvironmentID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}
	env, err := s.Repository.Environment().Get(ctx, environment.ByID(envID))
	if err != nil {
		return nil, err
	}

	if env.Slug == environment.EnvironmentSlugDevelopment {
		return nil, errdefs.ErrInvalidArgument(errors.New("cannot create API key for development environment"))
	}

	checker := permission.NewChecker(s.Repository)
	if env.Slug == environment.EnvironmentSlugDevelopment {
		if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditDevModeAPIKey); err != nil {
			return nil, err
		}
	} else {
		if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditLiveModeAPIKey); err != nil {
			return nil, err
		}
	}

	key, err := env.GenerateAPIKey()
	if err != nil {
		return nil, errdefs.ErrInternal(err)
	}

	currentUser := internal.CurrentUser(ctx)
	apiKey := &apikey.APIKey{
		ID:             uuid.Must(uuid.NewV4()),
		OrganizationID: currentOrg.ID,
		EnvironmentID:  env.ID,
		UserID:         currentUser.ID,
		Name:           in.Name,
		Key:            key,
	}

	if err = s.Repository.RunTransaction(func(tx port.Transaction) error {
		return tx.APIKey().Create(ctx, apiKey)
	}); err != nil {
		return nil, err
	}

	apiKey, err = s.Repository.APIKey().Get(ctx, apikey.ByID(apiKey.ID))
	if err != nil {
		return nil, err
	}

	return &dto.CreateAPIKeyOutput{
		APIKey: dto.APIKeyFromModel(apiKey, nil),
	}, nil
}

func (s *ServiceCE) Update(ctx context.Context, in dto.UpdateAPIKeyInput) (*dto.UpdateAPIKeyOutput, error) {
	currentOrg := internal.CurrentOrganization(ctx)
	apiKeyID, err := uuid.FromString(in.APIKeyID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}

	apiKey, err := s.Repository.APIKey().Get(ctx, apikey.ByID(apiKeyID), apikey.ByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	env, err := s.Repository.Environment().Get(ctx, environment.ByID(apiKey.EnvironmentID))
	if err != nil {
		return nil, err
	}

	if env.Slug == environment.EnvironmentSlugDevelopment {
		return nil, errdefs.ErrInvalidArgument(errors.New("cannot update API key for development environment"))
	}

	checker := permission.NewChecker(s.Repository)
	if env.Slug == environment.EnvironmentSlugDevelopment {
		if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditDevModeAPIKey); err != nil {
			return nil, err
		}
	} else {
		if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditLiveModeAPIKey); err != nil {
			return nil, err
		}
	}

	if in.Name != nil {
		apiKey.Name = internal.SafeValue(in.Name)
	}

	if err = s.Repository.RunTransaction(func(tx port.Transaction) error {
		return tx.APIKey().Update(ctx, apiKey)
	}); err != nil {
		return nil, err
	}

	return &dto.UpdateAPIKeyOutput{
		APIKey: dto.APIKeyFromModel(apiKey, nil),
	}, nil
}

func (s *ServiceCE) Delete(ctx context.Context, in dto.DeleteAPIKeyInput) (*dto.DeleteAPIKeyOutput, error) {
	apiKeyID, err := uuid.FromString(in.APIKeyID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}
	apiKey, err := s.Repository.APIKey().Get(ctx, apikey.ByID(apiKeyID))
	if err != nil {
		return nil, err
	}

	env, err := s.Repository.Environment().Get(ctx, environment.ByID(apiKey.EnvironmentID))
	if err != nil {
		return nil, err
	}

	if env.Slug == environment.EnvironmentSlugDevelopment {
		return nil, errdefs.ErrInvalidArgument(errors.New("cannot delete API key for development environment"))
	}

	checker := permission.NewChecker(s.Repository)
	if env.Slug == environment.EnvironmentSlugDevelopment {
		if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditDevModeAPIKey); err != nil {
			return nil, err
		}
	} else {
		if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditLiveModeAPIKey); err != nil {
			return nil, err
		}
	}

	if err = s.Repository.RunTransaction(func(tx port.Transaction) error {
		return tx.APIKey().Delete(ctx, apiKey)
	}); err != nil {
		return nil, err
	}

	return &dto.DeleteAPIKeyOutput{
		APIKey: dto.APIKeyFromModel(apiKey, nil),
	}, nil
}
</file>

<file path="internal/app/auth/email.go">
package auth

import (
	"context"
	"fmt"
)

func (s *ServiceCE) sendMagicLinkEmail(ctx context.Context, email, firstName, url string) error {
	subject := "Log in to your Sourcetool account"

	content := fmt.Sprintf(`Hi %s,

Here's your magic link to log in to your Sourcetool account. Click the link below to access your account securely without a password:

%s

- This link will expire in 15 minutes for security reasons.
- If you didn't request this link, you can safely ignore this email.

Thank you for using Sourcetool!

The Sourcetool Team`, firstName, url)

	if err := s.Mailer.Send(ctx, []string{email}, "Sourcetool Team", subject, content); err != nil {
		return fmt.Errorf("failed to send email: %w", err)
	}

	return nil
}

func (s *ServiceCE) sendInvitationMagicLinkEmail(ctx context.Context, email, firstName, url string) error {
	subject := "Your invitation to join Sourcetool"

	content := fmt.Sprintf(`Hi %s,

You've been invited to join Sourcetool. Click the link below to accept the invitation:

%s

This link will expire in 15 minutes.

Best regards,
The Sourcetool Team`, firstName, url)

	if err := s.Mailer.Send(ctx, []string{email}, "Sourcetool Team", subject, content); err != nil {
		return fmt.Errorf("failed to send email: %w", err)
	}
	return nil
}

func (s *ServiceCE) sendMultipleOrganizationsMagicLinkEmail(ctx context.Context, email, firstName string, loginURLs []string) error {
	subject := "Choose your Sourcetool organization to log in"

	urlList := ""
	for _, url := range loginURLs {
		urlList += url + "\n"
	}

	content := fmt.Sprintf(`Hi %s,

Your email, %s, is associated with multiple Sourcetool organizations. You may log in to each one by clicking its magic link below:

%s

Thank you for using Sourcetool!

The Sourcetool Team`, firstName, email, urlList)

	if err := s.Mailer.Send(ctx, []string{email}, "Sourcetool Team", subject, content); err != nil {
		return fmt.Errorf("failed to send email: %w", err)
	}

	return nil
}

func (s *ServiceCE) sendMultipleOrganizationsLoginEmail(ctx context.Context, email, firstName string, loginURLs []string) error {
	subject := "Choose your Sourcetool organization to log in"

	urlList := ""
	for _, url := range loginURLs {
		urlList += url + "\n"
	}

	content := fmt.Sprintf(`Hi %s,

Your email, %s, is associated with multiple Sourcetool organizations. You may log in to each one by clicking its login link below:

%s

Thank you for using Sourcetool!

The Sourcetool Team`, firstName, email, urlList)

	if err := s.Mailer.Send(ctx, []string{email}, "Sourcetool Team", subject, content); err != nil {
		return fmt.Errorf("failed to send email: %w", err)
	}

	return nil
}
</file>

<file path="internal/app/auth/google.go">
package auth

import (
	"context"
	"time"

	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
	googleOAuth2 "google.golang.org/api/oauth2/v2"
	"google.golang.org/api/option"

	"github.com/trysourcetool/sourcetool/backend/config"
)

var oauthScopes = []string{
	"https://www.googleapis.com/auth/userinfo.email",
	"https://www.googleapis.com/auth/userinfo.profile",
}

const (
	googleOAuthCallbackPath = "/auth/google/callback"
)

type googleOAuthClient struct{}

func newGoogleOAuthClient() *googleOAuthClient {
	return &googleOAuthClient{}
}

type googleUserInfo struct {
	id         string
	email      string
	givenName  string
	familyName string
}

type googleToken struct {
	accessToken  string
	tokenType    string
	refreshToken string
	expiry       time.Time
}

func (c *googleOAuthClient) getGoogleAuthCodeURL(ctx context.Context, state string) (string, error) {
	redirectURL := config.Config.AuthBaseURL() + googleOAuthCallbackPath

	conf := &oauth2.Config{
		ClientID:     config.Config.Google.OAuth.ClientID,
		ClientSecret: config.Config.Google.OAuth.ClientSecret,
		RedirectURL:  redirectURL,
		Scopes:       oauthScopes,
		Endpoint:     google.Endpoint,
	}

	opts := []oauth2.AuthCodeOption{
		oauth2.ApprovalForce,
		oauth2.AccessTypeOffline,
	}

	return conf.AuthCodeURL(state, opts...), nil
}

func (c *googleOAuthClient) getGoogleToken(ctx context.Context, code string) (*googleToken, error) {
	redirectURL := config.Config.AuthBaseURL() + googleOAuthCallbackPath

	conf := &oauth2.Config{
		ClientID:     config.Config.Google.OAuth.ClientID,
		ClientSecret: config.Config.Google.OAuth.ClientSecret,
		RedirectURL:  redirectURL,
		Scopes:       oauthScopes,
		Endpoint:     google.Endpoint,
	}

	tok, err := conf.Exchange(ctx, code)
	if err != nil {
		return nil, err
	}

	return &googleToken{
		accessToken:  tok.AccessToken,
		tokenType:    tok.TokenType,
		refreshToken: tok.RefreshToken,
		expiry:       tok.Expiry,
	}, nil
}

func (c *googleOAuthClient) getGoogleUserInfo(ctx context.Context, tok *googleToken) (*googleUserInfo, error) {
	redirectURL := config.Config.AuthBaseURL() + googleOAuthCallbackPath

	conf := &oauth2.Config{
		ClientID:     config.Config.Google.OAuth.ClientID,
		ClientSecret: config.Config.Google.OAuth.ClientSecret,
		RedirectURL:  redirectURL,
		Scopes:       oauthScopes,
		Endpoint:     google.Endpoint,
	}

	source := conf.TokenSource(ctx, &oauth2.Token{
		AccessToken:  tok.accessToken,
		TokenType:    tok.tokenType,
		RefreshToken: tok.refreshToken,
		Expiry:       tok.expiry,
	})

	service, err := googleOAuth2.NewService(ctx, option.WithTokenSource(source))
	if err != nil {
		return nil, err
	}

	info, err := service.Userinfo.Get().Do()
	if err != nil {
		return nil, err
	}

	return &googleUserInfo{
		id:         info.Id,
		email:      info.Email,
		givenName:  info.GivenName,
		familyName: info.FamilyName,
	}, nil
}
</file>

<file path="internal/app/auth/service.go">
package auth

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/auth"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
	"github.com/trysourcetool/sourcetool/backend/internal/jwt"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type Service interface {
	// Passwordless Authentication methods
	RequestMagicLink(context.Context, dto.RequestMagicLinkInput) (*dto.RequestMagicLinkOutput, error)
	AuthenticateWithMagicLink(context.Context, dto.AuthenticateWithMagicLinkInput) (*dto.AuthenticateWithMagicLinkOutput, error)
	RegisterWithMagicLink(context.Context, dto.RegisterWithMagicLinkInput) (*dto.RegisterWithMagicLinkOutput, error)
	RequestInvitationMagicLink(context.Context, dto.RequestInvitationMagicLinkInput) (*dto.RequestInvitationMagicLinkOutput, error)
	AuthenticateWithInvitationMagicLink(context.Context, dto.AuthenticateWithInvitationMagicLinkInput) (*dto.AuthenticateWithInvitationMagicLinkOutput, error)
	RegisterWithInvitationMagicLink(context.Context, dto.RegisterWithInvitationMagicLinkInput) (*dto.RegisterWithInvitationMagicLinkOutput, error)

	// Google Authentication methods
	RequestGoogleAuthLink(context.Context) (*dto.RequestGoogleAuthLinkOutput, error)
	AuthenticateWithGoogle(context.Context, dto.AuthenticateWithGoogleInput) (*dto.AuthenticateWithGoogleOutput, error)
	RegisterWithGoogle(context.Context, dto.RegisterWithGoogleInput) (*dto.RegisterWithGoogleOutput, error)
	RequestInvitationGoogleAuthLink(context.Context, dto.RequestInvitationGoogleAuthLinkInput) (*dto.RequestInvitationGoogleAuthLinkOutput, error)

	// Authentication methods
	Logout(context.Context) (*dto.LogoutOutput, error)
	Save(context.Context, dto.SaveAuthInput) (*dto.SaveAuthOutput, error)
	RefreshToken(context.Context, dto.RefreshTokenInput) (*dto.RefreshTokenOutput, error)
	ObtainAuthToken(context.Context) (*dto.ObtainAuthTokenOutput, error)
}

type ServiceCE struct {
	*port.Dependencies
}

func NewServiceCE(d *port.Dependencies) *ServiceCE {
	return &ServiceCE{Dependencies: d}
}

func (s *ServiceCE) RequestMagicLink(ctx context.Context, in dto.RequestMagicLinkInput) (*dto.RequestMagicLinkOutput, error) {
	// Check if email exists
	exists, err := s.Repository.User().IsEmailExists(ctx, in.Email)
	if err != nil {
		return nil, err
	}

	var firstName string
	isNewUser := !exists

	// Handle Cloud Edition with subdomain
	if config.Config.IsCloudEdition {
		subdomain := internal.Subdomain(ctx)
		if subdomain != "" && subdomain != "auth" {
			// Get organization by subdomain
			org, err := s.Repository.Organization().Get(ctx, organization.BySubdomain(subdomain))
			if err != nil {
				return nil, err
			}

			if exists {
				// For existing users, check if they have access to this organization
				u, err := s.Repository.User().Get(ctx, user.ByEmail(in.Email))
				if err != nil {
					return nil, err
				}

				_, err = s.Repository.User().GetOrganizationAccess(ctx,
					user.OrganizationAccessByUserID(u.ID),
					user.OrganizationAccessByOrganizationID(org.ID))
				if err != nil {
					return nil, errdefs.ErrUnauthenticated(errors.New("user does not have access to this organization"))
				}
			} else {
				// For new users, registration is only allowed through invitations
				return nil, errdefs.ErrPermissionDenied(errors.New("registration is only allowed through invitations"))
			}
		}
	}

	if exists {
		// Get user by email for existing users
		u, err := s.Repository.User().Get(ctx, user.ByEmail(in.Email))
		if err != nil {
			return nil, err
		}
		firstName = u.FirstName

		// Get user's organization access information
		orgAccesses, err := s.Repository.User().ListOrganizationAccesses(ctx, user.OrganizationAccessByUserID(u.ID))
		if err != nil {
			return nil, err
		}

		// Cloud edition specific handling for multiple organizations
		if config.Config.IsCloudEdition && len(orgAccesses) > 1 {
			// Handle multiple organizations
			loginURLs := make([]string, 0, len(orgAccesses))
			for _, access := range orgAccesses {
				org, err := s.Repository.Organization().Get(ctx, organization.ByID(access.OrganizationID))
				if err != nil {
					return nil, err
				}

				// Create org-specific magic link
				tok, err := createMagicLinkToken(in.Email)
				if err != nil {
					return nil, err
				}

				url, err := buildMagicLinkURL(internal.SafeValue(org.Subdomain), tok)
				if err != nil {
					return nil, err
				}
				loginURLs = append(loginURLs, url)
			}

			if err := s.sendMultipleOrganizationsMagicLinkEmail(ctx, in.Email, firstName, loginURLs); err != nil {
				return nil, err
			}

			return &dto.RequestMagicLinkOutput{
				Email: in.Email,
				IsNew: false,
			}, nil
		}
	} else {
		// For new users, generate a temporary ID that will be verified/used later
		firstName = "there" // Default greeting

		// For self-hosted mode, check if creating an organization is allowed
		if !config.Config.IsCloudEdition {
			// Check if an organization already exists in self-hosted mode
			if err := s.validateSelfHostedOrganization(ctx); err != nil {
				return nil, err
			}
		}
	}

	// Determine subdomain context based on edition
	var subdomain string
	if config.Config.IsCloudEdition {
		subdomain = internal.Subdomain(ctx)
	}

	// Create token for magic link authentication
	tok, err := createMagicLinkToken(in.Email)
	if err != nil {
		return nil, err
	}

	// Build magic link URL
	url, err := buildMagicLinkURL(subdomain, tok)
	if err != nil {
		return nil, err
	}

	// Send magic link email
	if err := s.sendMagicLinkEmail(ctx, in.Email, firstName, url); err != nil {
		return nil, err
	}

	return &dto.RequestMagicLinkOutput{
		Email: in.Email,
		IsNew: isNewUser,
	}, nil
}

func (s *ServiceCE) AuthenticateWithMagicLink(ctx context.Context, in dto.AuthenticateWithMagicLinkInput) (*dto.AuthenticateWithMagicLinkOutput, error) {
	// Parse and validate token
	c, err := jwt.ParseToken[*jwt.UserEmailClaims](in.Token)
	if err != nil {
		return nil, err
	}

	if c.Subject != jwt.UserSignatureSubjectMagicLink {
		return nil, errdefs.ErrInvalidArgument(errors.New("invalid jwt subject"))
	}

	// Check if user exists
	exists, err := s.Repository.User().IsEmailExists(ctx, c.Email)
	if err != nil {
		return nil, err
	}

	if !exists {
		// Generate registration token for new user
		registrationToken, err := createMagicLinkRegistrationToken(c.Email)
		if err != nil {
			return nil, fmt.Errorf("failed to generate registration token: %w", err)
		}

		return &dto.AuthenticateWithMagicLinkOutput{
			Token:           registrationToken,
			IsNewUser:       true,
			HasOrganization: false,
		}, nil
	}

	// Get existing user
	u, err := s.Repository.User().Get(ctx, user.ByEmail(c.Email))
	if err != nil {
		return nil, err
	}

	// Get user's organization access information
	orgAccesses, err := s.Repository.User().ListOrganizationAccesses(ctx, user.OrganizationAccessByUserID(u.ID))
	if err != nil {
		return nil, err
	}

	// Handle organization subdomain logic
	subdomain := internal.Subdomain(ctx)
	var orgAccess *user.UserOrganizationAccess
	var orgSubdomain string

	if config.Config.IsCloudEdition {
		if subdomain != "auth" {
			// For specific organization subdomain, resolve org and access
			_, orgAccess, err = s.resolveOrganizationBySubdomain(ctx, u, subdomain)
			if err != nil {
				return nil, err
			}
			orgSubdomain = subdomain
		} else {
			// For auth subdomain
			if len(orgAccesses) == 0 {
				// No organization - sign in as a user not associated with any organization
			} else if len(orgAccesses) == 1 {
				// Single organization - redirect to it
				orgAccess = orgAccesses[0]
				org, err := s.Repository.Organization().Get(ctx, organization.ByID(orgAccess.OrganizationID))
				if err != nil {
					return nil, err
				}
				orgSubdomain = internal.SafeValue(org.Subdomain)
			} else {
				return nil, errdefs.ErrUserMultipleOrganizations(errors.New("user has multiple organizations"))
			}
		}
	} else {
		// Self-hosted mode has only one organization
		orgAccess = orgAccesses[0]
		_, err = s.Repository.Organization().Get(ctx, organization.ByID(orgAccess.OrganizationID))
		if err != nil {
			return nil, err
		}
	}

	// Create token, refresh token, etc.
	token, xsrfToken, plainRefreshToken, hashedRefreshToken, _, err := s.createTokens(
		u.ID, auth.TmpTokenExpiration)
	if err != nil {
		return nil, err
	}

	// Update user with new refresh token
	u.RefreshTokenHash = hashedRefreshToken
	authURL, err := buildSaveAuthURL(orgSubdomain)
	if err != nil {
		return nil, err
	}

	// Save changes
	if err = s.Repository.RunTransaction(func(tx port.Transaction) error {
		return tx.User().Update(ctx, u)
	}); err != nil {
		return nil, err
	}

	return &dto.AuthenticateWithMagicLinkOutput{
		AuthURL:         authURL,
		Token:           token,
		HasOrganization: orgAccess != nil,
		RefreshToken:    plainRefreshToken,
		XSRFToken:       xsrfToken,
		Domain:          config.Config.OrgDomain(orgSubdomain),
		IsNewUser:       false,
	}, nil
}

func (s *ServiceCE) RegisterWithMagicLink(ctx context.Context, in dto.RegisterWithMagicLinkInput) (*dto.RegisterWithMagicLinkOutput, error) {
	// Parse and validate the registration token
	claims, err := jwt.ParseToken[*jwt.UserMagicLinkRegistrationClaims](in.Token)
	if err != nil {
		return nil, err
	}

	if claims.Subject != jwt.UserSignatureSubjectMagicLinkRegistration {
		return nil, errdefs.ErrInvalidArgument(errors.New("invalid jwt subject"))
	}

	// Generate refresh token and XSRF token
	plainRefreshToken, hashedRefreshToken, err := generateRefreshToken()
	if err != nil {
		return nil, err
	}

	// Create a new user
	now := time.Now()
	u := &user.User{
		ID:               uuid.Must(uuid.NewV4()),
		Email:            claims.Email,
		FirstName:        in.FirstName,
		LastName:         in.LastName,
		RefreshTokenHash: hashedRefreshToken,
	}

	orgAccesses, err := s.Repository.User().ListOrganizationAccesses(ctx, user.OrganizationAccessByUserID(u.ID))
	if err != nil {
		return nil, err
	}
	hasOrganization := len(orgAccesses) > 0

	var token, xsrfToken string
	var expiration time.Duration
	// Create the user in a transaction
	err = s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.User().Create(ctx, u); err != nil {
			return err
		}

		expiration = auth.TmpTokenExpiration
		if !config.Config.IsCloudEdition {
			// For self-hosted, create initial organization
			if err := s.createInitialOrganizationForSelfHosted(ctx, tx, u); err != nil {
				return err
			}
			expiration = auth.TokenExpiration()
			hasOrganization = true
		}

		// Create token
		var err error
		token, xsrfToken, _, _, _, err = s.createTokens(u.ID, expiration)
		if err != nil {
			return err
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	return &dto.RegisterWithMagicLinkOutput{
		Token:           token,
		RefreshToken:    plainRefreshToken,
		XSRFToken:       xsrfToken,
		ExpiresAt:       strconv.FormatInt(now.Add(expiration).Unix(), 10),
		HasOrganization: hasOrganization,
	}, nil
}

// RequestInvitationMagicLink sends a magic link for invitation authentication.
func (s *ServiceCE) RequestInvitationMagicLink(ctx context.Context, in dto.RequestInvitationMagicLinkInput) (*dto.RequestInvitationMagicLinkOutput, error) {
	// Parse and validate invitation token
	c, err := jwt.ParseToken[*jwt.UserEmailClaims](in.InvitationToken)
	if err != nil {
		return nil, err
	}

	if c.Subject != jwt.UserSignatureSubjectInvitation {
		return nil, errdefs.ErrInvalidArgument(errors.New("invalid jwt subject"))
	}

	// Get invitation
	userInvitation, err := s.Repository.User().GetInvitation(ctx, user.InvitationByEmail(c.Email))
	if err != nil {
		return nil, err
	}

	// Get organization
	invitedOrg, err := s.Repository.Organization().Get(ctx, organization.ByID(userInvitation.OrganizationID))
	if err != nil {
		return nil, err
	}

	// Verify organization access in cloud edition
	if config.Config.IsCloudEdition {
		subdomain := internal.Subdomain(ctx)
		hostOrg, err := s.Repository.Organization().Get(ctx, organization.BySubdomain(subdomain))
		if err != nil {
			return nil, err
		}

		if invitedOrg.ID != hostOrg.ID {
			return nil, errdefs.ErrUnauthenticated(errors.New("invalid organization"))
		}
	}

	// Check if user exists
	exists, err := s.Repository.User().IsEmailExists(ctx, c.Email)
	if err != nil {
		return nil, err
	}

	// Create magic link token
	tok, err := createInvitationMagicLinkToken(c.Email)
	if err != nil {
		return nil, err
	}

	// Build magic link URL
	url, err := buildInvitationMagicLinkURL(internal.SafeValue(invitedOrg.Subdomain), tok)
	if err != nil {
		return nil, err
	}

	// Send magic link email
	if err := s.sendInvitationMagicLinkEmail(ctx, c.Email, "there", url); err != nil {
		return nil, err
	}

	return &dto.RequestInvitationMagicLinkOutput{
		Email: c.Email,
		IsNew: !exists,
	}, nil
}

// AuthenticateWithInvitationMagicLink authenticates a user with an invitation magic link.
func (s *ServiceCE) AuthenticateWithInvitationMagicLink(ctx context.Context, in dto.AuthenticateWithInvitationMagicLinkInput) (*dto.AuthenticateWithInvitationMagicLinkOutput, error) {
	// Parse and validate token
	c, err := jwt.ParseToken[*jwt.UserEmailClaims](in.Token)
	if err != nil {
		return nil, err
	}

	if c.Subject != jwt.UserSignatureSubjectInvitationMagicLink {
		return nil, errdefs.ErrInvalidArgument(errors.New("invalid jwt subject"))
	}

	// Get invitation
	userInvitation, err := s.Repository.User().GetInvitation(ctx, user.InvitationByEmail(c.Email))
	if err != nil {
		return nil, err
	}

	// Get organization
	invitedOrg, err := s.Repository.Organization().Get(ctx, organization.ByID(userInvitation.OrganizationID))
	if err != nil {
		return nil, err
	}

	// Verify organization access in cloud edition
	var orgSubdomain string
	if config.Config.IsCloudEdition {
		subdomain := internal.Subdomain(ctx)
		hostOrg, err := s.Repository.Organization().Get(ctx, organization.BySubdomain(subdomain))
		if err != nil {
			return nil, err
		}

		if invitedOrg.ID != hostOrg.ID {
			return nil, errdefs.ErrUnauthenticated(errors.New("invalid organization"))
		}

		orgSubdomain = internal.SafeValue(hostOrg.Subdomain)
	}

	// Check if user exists
	exists, err := s.Repository.User().IsEmailExists(ctx, c.Email)
	if err != nil {
		return nil, err
	}

	if !exists {
		// Generate registration token for new user
		registrationToken, err := createMagicLinkRegistrationToken(c.Email)
		if err != nil {
			return nil, fmt.Errorf("failed to generate registration token: %w", err)
		}

		return &dto.AuthenticateWithInvitationMagicLinkOutput{
			Token:     registrationToken,
			IsNewUser: true,
		}, nil
	}

	// Get existing user
	u, err := s.Repository.User().Get(ctx, user.ByEmail(c.Email))
	if err != nil {
		return nil, err
	}

	// Create organization access
	orgAccess := &user.UserOrganizationAccess{
		ID:             uuid.Must(uuid.NewV4()),
		UserID:         u.ID,
		OrganizationID: invitedOrg.ID,
		Role:           userInvitation.Role,
	}

	// Generate token and refresh token
	now := time.Now()
	expiresAt := now.Add(auth.TmpTokenExpiration)
	xsrfToken := uuid.Must(uuid.NewV4()).String()
	token, err := createAuthToken(u.ID.String(), xsrfToken, expiresAt, jwt.UserSignatureSubjectEmail)
	if err != nil {
		return nil, err
	}

	// Save changes
	if err = s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.User().DeleteInvitation(ctx, userInvitation); err != nil {
			return err
		}

		if err := tx.User().CreateOrganizationAccess(ctx, orgAccess); err != nil {
			return err
		}

		if err := s.createPersonalAPIKey(ctx, tx, u, invitedOrg); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	return &dto.AuthenticateWithInvitationMagicLinkOutput{
		AuthURL:   config.Config.OrgBaseURL(orgSubdomain) + auth.SaveAuthPath,
		Token:     token,
		Domain:    config.Config.OrgDomain(orgSubdomain),
		IsNewUser: false,
	}, nil
}

// RegisterWithInvitationMagicLink registers a new user with an invitation magic link.
func (s *ServiceCE) RegisterWithInvitationMagicLink(ctx context.Context, in dto.RegisterWithInvitationMagicLinkInput) (*dto.RegisterWithInvitationMagicLinkOutput, error) {
	// Parse and validate token
	c, err := jwt.ParseToken[*jwt.UserEmailClaims](in.Token)
	if err != nil {
		return nil, err
	}

	if c.Subject != jwt.UserSignatureSubjectMagicLinkRegistration {
		return nil, errdefs.ErrInvalidArgument(errors.New("invalid jwt subject"))
	}

	// Get invitation
	userInvitation, err := s.Repository.User().GetInvitation(ctx, user.InvitationByEmail(c.Email))
	if err != nil {
		return nil, err
	}

	// Get organization
	invitedOrg, err := s.Repository.Organization().Get(ctx, organization.ByID(userInvitation.OrganizationID))
	if err != nil {
		return nil, err
	}

	// Verify organization access in cloud edition
	var orgSubdomain string
	if config.Config.IsCloudEdition {
		subdomain := internal.Subdomain(ctx)
		hostOrg, err := s.Repository.Organization().Get(ctx, organization.BySubdomain(subdomain))
		if err != nil {
			return nil, err
		}

		if invitedOrg.ID != hostOrg.ID {
			return nil, errdefs.ErrUnauthenticated(errors.New("invalid organization"))
		}

		orgSubdomain = internal.SafeValue(hostOrg.Subdomain)
	}

	// Generate refresh token
	plainRefreshToken, hashedRefreshToken, err := generateRefreshToken()
	if err != nil {
		return nil, errdefs.ErrInternal(err)
	}

	// Create new user
	now := time.Now()
	expiresAt := now.Add(auth.TokenExpiration())
	u := &user.User{
		ID:               uuid.Must(uuid.NewV4()),
		FirstName:        in.FirstName,
		LastName:         in.LastName,
		Email:            c.Email,
		RefreshTokenHash: hashedRefreshToken,
	}

	// Create organization access
	orgAccess := &user.UserOrganizationAccess{
		ID:             uuid.Must(uuid.NewV4()),
		UserID:         u.ID,
		OrganizationID: invitedOrg.ID,
		Role:           userInvitation.Role,
	}

	// Generate token
	xsrfToken := uuid.Must(uuid.NewV4()).String()
	token, err := createAuthToken(u.ID.String(), xsrfToken, expiresAt, jwt.UserSignatureSubjectEmail)
	if err != nil {
		return nil, err
	}

	// Save changes
	if err = s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.User().DeleteInvitation(ctx, userInvitation); err != nil {
			return err
		}

		if err := tx.User().Create(ctx, u); err != nil {
			return err
		}

		if err := tx.User().CreateOrganizationAccess(ctx, orgAccess); err != nil {
			return err
		}

		if err := s.createPersonalAPIKey(ctx, tx, u, invitedOrg); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	return &dto.RegisterWithInvitationMagicLinkOutput{
		Token:        token,
		RefreshToken: plainRefreshToken,
		XSRFToken:    xsrfToken,
		ExpiresAt:    strconv.FormatInt(expiresAt.Unix(), 10),
		Domain:       config.Config.OrgDomain(orgSubdomain),
	}, nil
}

// RequestGoogleAuthLink sends a Google Auth link for invitation authentication.
func (s *ServiceCE) RequestGoogleAuthLink(ctx context.Context) (*dto.RequestGoogleAuthLinkOutput, error) {
	var hostSubdomain string
	if config.Config.IsCloudEdition {
		subdomain := internal.Subdomain(ctx)
		if subdomain != "auth" {
			hostSubdomain = subdomain
		}
	}

	stateToken, err := createGoogleAuthLinkToken(
		jwt.GoogleAuthFlowStandard,
		uuid.Nil,
		hostSubdomain,
	)
	if err != nil {
		return nil, err
	}

	googleOAuthClient := newGoogleOAuthClient()
	url, err := googleOAuthClient.getGoogleAuthCodeURL(ctx, stateToken)
	if err != nil {
		return nil, err
	}

	return &dto.RequestGoogleAuthLinkOutput{
		AuthURL: url,
	}, nil
}

func (s *ServiceCE) AuthenticateWithGoogle(ctx context.Context, in dto.AuthenticateWithGoogleInput) (*dto.AuthenticateWithGoogleOutput, error) {
	// Parse and validate state token
	stateClaims, err := jwt.ParseToken[*jwt.UserGoogleAuthLinkClaims](in.State)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}

	if stateClaims.Subject != jwt.UserSignatureSubjectGoogleAuthLink {
		return nil, errdefs.ErrInvalidArgument(errors.New("invalid jwt subject"))
	}

	// Get Google token and user info
	googleOAuthClient := newGoogleOAuthClient()
	tok, err := googleOAuthClient.getGoogleToken(ctx, in.Code)
	if err != nil {
		return nil, err
	}

	userInfo, err := googleOAuthClient.getGoogleUserInfo(ctx, tok)
	if err != nil {
		return nil, err
	}

	// In staging environment, only allow @trysourcetool.com email addresses
	if config.Config.Env == config.EnvStaging && !strings.HasSuffix(userInfo.email, "@trysourcetool.com") {
		return nil, errdefs.ErrPermissionDenied(errors.New("access restricted in staging environment"))
	}

	// Check if user exists
	exists, err := s.Repository.User().IsEmailExists(ctx, userInfo.email)
	if err != nil {
		return nil, err
	}

	if !exists {
		if !config.Config.IsCloudEdition && stateClaims.Flow == jwt.GoogleAuthFlowStandard {
			if err := s.validateSelfHostedOrganization(ctx); err != nil {
				return nil, err
			}
		}

		var role string
		if stateClaims.Flow == jwt.GoogleAuthFlowInvitation {
			// Verify invitation exists
			userInvitation, err := s.Repository.User().GetInvitation(ctx, user.InvitationByEmail(userInfo.email), user.InvitationByOrganizationID(stateClaims.InvitationOrgID))
			if err != nil {
				return nil, errdefs.ErrInvalidArgument(errors.New("invalid invitation"))
			}
			role = userInvitation.Role.String()
		}

		// Generate registration token with flow info
		registrationToken, err := createGoogleRegistrationToken(
			userInfo.id,
			userInfo.email,
			userInfo.givenName,
			userInfo.familyName,
			stateClaims.Flow,
			stateClaims.InvitationOrgID,
			role,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to create registration token: %w", err)
		}

		return &dto.AuthenticateWithGoogleOutput{
			Token:           registrationToken,
			IsNewUser:       true,
			HasOrganization: stateClaims.Flow == jwt.GoogleAuthFlowInvitation,
			Flow:            string(stateClaims.Flow),
			FirstName:       userInfo.givenName,
			LastName:        userInfo.familyName,
		}, nil
	}

	// For existing users
	u, err := s.Repository.User().Get(ctx, user.ByEmail(userInfo.email))
	if err != nil {
		return nil, errdefs.ErrUnauthenticated(err)
	}

	needsGoogleIDUpdate := u.GoogleID == ""

	var org *organization.Organization
	var orgAccess *user.UserOrganizationAccess
	var orgSubdomain string

	if stateClaims.Flow == jwt.GoogleAuthFlowInvitation {
		// Handle invitation flow for existing users
		invitedOrg, err := s.Repository.Organization().Get(ctx, organization.ByID(stateClaims.InvitationOrgID))
		if err != nil {
			return nil, fmt.Errorf("failed to get invited organization: %w", err)
		}

		userInvitation, err := s.Repository.User().GetInvitation(ctx,
			user.InvitationByEmail(userInfo.email),
			user.InvitationByOrganizationID(stateClaims.InvitationOrgID))
		if err != nil {
			return nil, errdefs.ErrInvalidArgument(errors.New("invalid invitation"))
		}

		orgAccess = &user.UserOrganizationAccess{
			ID:             uuid.Must(uuid.NewV4()),
			UserID:         u.ID,
			OrganizationID: invitedOrg.ID,
			Role:           userInvitation.Role,
		}
		org = invitedOrg
		orgSubdomain = internal.SafeValue(invitedOrg.Subdomain)
	} else {
		// Standard flow - get user's organization info
		// Get all organization accesses for the user
		orgAccesses, err := s.Repository.User().ListOrganizationAccesses(ctx, user.OrganizationAccessByUserID(u.ID))
		if err != nil {
			return nil, err
		}

		if config.Config.IsCloudEdition {
			if len(orgAccesses) > 1 {
				hostSubdomain := stateClaims.HostSubdomain
				if hostSubdomain == "" {
					// Handle multiple organizations by sending email with login URLs
					loginURLs := make([]string, 0, len(orgAccesses))
					for _, access := range orgAccesses {
						org, err := s.Repository.Organization().Get(ctx, organization.ByID(access.OrganizationID))
						if err != nil {
							return nil, err
						}

						url, err := buildLoginURL(internal.SafeValue(org.Subdomain))
						if err != nil {
							return nil, err
						}
						loginURLs = append(loginURLs, url)
					}

					// Send email with multiple organization links
					if err := s.sendMultipleOrganizationsLoginEmail(ctx, u.Email, u.FirstName, loginURLs); err != nil {
						return nil, err
					}

					return &dto.AuthenticateWithGoogleOutput{
						IsNewUser:                false,
						HasOrganization:          true,
						HasMultipleOrganizations: true,
						Flow:                     string(stateClaims.Flow),
					}, nil
				} else {
					org, err = s.Repository.Organization().Get(ctx, organization.BySubdomain(hostSubdomain))
					if err != nil {
						return nil, err
					}
					orgAccess, err = s.Repository.User().GetOrganizationAccess(ctx,
						user.OrganizationAccessByUserID(u.ID),
						user.OrganizationAccessByOrganizationID(org.ID),
					)
					if err != nil {
						return nil, err
					}
					orgSubdomain = internal.SafeValue(org.Subdomain)
				}
			} else {
				// Single organization case
				orgAccess = orgAccesses[0]

				org, err = s.Repository.Organization().Get(ctx, organization.ByID(orgAccess.OrganizationID))
				if err != nil {
					return nil, err
				}
				orgSubdomain = internal.SafeValue(org.Subdomain)
			}
		} else {
			// Self-hosted mode
			orgAccess = orgAccesses[0]
			org, err = s.Repository.Organization().Get(ctx, organization.ByID(orgAccess.OrganizationID))
			if err != nil {
				return nil, err
			}
		}
	}

	// Generate temporary auth tokens
	token, xsrfToken, plainRefreshToken, hashedRefreshToken, _, err := s.createTokens(u.ID, auth.TmpTokenExpiration)
	if err != nil {
		return nil, err
	}

	u.RefreshTokenHash = hashedRefreshToken
	if needsGoogleIDUpdate {
		u.GoogleID = userInfo.id
	}

	authURL, err := buildSaveAuthURL(orgSubdomain)
	if err != nil {
		return nil, err
	}

	if err = s.Repository.RunTransaction(func(tx port.Transaction) error {
		if stateClaims.Flow == jwt.GoogleAuthFlowInvitation {
			// For invitation flow, create org access and delete invitation
			userInvitation, err := s.Repository.User().GetInvitation(ctx,
				user.InvitationByEmail(userInfo.email),
				user.InvitationByOrganizationID(stateClaims.InvitationOrgID))
			if err != nil {
				return err
			}
			if err := tx.User().DeleteInvitation(ctx, userInvitation); err != nil {
				return err
			}
			if err := tx.User().CreateOrganizationAccess(ctx, orgAccess); err != nil {
				return err
			}
			if err := s.createPersonalAPIKey(ctx, tx, u, org); err != nil {
				return err
			}
		}
		return tx.User().Update(ctx, u)
	}); err != nil {
		return nil, err
	}

	return &dto.AuthenticateWithGoogleOutput{
		AuthURL:         authURL,
		Token:           token,
		HasOrganization: orgAccess != nil,
		RefreshToken:    plainRefreshToken,
		XSRFToken:       xsrfToken,
		Domain:          config.Config.OrgDomain(orgSubdomain),
		IsNewUser:       false,
		Flow:            string(stateClaims.Flow),
	}, nil
}

// RegisterWithGoogle registers a new user based on the token received after Google OAuth confirmation.
func (s *ServiceCE) RegisterWithGoogle(ctx context.Context, in dto.RegisterWithGoogleInput) (*dto.RegisterWithGoogleOutput, error) {
	// Parse and validate registration token
	claims, err := jwt.ParseToken[*jwt.UserGoogleRegistrationClaims](in.Token)
	if err != nil {
		return nil, fmt.Errorf("invalid registration token: %w", err)
	}
	if claims.Subject != jwt.UserSignatureSubjectGoogleRegistration {
		return nil, errdefs.ErrInvalidArgument(errors.New("invalid jwt subject for google registration"))
	}

	// Check if user already exists
	exists, err := s.Repository.User().IsEmailExists(ctx, claims.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to check user existence: %w", err)
	}
	if exists {
		return nil, errdefs.ErrUserEmailAlreadyExists(fmt.Errorf("user with email %s already exists", claims.Email))
	}

	plainRefreshToken, hashedRefreshToken, err := generateRefreshToken()
	if err != nil {
		return nil, fmt.Errorf("failed to generate refresh token: %w", err)
	}

	now := time.Now()
	tokenExpiration := auth.TokenExpiration()
	expiresAt := now.Add(tokenExpiration)
	u := &user.User{
		ID:               uuid.Must(uuid.NewV4()),
		Email:            claims.Email,
		FirstName:        claims.FirstName,
		LastName:         claims.LastName,
		RefreshTokenHash: hashedRefreshToken,
		GoogleID:         claims.GoogleID,
	}

	var token, xsrfToken string
	var orgSubdomain string
	var authURL string
	var hasOrganization bool
	err = s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.User().Create(ctx, u); err != nil {
			return fmt.Errorf("failed to create user: %w", err)
		}

		if claims.Flow == jwt.GoogleAuthFlowInvitation {
			invitedOrg, err := s.Repository.Organization().Get(ctx, organization.ByID(claims.InvitationOrgID))
			if err != nil {
				return fmt.Errorf("failed to get invited organization: %w", err)
			}

			userInvitation, err := s.Repository.User().GetInvitation(ctx,
				user.InvitationByEmail(claims.Email),
				user.InvitationByOrganizationID(claims.InvitationOrgID))
			if err != nil {
				return fmt.Errorf("failed to get invitation: %w", err)
			}

			orgAccess := &user.UserOrganizationAccess{
				ID:             uuid.Must(uuid.NewV4()),
				UserID:         u.ID,
				OrganizationID: claims.InvitationOrgID,
				Role:           user.UserOrganizationRoleFromString(claims.Role),
			}

			if err := tx.User().DeleteInvitation(ctx, userInvitation); err != nil {
				return fmt.Errorf("failed to delete invitation: %w", err)
			}

			if err := tx.User().CreateOrganizationAccess(ctx, orgAccess); err != nil {
				return fmt.Errorf("failed to create organization access: %w", err)
			}

			if err := s.createPersonalAPIKey(ctx, tx, u, invitedOrg); err != nil {
				return fmt.Errorf("failed to create personal API key: %w", err)
			}

			orgSubdomain = internal.SafeValue(invitedOrg.Subdomain)
			hasOrganization = true
		} else {
			if !config.Config.IsCloudEdition {
				if err := s.createInitialOrganizationForSelfHosted(ctx, tx, u); err != nil {
					return fmt.Errorf("failed to create initial organization: %w", err)
				}
				hasOrganization = true
			}
		}

		var err error
		token, xsrfToken, _, _, _, err = s.createTokens(u.ID, tokenExpiration)
		if err != nil {
			return fmt.Errorf("failed to create auth token: %w", err)
		}

		if hasOrganization {
			authURL, err = buildSaveAuthURL(orgSubdomain)
			if err != nil {
				return err
			}
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	return &dto.RegisterWithGoogleOutput{
		Token:           token,
		RefreshToken:    plainRefreshToken,
		XSRFToken:       xsrfToken,
		ExpiresAt:       strconv.FormatInt(expiresAt.Unix(), 10),
		AuthURL:         authURL,
		HasOrganization: hasOrganization,
	}, nil
}

// RequestInvitationGoogleAuthLink prepares the Google OAuth URL for an invited user.
func (s *ServiceCE) RequestInvitationGoogleAuthLink(ctx context.Context, in dto.RequestInvitationGoogleAuthLinkInput) (*dto.RequestInvitationGoogleAuthLinkOutput, error) {
	c, err := jwt.ParseToken[*jwt.UserEmailClaims](in.InvitationToken)
	if err != nil {
		return nil, fmt.Errorf("invalid invitation token: %w", err)
	}
	if c.Subject != jwt.UserSignatureSubjectInvitation {
		return nil, errdefs.ErrInvalidArgument(errors.New("invalid jwt subject for invitation"))
	}

	userInvitation, err := s.Repository.User().GetInvitation(ctx, user.InvitationByEmail(c.Email))
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve invitation: %w", err)
	}

	invitedOrg, err := s.Repository.Organization().Get(ctx, organization.ByID(userInvitation.OrganizationID))
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve invited organization: %w", err)
	}

	if config.Config.IsCloudEdition {
		subdomain := internal.Subdomain(ctx)
		if subdomain == "" || subdomain == "auth" {
			return nil, errdefs.ErrInvalidArgument(errors.New("invitation must be accessed via organization subdomain"))
		}
		hostOrg, err := s.Repository.Organization().Get(ctx, organization.BySubdomain(subdomain))
		if err != nil {
			return nil, fmt.Errorf("failed to retrieve host organization: %w", err)
		}
		if invitedOrg.ID != hostOrg.ID {
			return nil, errdefs.ErrUnauthenticated(errors.New("invitation organization mismatch"))
		}
	}

	var hostSubdomain string
	if config.Config.IsCloudEdition {
		hostSubdomain = internal.Subdomain(ctx)
	}

	stateToken, err := createGoogleAuthLinkToken(
		jwt.GoogleAuthFlowInvitation,
		invitedOrg.ID,
		hostSubdomain,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create state token: %w", err)
	}

	googleOAuthClient := newGoogleOAuthClient()
	url, err := googleOAuthClient.getGoogleAuthCodeURL(ctx, stateToken)
	if err != nil {
		return nil, fmt.Errorf("failed to get google auth code url: %w", err)
	}

	return &dto.RequestInvitationGoogleAuthLinkOutput{
		AuthURL: url,
	}, nil
}

func (s *ServiceCE) RefreshToken(ctx context.Context, in dto.RefreshTokenInput) (*dto.RefreshTokenOutput, error) {
	// Validate XSRF token consistency
	if in.XSRFTokenCookie != in.XSRFTokenHeader {
		return nil, errdefs.ErrUnauthenticated(errors.New("invalid xsrf token"))
	}

	// Get user by refresh token
	hashedRefreshToken := hashRefreshToken(in.RefreshToken)
	u, err := s.Repository.User().Get(ctx, user.ByRefreshTokenHash(hashedRefreshToken))
	if err != nil {
		return nil, errdefs.ErrUnauthenticated(err)
	}

	// Get current subdomain and resolve organization
	subdomain := internal.Subdomain(ctx)
	var orgSubdomain string

	if config.Config.IsCloudEdition {
		if subdomain != "auth" {
			// Verify user has access to this organization
			_, _, err = s.resolveOrganizationBySubdomain(ctx, u, subdomain)
			if err != nil {
				return nil, err
			}
			orgSubdomain = subdomain
		} else {
			// For auth subdomain, use default
			orgSubdomain = "auth"
		}
	} else {
		// For self-hosted, no specific subdomain needed
		orgSubdomain = ""
	}

	// Generate token and set expiration
	now := time.Now()
	expiresAt := now.Add(auth.TokenExpiration())
	xsrfToken := uuid.Must(uuid.NewV4()).String()
	token, err := createAuthToken(u.ID.String(), xsrfToken, expiresAt, jwt.UserSignatureSubjectEmail)
	if err != nil {
		return nil, errdefs.ErrInternal(err)
	}

	return &dto.RefreshTokenOutput{
		Token:        token,
		RefreshToken: in.RefreshToken,
		XSRFToken:    xsrfToken,
		ExpiresAt:    strconv.FormatInt(expiresAt.Unix(), 10),
		Domain:       config.Config.OrgDomain(orgSubdomain),
	}, nil
}

func (s *ServiceCE) Logout(ctx context.Context) (*dto.LogoutOutput, error) {
	u := internal.CurrentUser(ctx)

	orgAccessOpts := []user.OrganizationAccessQuery{
		user.OrganizationAccessByUserID(u.ID),
	}

	var subdomain string
	if config.Config.IsCloudEdition {
		subdomain = internal.Subdomain(ctx)
		orgAccessOpts = append(orgAccessOpts, user.OrganizationAccessByOrganizationSubdomain(subdomain))
	}
	_, err := s.Repository.User().GetOrganizationAccess(ctx, orgAccessOpts...)
	if err != nil {
		return nil, err
	}

	return &dto.LogoutOutput{
		Domain: config.Config.OrgDomain(subdomain),
	}, nil
}

func (s *ServiceCE) Save(ctx context.Context, in dto.SaveAuthInput) (*dto.SaveAuthOutput, error) {
	// Parse and validate token
	c, err := jwt.ParseToken[*jwt.UserAuthClaims](in.Token)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.FromString(c.UserID)
	if err != nil {
		return nil, err
	}

	// Get user by ID
	u, err := s.Repository.User().Get(ctx, user.ByID(userID))
	if err != nil {
		return nil, err
	}

	// Get current subdomain and verify organization access
	subdomain := internal.Subdomain(ctx)
	var orgSubdomain string

	if config.Config.IsCloudEdition {
		if subdomain != "auth" {
			// For specific organization subdomain, verify user has access
			_, _, err = s.resolveOrganizationBySubdomain(ctx, u, subdomain)
			if err != nil {
				return nil, err
			}
			orgSubdomain = subdomain
		} else {
			// For auth subdomain, use default
			orgSubdomain = "auth"
		}
	}

	// Generate token and refresh token
	now := time.Now()
	expiresAt := now.Add(auth.TokenExpiration())
	xsrfToken := uuid.Must(uuid.NewV4()).String()
	token, err := createAuthToken(u.ID.String(), xsrfToken, expiresAt, jwt.UserSignatureSubjectEmail)
	if err != nil {
		return nil, errdefs.ErrInternal(err)
	}

	plainRefreshToken, hashedRefreshToken, err := generateRefreshToken()
	if err != nil {
		return nil, errdefs.ErrInternal(err)
	}

	// Update user's refresh token
	u.RefreshTokenHash = hashedRefreshToken

	// Save changes
	if err = s.Repository.RunTransaction(func(tx port.Transaction) error {
		return tx.User().Update(ctx, u)
	}); err != nil {
		return nil, err
	}

	return &dto.SaveAuthOutput{
		Token:        token,
		RefreshToken: plainRefreshToken,
		XSRFToken:    xsrfToken,
		ExpiresAt:    strconv.FormatInt(expiresAt.Unix(), 10),
		RedirectURL:  config.Config.OrgBaseURL(orgSubdomain),
		Domain:       config.Config.OrgDomain(orgSubdomain),
	}, nil
}

func (s *ServiceCE) ObtainAuthToken(ctx context.Context) (*dto.ObtainAuthTokenOutput, error) {
	// Get current user from context
	u := internal.CurrentUser(ctx)
	if u == nil {
		return nil, errdefs.ErrUnauthenticated(errors.New("no user in context"))
	}

	// Get user's organization info
	org, _, err := s.getUserOrganizationInfo(ctx)
	if err != nil {
		return nil, err
	}

	// Generate temporary token
	now := time.Now()
	expiresAt := now.Add(auth.TmpTokenExpiration)
	xsrfToken := uuid.Must(uuid.NewV4()).String()
	token, err := createAuthToken(u.ID.String(), xsrfToken, expiresAt, jwt.UserSignatureSubjectEmail)
	if err != nil {
		return nil, err
	}

	// Build auth URL with organization subdomain
	authURL, err := buildSaveAuthURL(internal.SafeValue(org.Subdomain))
	if err != nil {
		return nil, err
	}

	// Update user
	if err = s.Repository.RunTransaction(func(tx port.Transaction) error {
		return tx.User().Update(ctx, u)
	}); err != nil {
		return nil, err
	}

	return &dto.ObtainAuthTokenOutput{
		AuthURL: authURL,
		Token:   token,
	}, nil
}

func (s *ServiceCE) createPersonalAPIKey(ctx context.Context, tx port.Transaction, u *user.User, org *organization.Organization) error {
	devEnv, err := s.Repository.Environment().Get(ctx, environment.ByOrganizationID(org.ID), environment.BySlug(environment.EnvironmentSlugDevelopment))
	if err != nil {
		return err
	}

	key, err := devEnv.GenerateAPIKey()
	if err != nil {
		return err
	}

	apiKey := &apikey.APIKey{
		ID:             uuid.Must(uuid.NewV4()),
		OrganizationID: org.ID,
		EnvironmentID:  devEnv.ID,
		UserID:         u.ID,
		Name:           "",
		Key:            key,
	}

	return tx.APIKey().Create(ctx, apiKey)
}

// createTokens creates a new authentication token and refresh token.
func (s *ServiceCE) createTokens(userID uuid.UUID, expiration time.Duration) (token, xsrfToken, plainRefreshToken, hashedRefreshToken string, expiresAt time.Time, err error) {
	now := time.Now()
	expiresAt = now.Add(expiration)
	xsrfToken = uuid.Must(uuid.NewV4()).String()

	token, err = createAuthToken(userID.String(), xsrfToken, expiresAt, jwt.UserSignatureSubjectEmail)
	if err != nil {
		return "", "", "", "", time.Time{}, err
	}

	plainRefreshToken, hashedRefreshToken, err = generateRefreshToken()
	if err != nil {
		return "", "", "", "", time.Time{}, errdefs.ErrInternal(err)
	}

	return token, xsrfToken, plainRefreshToken, hashedRefreshToken, expiresAt, nil
}

// resolveOrganizationBySubdomain gets an organization by subdomain and verifies the user has access.
// Deprecated: Use getOrganizationBySubdomain instead.
func (s *ServiceCE) resolveOrganizationBySubdomain(ctx context.Context, u *user.User, subdomain string) (*organization.Organization, *user.UserOrganizationAccess, error) {
	if subdomain == "" {
		return nil, nil, errdefs.ErrInvalidArgument(errors.New("subdomain cannot be empty"))
	}

	return s.getOrganizationBySubdomain(ctx, u, subdomain)
}

// validateSelfHostedOrganization checks if creating a new organization is allowed in self-hosted mode.
func (s *ServiceCE) validateSelfHostedOrganization(ctx context.Context) error {
	if !config.Config.IsCloudEdition {
		// In self-hosted mode, check if an organization already exists
		if _, err := s.Repository.Organization().Get(ctx); err == nil {
			return errdefs.ErrPermissionDenied(errors.New("only one organization is allowed in self-hosted edition"))
		}
	}
	return nil
}

func (s *ServiceCE) createInitialOrganizationForSelfHosted(ctx context.Context, tx port.Transaction, u *user.User) error {
	if config.Config.IsCloudEdition {
		return nil
	}

	org := &organization.Organization{
		ID:        uuid.Must(uuid.NewV4()),
		Subdomain: nil, // Empty subdomain for non-cloud edition
	}
	if err := tx.Organization().Create(ctx, org); err != nil {
		return err
	}

	orgAccess := &user.UserOrganizationAccess{
		ID:             uuid.Must(uuid.NewV4()),
		UserID:         u.ID,
		OrganizationID: org.ID,
		Role:           user.UserOrganizationRoleAdmin,
	}
	if err := tx.User().CreateOrganizationAccess(ctx, orgAccess); err != nil {
		return err
	}

	devEnv := &environment.Environment{
		ID:             uuid.Must(uuid.NewV4()),
		OrganizationID: org.ID,
		Name:           environment.EnvironmentNameDevelopment,
		Slug:           environment.EnvironmentSlugDevelopment,
		Color:          environment.EnvironmentColorDevelopment,
	}
	envs := []*environment.Environment{
		{
			ID:             uuid.Must(uuid.NewV4()),
			OrganizationID: org.ID,
			Name:           environment.EnvironmentNameProduction,
			Slug:           environment.EnvironmentSlugProduction,
			Color:          environment.EnvironmentColorProduction,
		},
		devEnv,
	}
	if err := tx.Environment().BulkInsert(ctx, envs); err != nil {
		return err
	}

	key, err := devEnv.GenerateAPIKey()
	if err != nil {
		return err
	}
	apiKey := &apikey.APIKey{
		ID:             uuid.Must(uuid.NewV4()),
		OrganizationID: org.ID,
		EnvironmentID:  devEnv.ID,
		UserID:         u.ID,
		Name:           "",
		Key:            key,
	}
	if err := tx.APIKey().Create(ctx, apiKey); err != nil {
		return err
	}

	return nil
}

// getUserOrganizationInfo is a convenience wrapper that retrieves organization
// and access information for the current user from the context.
func (s *ServiceCE) getUserOrganizationInfo(ctx context.Context) (*organization.Organization, *user.UserOrganizationAccess, error) {
	return s.getOrganizationInfo(ctx, internal.CurrentUser(ctx))
}

// getOrganizationBySubdomain retrieves an organization by subdomain and verifies user access.
func (s *ServiceCE) getOrganizationBySubdomain(ctx context.Context, u *user.User, subdomain string) (*organization.Organization, *user.UserOrganizationAccess, error) {
	// Get organization by subdomain
	org, err := s.Repository.Organization().Get(ctx, organization.BySubdomain(subdomain))
	if err != nil {
		return nil, nil, err
	}

	// Verify user has access to this organization
	orgAccess, err := s.Repository.User().GetOrganizationAccess(ctx,
		user.OrganizationAccessByOrganizationID(org.ID),
		user.OrganizationAccessByUserID(u.ID))
	if err != nil {
		return nil, nil, err
	}

	return org, orgAccess, nil
}

// getOrganizationInfo retrieves organization and access information for the specified user.
// It handles both cloud and self-hosted editions with appropriate subdomain logic.
func (s *ServiceCE) getOrganizationInfo(ctx context.Context, u *user.User) (*organization.Organization, *user.UserOrganizationAccess, error) {
	if u == nil {
		return nil, nil, errdefs.ErrInvalidArgument(errors.New("user cannot be nil"))
	}

	subdomain := internal.Subdomain(ctx)
	isCloudWithSubdomain := config.Config.IsCloudEdition && subdomain != "" && subdomain != "auth"

	// Different strategies for cloud vs. self-hosted or auth subdomain
	if isCloudWithSubdomain {
		return s.getOrganizationBySubdomain(ctx, u, subdomain)
	}

	return s.getDefaultOrganizationForUser(ctx, u)
}

// (typically the most recently created one).
func (s *ServiceCE) getDefaultOrganizationForUser(ctx context.Context, u *user.User) (*organization.Organization, *user.UserOrganizationAccess, error) {
	// Get user's organization access
	orgAccess, err := s.Repository.User().GetOrganizationAccess(ctx,
		user.OrganizationAccessByUserID(u.ID),
		user.OrganizationAccessOrderBy("created_at DESC"))
	if err != nil {
		return nil, nil, err
	}

	// Get the organization
	org, err := s.Repository.Organization().Get(ctx, organization.ByID(orgAccess.OrganizationID))
	if err != nil {
		return nil, nil, err
	}

	return org, orgAccess, nil
}
</file>

<file path="internal/app/auth/sign.go">
package auth

import (
	"time"

	"github.com/gofrs/uuid/v5"
	gojwt "github.com/golang-jwt/jwt/v5"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/auth"
	"github.com/trysourcetool/sourcetool/backend/internal/jwt"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

func buildSaveAuthURL(subdomain string) (string, error) {
	return urlx.BuildURL(config.Config.OrgBaseURL(subdomain), auth.SaveAuthPath, nil)
}

func createMagicLinkToken(email string) (string, error) {
	return jwt.SignToken(&jwt.UserEmailClaims{
		Email: email,
		RegisteredClaims: gojwt.RegisteredClaims{
			ExpiresAt: gojwt.NewNumericDate(time.Now().Add(15 * time.Minute)),
			Issuer:    jwt.Issuer,
			Subject:   jwt.UserSignatureSubjectMagicLink,
		},
	})
}

func createInvitationMagicLinkToken(email string) (string, error) {
	return jwt.SignToken(&jwt.UserEmailClaims{
		Email: email,
		RegisteredClaims: gojwt.RegisteredClaims{
			ExpiresAt: gojwt.NewNumericDate(time.Now().Add(15 * time.Minute)),
			Issuer:    jwt.Issuer,
			Subject:   jwt.UserSignatureSubjectInvitationMagicLink,
		},
	})
}

func createMagicLinkRegistrationToken(email string) (string, error) {
	return jwt.SignToken(&jwt.UserEmailClaims{
		Email: email,
		RegisteredClaims: gojwt.RegisteredClaims{
			ExpiresAt: gojwt.NewNumericDate(time.Now().Add(5 * time.Minute)),
			Issuer:    jwt.Issuer,
			Subject:   jwt.UserSignatureSubjectMagicLinkRegistration,
		},
	})
}

func createAuthToken(userID, xsrfToken string, expirationTime time.Time, subject string) (string, error) {
	return jwt.SignToken(&jwt.UserAuthClaims{
		UserID:    userID,
		XSRFToken: xsrfToken,
		RegisteredClaims: gojwt.RegisteredClaims{
			ExpiresAt: gojwt.NewNumericDate(expirationTime),
			Issuer:    jwt.Issuer,
			Subject:   subject,
		},
	})
}

func createGoogleAuthLinkToken(flow jwt.GoogleAuthFlow, invitationOrgID uuid.UUID, hostSubdomain string) (string, error) {
	claims := &jwt.UserGoogleAuthLinkClaims{
		Flow:            flow,
		InvitationOrgID: invitationOrgID,
		HostSubdomain:   hostSubdomain,
		RegisteredClaims: gojwt.RegisteredClaims{
			ExpiresAt: gojwt.NewNumericDate(time.Now().Add(5 * time.Minute)),
			Issuer:    jwt.Issuer,
			Subject:   jwt.UserSignatureSubjectGoogleAuthLink,
		},
	}
	return jwt.SignToken(claims)
}

func createGoogleRegistrationToken(googleID, email, firstName, lastName string, flow jwt.GoogleAuthFlow, invitationOrgID uuid.UUID, role string) (string, error) {
	claims := &jwt.UserGoogleRegistrationClaims{
		GoogleID:        googleID,
		Email:           email,
		FirstName:       firstName,
		LastName:        lastName,
		Flow:            flow,
		InvitationOrgID: invitationOrgID,
		Role:            role,
		RegisteredClaims: gojwt.RegisteredClaims{
			ExpiresAt: gojwt.NewNumericDate(time.Now().Add(5 * time.Minute)),
			Issuer:    jwt.Issuer,
			Subject:   jwt.UserSignatureSubjectGoogleRegistration,
		},
	}
	return jwt.SignToken(claims)
}
</file>

<file path="internal/app/auth/token_test.go">
package auth

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestHashRefreshToken(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "empty string",
			input:    "",
			expected: "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
		},
		{
			name:     "non-empty string",
			input:    "test-refresh-token",
			expected: "0a9b110d5e553bd98e9965c70a601c15c36805016ba60d54f20f5830c39edcde",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := hashRefreshToken(tt.input)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGenerateRefreshToken(t *testing.T) {
	plainRefreshToken, hashedRefreshToken, err := generateRefreshToken()
	assert.NoError(t, err)
	assert.NotEmpty(t, plainRefreshToken)
	assert.NotEmpty(t, hashedRefreshToken)
	assert.Equal(t, hashRefreshToken(plainRefreshToken), hashedRefreshToken)
}
</file>

<file path="internal/app/auth/token.go">
package auth

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
)

// hashRefreshToken creates a SHA-256 hash of a plaintext refresh token.
func hashRefreshToken(plainRefreshToken string) string {
	hash := sha256.Sum256([]byte(plainRefreshToken))
	return hex.EncodeToString(hash[:])
}

// generateRefreshToken creates a new random refresh token and its hash for user authentication.
func generateRefreshToken() (plainRefreshToken, hashedRefreshToken string, err error) {
	randomBytes := make([]byte, 32)
	if _, err := rand.Read(randomBytes); err != nil {
		return "", "", err
	}

	plainRefreshToken = base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(randomBytes)
	hashedRefreshToken = hashRefreshToken(plainRefreshToken)

	return plainRefreshToken, hashedRefreshToken, nil
}
</file>

<file path="internal/app/auth/url_test.go">
package auth

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/auth"
)

func TestBuildSaveAuthURL(t *testing.T) {
	// Setup test config
	config.Config = &config.Cfg{
		BaseURL:      "https://example.com",
		SSL:          true,
		Protocol:     "https",
		BaseDomain:   "example.com",
		BaseHostname: "example.com",
	}

	tests := []struct {
		name      string
		subdomain string
		expected  string
	}{
		{
			name:      "valid subdomain",
			subdomain: "test",
			expected:  "https://example.com" + auth.SaveAuthPath,
		},
		{
			name:      "empty subdomain",
			subdomain: "",
			expected:  "https://example.com" + auth.SaveAuthPath,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := buildSaveAuthURL(tt.subdomain)
			assert.NoError(t, err)
			assert.Equal(t, tt.expected, result)
		})
	}
}
</file>

<file path="internal/app/auth/url.go">
package auth

import (
	"path"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

func buildLoginURL(subdomain string) (string, error) {
	return urlx.BuildURL(config.Config.OrgBaseURL(subdomain), path.Join("login"), nil)
}

func buildMagicLinkURL(subdomain, token string) (string, error) {
	base := config.Config.AuthBaseURL()
	if subdomain != "" && subdomain != "auth" {
		base = config.Config.OrgBaseURL(subdomain)
	}
	return urlx.BuildURL(base, path.Join("auth", "magic", "authenticate"), map[string]string{
		"token": token,
	})
}

func buildInvitationMagicLinkURL(subdomain, token string) (string, error) {
	baseURL := config.Config.OrgBaseURL(subdomain)
	return urlx.BuildURL(baseURL, path.Join("auth", "invitations", "magic", "authenticate"), map[string]string{
		"token": token,
	})
}
</file>

<file path="internal/app/dto/apikey.go">
package dto

import (
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
)

type GetAPIKeyInput struct {
	APIKeyID string
}

type CreateAPIKeyInput struct {
	EnvironmentID string
	Name          string
}

type UpdateAPIKeyInput struct {
	APIKeyID string
	Name     *string
}

type DeleteAPIKeyInput struct {
	APIKeyID string
}

type APIKey struct {
	ID          string
	Name        string
	Key         string
	CreatedAt   int64
	UpdatedAt   int64
	Environment *Environment
}

func APIKeyFromModel(apiKey *apikey.APIKey, env *environment.Environment) *APIKey {
	if apiKey == nil {
		return nil
	}

	result := &APIKey{
		ID:        apiKey.ID.String(),
		Name:      apiKey.Name,
		Key:       apiKey.Key,
		CreatedAt: apiKey.CreatedAt.Unix(),
		UpdatedAt: apiKey.UpdatedAt.Unix(),
	}

	if env != nil {
		result.Environment = EnvironmentFromModel(env)
	}

	return result
}

type GetAPIKeyOutput struct {
	APIKey *APIKey
}

type ListAPIKeysOutput struct {
	DevKey   *APIKey
	LiveKeys []*APIKey
}

type CreateAPIKeyOutput struct {
	APIKey *APIKey
}

type UpdateAPIKeyOutput struct {
	APIKey *APIKey
}

type DeleteAPIKeyOutput struct {
	APIKey *APIKey
}
</file>

<file path="internal/app/dto/auth.go">
package dto

type RequestMagicLinkInput struct {
	Email string
}

type AuthenticateWithMagicLinkInput struct {
	Token     string
	FirstName string // Optional: used for new users
	LastName  string // Optional: used for new users
}

type RegisterWithMagicLinkInput struct {
	Token     string
	FirstName string
	LastName  string
}

type RequestInvitationMagicLinkInput struct {
	InvitationToken string
}

type AuthenticateWithInvitationMagicLinkInput struct {
	Token string
}

type RegisterWithInvitationMagicLinkInput struct {
	Token     string
	FirstName string
	LastName  string
}

type AuthenticateWithGoogleInput struct {
	Code  string
	State string
}

type RegisterWithGoogleInput struct {
	Token     string
	FirstName string
	LastName  string
}

type RequestInvitationGoogleAuthLinkInput struct {
	InvitationToken string
}

type RefreshTokenInput struct {
	RefreshToken    string
	XSRFTokenHeader string
	XSRFTokenCookie string
}

type SaveAuthInput struct {
	Token string
}

type RequestMagicLinkOutput struct {
	Email string
	IsNew bool
}

type AuthenticateWithMagicLinkOutput struct {
	AuthURL         string
	Token           string
	HasOrganization bool
	RefreshToken    string
	XSRFToken       string
	Domain          string
	IsNewUser       bool
}

type RegisterWithMagicLinkOutput struct {
	Token           string
	RefreshToken    string
	XSRFToken       string
	ExpiresAt       string
	HasOrganization bool
}

type RequestInvitationMagicLinkOutput struct {
	Email string
	IsNew bool
}

type AuthenticateWithInvitationMagicLinkOutput struct {
	AuthURL   string
	Token     string
	Domain    string
	IsNewUser bool
}

type RegisterWithInvitationMagicLinkOutput struct {
	Token        string
	RefreshToken string
	XSRFToken    string
	ExpiresAt    string
	Domain       string
}

type RequestGoogleAuthLinkOutput struct {
	AuthURL string
}

type AuthenticateWithGoogleOutput struct {
	FirstName                string
	LastName                 string
	AuthURL                  string
	Token                    string
	HasOrganization          bool
	HasMultipleOrganizations bool
	RefreshToken             string
	XSRFToken                string
	Domain                   string
	IsNewUser                bool
	Flow                     string
}

type RegisterWithGoogleOutput struct {
	Token           string
	RefreshToken    string
	XSRFToken       string
	ExpiresAt       string
	AuthURL         string
	HasOrganization bool
}

type RequestInvitationGoogleAuthLinkOutput struct {
	AuthURL string
}

type LogoutOutput struct {
	Domain string
}

type RefreshTokenOutput struct {
	Token        string
	RefreshToken string
	XSRFToken    string
	ExpiresAt    string
	Domain       string
}

type SaveAuthOutput struct {
	Token        string
	RefreshToken string
	XSRFToken    string
	ExpiresAt    string
	RedirectURL  string
	Domain       string
}

type ObtainAuthTokenOutput struct {
	AuthURL string
	Token   string
}
</file>

<file path="internal/app/dto/environment.go">
package dto

import (
	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
)

type GetEnvironmentInput struct {
	EnvironmentID string
}

type CreateEnvironmentInput struct {
	Name  string
	Slug  string
	Color string
}

type UpdateEnvironmentInput struct {
	EnvironmentID string
	Name          *string
	Color         *string
}

type DeleteEnvironmentInput struct {
	EnvironmentID string
}

type Environment struct {
	ID        string
	Name      string
	Slug      string
	Color     string
	CreatedAt int64
	UpdatedAt int64
}

func EnvironmentFromModel(env *environment.Environment) *Environment {
	if env == nil {
		return nil
	}

	return &Environment{
		ID:        env.ID.String(),
		Name:      env.Name,
		Slug:      env.Slug,
		Color:     env.Color,
		CreatedAt: env.CreatedAt.Unix(),
		UpdatedAt: env.UpdatedAt.Unix(),
	}
}

type GetEnvironmentOutput struct {
	Environment *Environment
}

type ListEnvironmentsOutput struct {
	Environments []*Environment
}

type CreateEnvironmentOutput struct {
	Environment *Environment
}

type UpdateEnvironmentOutput struct {
	Environment *Environment
}

type DeleteEnvironmentOutput struct {
	Environment *Environment
}
</file>

<file path="internal/app/dto/group.go">
package dto

import "github.com/trysourcetool/sourcetool/backend/internal/domain/group"

type GetGroupInput struct {
	GroupID string
}

type CreateGroupInput struct {
	Name    string
	Slug    string
	UserIDs []string
}

type UpdateGroupInput struct {
	GroupID string
	Name    *string
	UserIDs []string
}

type DeleteGroupInput struct {
	GroupID string
}

type Group struct {
	ID             string
	OrganizationID string
	Name           string
	Slug           string
	CreatedAt      int64
	UpdatedAt      int64
}

func GroupFromModel(group *group.Group) *Group {
	if group == nil {
		return nil
	}

	return &Group{
		ID:             group.ID.String(),
		OrganizationID: group.OrganizationID.String(),
		Name:           group.Name,
		Slug:           group.Slug,
		CreatedAt:      group.CreatedAt.Unix(),
		UpdatedAt:      group.UpdatedAt.Unix(),
	}
}

type GroupPage struct {
	ID        string
	GroupID   string
	PageID    string
	CreatedAt int64
	UpdatedAt int64
}

func GroupPageFromModel(groupPage *group.GroupPage) *GroupPage {
	if groupPage == nil {
		return nil
	}

	return &GroupPage{
		ID:        groupPage.ID.String(),
		GroupID:   groupPage.GroupID.String(),
		PageID:    groupPage.PageID.String(),
		CreatedAt: groupPage.CreatedAt.Unix(),
		UpdatedAt: groupPage.UpdatedAt.Unix(),
	}
}

type GetGroupOutput struct {
	Group *Group
}

type ListGroupsOutput struct {
	Groups     []*Group
	Users      []*User
	UserGroups []*UserGroup
}

type CreateGroupOutput struct {
	Group *Group
}

type UpdateGroupOutput struct {
	Group *Group
}

type DeleteGroupOutput struct {
	Group *Group
}
</file>

<file path="internal/app/dto/hostinstance.go">
package dto

import "github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"

type PingHostInstanceInput struct {
	PageID *string
}

type HostInstance struct {
	ID             string
	OrganizationID string
	APIKeyID       string
	SDKName        string
	SDKVersion     string
	Status         string
	CreatedAt      int64
	UpdatedAt      int64
}

func HostInstanceFromModel(instance *hostinstance.HostInstance) *HostInstance {
	if instance == nil {
		return nil
	}

	return &HostInstance{
		ID:             instance.ID.String(),
		OrganizationID: instance.OrganizationID.String(),
		APIKeyID:       instance.APIKeyID.String(),
		SDKName:        instance.SDKName,
		SDKVersion:     instance.SDKVersion,
		Status:         instance.Status.String(),
		CreatedAt:      instance.CreatedAt.Unix(),
		UpdatedAt:      instance.UpdatedAt.Unix(),
	}
}

type PingHostInstanceOutput struct {
	HostInstance *HostInstance
}
</file>

<file path="internal/app/dto/organization.go">
package dto

import (
	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type CreateOrganizationInput struct {
	Subdomain string
}

type CheckSubdomainAvailabilityInput struct {
	Subdomain string
}

type Organization struct {
	ID        string
	Subdomain string
	CreatedAt int64
	UpdatedAt int64
}

func OrganizationFromModel(org *organization.Organization) *Organization {
	if org == nil {
		return nil
	}

	return &Organization{
		ID:        org.ID.String(),
		Subdomain: internal.SafeValue(org.Subdomain),
		CreatedAt: org.CreatedAt.Unix(),
		UpdatedAt: org.UpdatedAt.Unix(),
	}
}

type CreateOrganizationOutput struct {
	Organization *Organization
}
</file>

<file path="internal/app/dto/page.go">
package dto

import "github.com/trysourcetool/sourcetool/backend/internal/domain/page"

type ListPagesInput struct {
	EnvironmentID string
}

type Page struct {
	ID             string
	OrganizationID string
	EnvironmentID  string
	APIKeyID       string
	Name           string
	Route          string
	Path           []int32
	CreatedAt      int64
	UpdatedAt      int64
}

func PageFromModel(page *page.Page) *Page {
	if page == nil {
		return nil
	}

	return &Page{
		ID:             page.ID.String(),
		OrganizationID: page.OrganizationID.String(),
		EnvironmentID:  page.EnvironmentID.String(),
		APIKeyID:       page.APIKeyID.String(),
		Name:           page.Name,
		Route:          page.Route,
		Path:           page.Path,
		CreatedAt:      page.CreatedAt.Unix(),
		UpdatedAt:      page.UpdatedAt.Unix(),
	}
}

type ListPagesOutput struct {
	Pages      []*Page
	Groups     []*Group
	GroupPages []*GroupPage
	Users      []*User
	UserGroups []*UserGroup
}
</file>

<file path="internal/app/dto/session.go">
package dto

import "github.com/trysourcetool/sourcetool/backend/internal/domain/session"

type Session struct {
	ID             string
	OrganizationID string
	UserID         string
	APIKeyID       string
	HostInstanceID string
	CreatedAt      int64
	UpdatedAt      int64
}

func SessionFromModel(session *session.Session) *Session {
	if session == nil {
		return nil
	}

	return &Session{
		ID:             session.ID.String(),
		OrganizationID: session.OrganizationID.String(),
		UserID:         session.UserID.String(),
		APIKeyID:       session.APIKeyID.String(),
		HostInstanceID: session.HostInstanceID.String(),
		CreatedAt:      session.CreatedAt.Unix(),
		UpdatedAt:      session.UpdatedAt.Unix(),
	}
}
</file>

<file path="internal/app/dto/user.go">
package dto

import (
	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
)

type UpdateMeInput struct {
	FirstName *string
	LastName  *string
}

type SendUpdateMeEmailInstructionsInput struct {
	Email             string
	EmailConfirmation string
}

type UpdateMeEmailInput struct {
	Token string
}

type UpdateUserInput struct {
	UserID   string
	Role     *string
	GroupIDs []string
}

type DeleteUserInput struct {
	UserID string
}

type CreateUserInvitationsInput struct {
	Emails []string
	Role   string
}

type ResendUserInvitationInput struct {
	InvitationID string
}

type User struct {
	ID           string
	Email        string
	FirstName    string
	LastName     string
	Role         string
	CreatedAt    int64
	UpdatedAt    int64
	Organization *Organization
}

func UserFromModel(user *user.User, org *organization.Organization, role user.UserOrganizationRole) *User {
	if user == nil {
		return nil
	}

	result := &User{
		ID:        user.ID.String(),
		Email:     user.Email,
		FirstName: user.FirstName,
		LastName:  user.LastName,
		Role:      role.String(),
		CreatedAt: user.CreatedAt.Unix(),
		UpdatedAt: user.UpdatedAt.Unix(),
	}

	if org != nil {
		result.Organization = OrganizationFromModel(org)
	}

	return result
}

type UserInvitation struct {
	ID        string
	Email     string
	CreatedAt int64
}

func UserInvitationFromModel(invitation *user.UserInvitation) *UserInvitation {
	if invitation == nil {
		return nil
	}

	return &UserInvitation{
		ID:        invitation.ID.String(),
		Email:     invitation.Email,
		CreatedAt: invitation.CreatedAt.Unix(),
	}
}

type UserGroup struct {
	ID        string
	UserID    string
	GroupID   string
	CreatedAt int64
	UpdatedAt int64
}

func UserGroupFromModel(group *user.UserGroup) *UserGroup {
	if group == nil {
		return nil
	}

	return &UserGroup{
		ID:        group.ID.String(),
		UserID:    group.UserID.String(),
		GroupID:   group.GroupID.String(),
		CreatedAt: group.CreatedAt.Unix(),
		UpdatedAt: group.UpdatedAt.Unix(),
	}
}

type GetMeOutput struct {
	User *User
}

type UpdateMeOutput struct {
	User *User
}

type UpdateMeEmailOutput struct {
	User *User
}

type ListUsersOutput struct {
	Users           []*User
	UserInvitations []*UserInvitation
}

type UpdateUserOutput struct {
	User *User
}

type CreateUserInvitationsOutput struct {
	UserInvitations []*UserInvitation
}

type ResendUserInvitationOutput struct {
	UserInvitation *UserInvitation
}
</file>

<file path="internal/app/dto/ws.go">
package dto

import "github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"

type UpdateHostInstanceStatusInput struct {
	ID     string
	Status hostinstance.HostInstanceStatus
}

type UpdateHostInstanceStatusOutput struct {
	HostInstance *HostInstance
}
</file>

<file path="internal/app/environment/service.go">
package environment

import (
	"context"
	"errors"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/app/permission"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
	domainperm "github.com/trysourcetool/sourcetool/backend/internal/domain/permission"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type Service interface {
	Get(context.Context, dto.GetEnvironmentInput) (*dto.GetEnvironmentOutput, error)
	List(context.Context) (*dto.ListEnvironmentsOutput, error)
	Create(context.Context, dto.CreateEnvironmentInput) (*dto.CreateEnvironmentOutput, error)
	Update(context.Context, dto.UpdateEnvironmentInput) (*dto.UpdateEnvironmentOutput, error)
	Delete(context.Context, dto.DeleteEnvironmentInput) (*dto.DeleteEnvironmentOutput, error)
}

type ServiceCE struct {
	*port.Dependencies
}

func NewServiceCE(d *port.Dependencies) *ServiceCE {
	return &ServiceCE{Dependencies: d}
}

func (s *ServiceCE) Get(ctx context.Context, in dto.GetEnvironmentInput) (*dto.GetEnvironmentOutput, error) {
	currentOrg := internal.CurrentOrganization(ctx)
	envID, err := uuid.FromString(in.EnvironmentID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}

	env, err := s.Repository.Environment().Get(ctx, environment.ByOrganizationID(currentOrg.ID), environment.ByID(envID))
	if err != nil {
		return nil, err
	}

	return &dto.GetEnvironmentOutput{
		Environment: dto.EnvironmentFromModel(env),
	}, nil
}

func (s *ServiceCE) List(ctx context.Context) (*dto.ListEnvironmentsOutput, error) {
	currentOrg := internal.CurrentOrganization(ctx)
	envs, err := s.Repository.Environment().List(ctx, environment.ByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	envsOut := make([]*dto.Environment, 0, len(envs))
	for _, env := range envs {
		envsOut = append(envsOut, dto.EnvironmentFromModel(env))
	}

	return &dto.ListEnvironmentsOutput{
		Environments: envsOut,
	}, nil
}

func (s *ServiceCE) Create(ctx context.Context, in dto.CreateEnvironmentInput) (*dto.CreateEnvironmentOutput, error) {
	checker := permission.NewChecker(s.Repository)
	if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditEnvironment); err != nil {
		return nil, err
	}

	currentOrg := internal.CurrentOrganization(ctx)

	slugExists, err := s.Repository.Environment().IsSlugExistsInOrganization(ctx, currentOrg.ID, in.Slug)
	if err != nil {
		return nil, err
	}
	if slugExists {
		return nil, errdefs.ErrEnvironmentSlugAlreadyExists(errors.New("slug already exists"))
	}

	if !validateSlug(in.Slug) {
		return nil, errdefs.ErrInvalidArgument(errors.New("invalid slug"))
	}

	env := &environment.Environment{
		ID:             uuid.Must(uuid.NewV4()),
		OrganizationID: currentOrg.ID,
		Name:           in.Name,
		Slug:           in.Slug,
		Color:          in.Color,
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.Environment().Create(ctx, env); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	env, err = s.Repository.Environment().Get(ctx, environment.ByID(env.ID))
	if err != nil {
		return nil, err
	}

	return &dto.CreateEnvironmentOutput{
		Environment: dto.EnvironmentFromModel(env),
	}, nil
}

func (s *ServiceCE) Update(ctx context.Context, in dto.UpdateEnvironmentInput) (*dto.UpdateEnvironmentOutput, error) {
	checker := permission.NewChecker(s.Repository)
	if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditEnvironment); err != nil {
		return nil, err
	}

	currentOrg := internal.CurrentOrganization(ctx)
	envID, err := uuid.FromString(in.EnvironmentID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}

	env, err := s.Repository.Environment().Get(ctx, environment.ByID(envID), environment.ByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	if in.Name != nil {
		env.Name = internal.SafeValue(in.Name)
	}
	if in.Color != nil {
		env.Color = internal.SafeValue(in.Color)
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.Environment().Update(ctx, env); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	env, err = s.Repository.Environment().Get(ctx, environment.ByID(env.ID))
	if err != nil {
		return nil, err
	}

	return &dto.UpdateEnvironmentOutput{
		Environment: dto.EnvironmentFromModel(env),
	}, nil
}

func (s *ServiceCE) Delete(ctx context.Context, in dto.DeleteEnvironmentInput) (*dto.DeleteEnvironmentOutput, error) {
	checker := permission.NewChecker(s.Repository)
	if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditEnvironment); err != nil {
		return nil, err
	}

	currentOrg := internal.CurrentOrganization(ctx)
	envID, err := uuid.FromString(in.EnvironmentID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}

	env, err := s.Repository.Environment().Get(ctx, environment.ByID(envID), environment.ByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	if env.Slug == environment.EnvironmentSlugDevelopment || env.Slug == environment.EnvironmentSlugProduction {
		return nil, errdefs.ErrInvalidArgument(errors.New("cannot delete development or production environment"))
	}

	apiKeys, err := s.Repository.APIKey().List(ctx, apikey.ByEnvironmentID(env.ID))
	if err != nil {
		return nil, err
	}

	if len(apiKeys) > 0 {
		return nil, errdefs.ErrEnvironmentDeletionNotAllowed(errors.New("cannot delete environment with API keys"))
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.Environment().Delete(ctx, env); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	return &dto.DeleteEnvironmentOutput{
		Environment: dto.EnvironmentFromModel(env),
	}, nil
}
</file>

<file path="internal/app/environment/validate.go">
package environment

import "regexp"

func validateSlug(s string) bool {
	pattern := `^[a-zA-Z0-9\-_]+$`
	match, _ := regexp.MatchString(pattern, s)
	return match
}
</file>

<file path="internal/app/group/service.go">
package group

import (
	"context"
	"errors"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
)

type Service interface {
	Get(context.Context, dto.GetGroupInput) (*dto.GetGroupOutput, error)
	List(context.Context) (*dto.ListGroupsOutput, error)
	Create(context.Context, dto.CreateGroupInput) (*dto.CreateGroupOutput, error)
	Update(context.Context, dto.UpdateGroupInput) (*dto.UpdateGroupOutput, error)
	Delete(context.Context, dto.DeleteGroupInput) (*dto.DeleteGroupOutput, error)
}

type ServiceCE struct {
	*port.Dependencies
}

func NewServiceCE(d *port.Dependencies) *ServiceCE {
	return &ServiceCE{Dependencies: d}
}

func (s *ServiceCE) Get(ctx context.Context, in dto.GetGroupInput) (*dto.GetGroupOutput, error) {
	return nil, errors.New("group functionality is not available in CE version")
}

func (s *ServiceCE) List(ctx context.Context) (*dto.ListGroupsOutput, error) {
	return nil, errors.New("group functionality is not available in CE version")
}

func (s *ServiceCE) Create(ctx context.Context, in dto.CreateGroupInput) (*dto.CreateGroupOutput, error) {
	return nil, errors.New("group functionality is not available in CE version")
}

func (s *ServiceCE) Update(ctx context.Context, in dto.UpdateGroupInput) (*dto.UpdateGroupOutput, error) {
	return nil, errors.New("group functionality is not available in CE version")
}

func (s *ServiceCE) Delete(ctx context.Context, in dto.DeleteGroupInput) (*dto.DeleteGroupOutput, error) {
	return nil, errors.New("group functionality is not available in CE version")
}
</file>

<file path="internal/app/hostinstance/service.go">
package hostinstance

import (
	"context"
	"errors"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/page"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type Service interface {
	Ping(context.Context, dto.PingHostInstanceInput) (*dto.PingHostInstanceOutput, error)
}

type ServiceCE struct {
	*port.Dependencies
}

func NewServiceCE(d *port.Dependencies) *ServiceCE {
	return &ServiceCE{Dependencies: d}
}

func (s *ServiceCE) Ping(ctx context.Context, in dto.PingHostInstanceInput) (*dto.PingHostInstanceOutput, error) {
	currentOrg := internal.CurrentOrganization(ctx)
	if currentOrg == nil {
		return nil, errdefs.ErrUnauthenticated(errors.New("current organization not found"))
	}

	hostInstanceOpts := []hostinstance.Query{
		hostinstance.ByOrganizationID(currentOrg.ID),
	}
	if in.PageID != nil {
		pageID, err := uuid.FromString(internal.SafeValue(in.PageID))
		if err != nil {
			return nil, errdefs.ErrInvalidArgument(err)
		}

		page, err := s.Repository.Page().Get(ctx, page.ByID(pageID))
		if err != nil {
			return nil, err
		}

		apiKey, err := s.Repository.APIKey().Get(ctx, apikey.ByID(page.APIKeyID))
		if err != nil {
			return nil, err
		}

		hostInstanceOpts = append(hostInstanceOpts, hostinstance.ByAPIKeyID(apiKey.ID))
	}

	hostInstances, err := s.Repository.HostInstance().List(ctx, hostInstanceOpts...)
	if err != nil {
		return nil, err
	}

	var onlineHostInstance *hostinstance.HostInstance
	for _, hostInstance := range hostInstances {
		if hostInstance.Status == hostinstance.HostInstanceStatusOnline {
			if err := s.WSManager.PingConnectedHost(hostInstance.ID); err != nil {
				hostInstance.Status = hostinstance.HostInstanceStatusOffline
				if err := s.Repository.HostInstance().Update(ctx, hostInstance); err != nil {
					return nil, err
				}
				continue
			}

			onlineHostInstance = hostInstance
			break
		}
	}

	if onlineHostInstance == nil {
		return nil, errdefs.ErrHostInstanceStatusNotOnline(errors.New("host instance status is not online"))
	}

	return &dto.PingHostInstanceOutput{
		HostInstance: dto.HostInstanceFromModel(onlineHostInstance),
	}, nil
}
</file>

<file path="internal/app/organization/reserved_subdomains.go">
package organization

var reservedSubdomains = []string{
	// Brand Protection
	"sourcetool",
	"trysourcetool",

	// Authentication & Security
	"2fa",
	"auth",
	"auth0",
	"login",
	"mfa",
	"oauth",
	"password",
	"passwords",
	"register",
	"registration",
	"saml",
	"secure",
	"security",
	"signin",
	"signup",
	"sso",

	// Core Infrastructure
	"api",
	"api-docs",
	"apis",
	"app",
	"apps",
	"cache",
	"cdn",
	"config",
	"db",
	"database",
	"git",
	"graphql",
	"logs",
	"proxy",
	"repo",
	"repository",
	"server",
	"service",
	"services",
	"socket",
	"static",
	"storage",
	"svc",
	"sys",
	"system",
	"webhook",
	"webhooks",
	"ws",

	// Environment & Testing
	"alpha",
	"beta",
	"demo",
	"example",
	"examples",
	"playground",
	"preview",
	"prod",
	"production",
	"prd",
	"qa",
	"quality",
	"quality-assurance",
	"release",
	"sample",
	"samples",
	"sandbox",
	"staging",
	"stg",
	"test",
	"testing",
	"tests",

	// User & Organization Management
	"account",
	"accounts",
	"admin",
	"administrator",
	"groups",
	"members",
	"my",
	"org",
	"organization",
	"portal",
	"profile",
	"root",
	"settings",
	"super",
	"superuser",
	"team",
	"teams",
	"user",
	"users",
	"customer",
	"customers",
	"welcome",
	"workspace",
	"workspaces",
	"project",
	"projects",

	// Business & Enterprise
	"billing",
	"corporate",
	"enterprise",
	"finance",
	"hr",
	"invoice",
	"marketing",
	"payments",
	"premium",
	"pro",
	"sales",

	// Product Features
	"alerts",
	"analytics",
	"console",
	"dashboard",
	"feedback",
	"internal",
	"management",
	"metrics",
	"monitor",
	"notifications",
	"private",
	"public",
	"reports",
	"search",

	// Communication & Support
	"email",
	"ftp",
	"help",
	"imap",
	"mail",
	"pop",
	"smtp",
	"ssh",
	"support",

	// Documentation & Development
	"dev",
	"developer",
	"developers",
	"docs",
	"document",
	"documentation",
	"documentations",
	"documents",
	"swagger",

	// Content & Media
	"assets",
	"blog",
	"browser",
	"media",
	"news",
	"web",
	"www",

	// Legal & Company
	"about",
	"contact",
	"legal",
	"privacy",
	"terms",

	// Commerce
	"shop",
	"store",

	// Temporary & Misc
	"hello",
	"official",
	"temp",
	"temporary",
	"tmp",
}
</file>

<file path="internal/app/organization/service.go">
package organization

import (
	"context"
	"errors"

	"github.com/gofrs/uuid/v5"
	"github.com/samber/lo"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type Service interface {
	Create(ctx context.Context, in dto.CreateOrganizationInput) (*dto.CreateOrganizationOutput, error)
	CheckSubdomainAvailability(ctx context.Context, in dto.CheckSubdomainAvailabilityInput) error
}

type ServiceCE struct {
	*port.Dependencies
}

func NewServiceCE(d *port.Dependencies) *ServiceCE {
	return &ServiceCE{Dependencies: d}
}

func (s *ServiceCE) Create(ctx context.Context, in dto.CreateOrganizationInput) (*dto.CreateOrganizationOutput, error) {
	var subdomain *string
	if config.Config.IsCloudEdition {
		subdomain = internal.NilValue(in.Subdomain)

		if lo.Contains(reservedSubdomains, in.Subdomain) {
			return nil, errdefs.ErrOrganizationSubdomainAlreadyExists(errors.New("subdomain is reserved"))
		}

		exists, err := s.Repository.Organization().IsSubdomainExists(ctx, in.Subdomain)
		if err != nil {
			return nil, err
		}
		if exists {
			return nil, errdefs.ErrOrganizationSubdomainAlreadyExists(errors.New("subdomain already exists"))
		}
	}

	o := &organization.Organization{
		ID:        uuid.Must(uuid.NewV4()),
		Subdomain: subdomain,
	}

	currentUser := internal.CurrentUser(ctx)

	orgAccess := &user.UserOrganizationAccess{
		ID:             uuid.Must(uuid.NewV4()),
		UserID:         currentUser.ID,
		OrganizationID: o.ID,
		Role:           user.UserOrganizationRoleAdmin,
	}
	devEnv := &environment.Environment{
		ID:             uuid.Must(uuid.NewV4()),
		OrganizationID: o.ID,
		Name:           environment.EnvironmentNameDevelopment,
		Slug:           environment.EnvironmentSlugDevelopment,
		Color:          environment.EnvironmentColorDevelopment,
	}
	envs := []*environment.Environment{
		{
			ID:             uuid.Must(uuid.NewV4()),
			OrganizationID: o.ID,
			Name:           environment.EnvironmentNameProduction,
			Slug:           environment.EnvironmentSlugProduction,
			Color:          environment.EnvironmentColorProduction,
		},
		devEnv,
	}

	key, err := devEnv.GenerateAPIKey()
	if err != nil {
		return nil, errdefs.ErrInternal(err)
	}
	apiKey := &apikey.APIKey{
		ID:             uuid.Must(uuid.NewV4()),
		OrganizationID: o.ID,
		EnvironmentID:  devEnv.ID,
		UserID:         currentUser.ID,
		Name:           "",
		Key:            key,
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.Organization().Create(ctx, o); err != nil {
			return err
		}

		if err := tx.User().CreateOrganizationAccess(ctx, orgAccess); err != nil {
			return err
		}

		if err := tx.Environment().BulkInsert(ctx, envs); err != nil {
			return err
		}

		if err := tx.APIKey().Create(ctx, apiKey); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	o, err = s.Repository.Organization().Get(ctx, organization.ByID(o.ID))
	if err != nil {
		return nil, err
	}

	return &dto.CreateOrganizationOutput{
		Organization: dto.OrganizationFromModel(o),
	}, nil
}

func (s *ServiceCE) CheckSubdomainAvailability(ctx context.Context, in dto.CheckSubdomainAvailabilityInput) error {
	exists, err := s.Repository.Organization().IsSubdomainExists(ctx, in.Subdomain)
	if err != nil {
		return err
	}
	if exists {
		return errdefs.ErrOrganizationSubdomainAlreadyExists(errors.New("subdomain already exists"))
	}

	if lo.Contains(reservedSubdomains, in.Subdomain) {
		return errdefs.ErrOrganizationSubdomainAlreadyExists(errors.New("subdomain is reserved"))
	}

	return nil
}
</file>

<file path="internal/app/page/service.go">
package page

import (
	"context"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/page"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
)

type Service interface {
	List(context.Context, dto.ListPagesInput) (*dto.ListPagesOutput, error)
}

type ServiceCE struct {
	*port.Dependencies
}

func NewServiceCE(d *port.Dependencies) *ServiceCE {
	return &ServiceCE{Dependencies: d}
}

func (s *ServiceCE) List(ctx context.Context, in dto.ListPagesInput) (*dto.ListPagesOutput, error) {
	o := internal.CurrentOrganization(ctx)

	envID, err := uuid.FromString(in.EnvironmentID)
	if err != nil {
		return nil, err
	}

	env, err := s.Repository.Environment().Get(ctx, environment.ByID(envID))
	if err != nil {
		return nil, err
	}

	pages, err := s.Repository.Page().List(ctx, page.ByOrganizationID(o.ID), page.ByEnvironmentID(env.ID), page.OrderBy(`array_length(p."path", 1), "path"`))
	if err != nil {
		return nil, err
	}

	users, err := s.Repository.User().List(ctx, user.ByOrganizationID(o.ID))
	if err != nil {
		return nil, err
	}

	userGroups, err := s.Repository.User().ListGroups(ctx, user.GroupByOrganizationID(o.ID))
	if err != nil {
		return nil, err
	}

	pagesOut := make([]*dto.Page, 0, len(pages))
	for _, page := range pages {
		pagesOut = append(pagesOut, dto.PageFromModel(page))
	}

	usersOut := make([]*dto.User, 0, len(users))
	for _, u := range users {
		usersOut = append(usersOut, dto.UserFromModel(u, nil, user.UserOrganizationRoleUnknown))
	}

	userGroupsOut := make([]*dto.UserGroup, 0, len(userGroups))
	for _, userGroup := range userGroups {
		userGroupsOut = append(userGroupsOut, dto.UserGroupFromModel(userGroup))
	}

	return &dto.ListPagesOutput{
		Pages:      pagesOut,
		Groups:     make([]*dto.Group, 0),
		GroupPages: make([]*dto.GroupPage, 0),
		Users:      usersOut,
		UserGroups: userGroupsOut,
	}, nil
}
</file>

<file path="internal/app/permission/checker.go">
package permission

import (
	"context"
	"errors"
	"fmt"

	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	domainperm "github.com/trysourcetool/sourcetool/backend/internal/domain/permission"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

// Checker handles authorization logic in the application layer.
type Checker struct {
	repo port.Repositories
}

// NewChecker creates a new permission Checker.
func NewChecker(repo port.Repositories) *Checker {
	return &Checker{repo: repo}
}

// AuthorizeOperation checks if the current user can perform the given operation.
func (c *Checker) AuthorizeOperation(ctx context.Context, op domainperm.Operation) error {
	currentUser := internal.CurrentUser(ctx)
	currentOrg := internal.CurrentOrganization(ctx)
	if currentUser == nil || currentOrg == nil {
		return errdefs.ErrPermissionDenied(errors.New("user or organization context not found"))
	}
	orgAccess, err := c.repo.User().GetOrganizationAccess(
		ctx,
		user.OrganizationAccessByUserID(currentUser.ID),
		user.OrganizationAccessByOrganizationID(currentOrg.ID),
	)
	if err != nil && !errdefs.IsUserOrganizationAccessNotFound(err) {
		return errdefs.ErrPermissionDenied(err)
	}
	if !domainperm.CanPerform(orgAccess.Role, op) {
		return errdefs.ErrPermissionDenied(fmt.Errorf("user role %s is not allowed to perform operation: %s", orgAccess.Role.String(), op))
	}
	return nil
}
</file>

<file path="internal/app/port/dependencies.go">
package port

type Dependencies struct {
	Repository Repository
	Mailer     Mailer
	PubSub     PubSub
	WSManager  WSManager
}

func NewDependencies(repo Repository, mailer Mailer, pubsub PubSub, wsManager WSManager) *Dependencies {
	return &Dependencies{
		Repository: repo,
		Mailer:     mailer,
		PubSub:     pubsub,
		WSManager:  wsManager,
	}
}
</file>

<file path="internal/app/port/mailer.go">
package port

import "context"

type Mailer interface {
	Send(ctx context.Context, to []string, from, subject, body string) error
}
</file>

<file path="internal/app/port/pubsub.go">
package port

import "context"

// Message represents a message received from a subscription.
type Message struct {
	ID      string
	Payload []byte
}

// PubSub defines the interface for publish/subscribe operations.
type PubSub interface {
	// Publish sends a message to the specified channel.
	Publish(ctx context.Context, channel, id string, payload []byte) error
	// Subscribe listens for messages on the specified channel.
	// It returns a channel that receives messages. The channel will be closed
	// when the context is canceled or an error occurs during subscription.
	Subscribe(ctx context.Context, channel string) (<-chan *Message, error)
	// Close terminates the connection.
	Close() error
}
</file>

<file path="internal/app/port/repository.go">
package port

import (
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/group"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/page"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/session"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
)

type Repositories interface {
	APIKey() apikey.Repository
	Environment() environment.Repository
	Group() group.Repository
	HostInstance() hostinstance.Repository
	Organization() organization.Repository
	Page() page.Repository
	Session() session.Repository
	User() user.Repository
}

type Repository interface {
	Repositories
	Close() error
	RunTransaction(func(tx Transaction) error) error
}

type Transaction interface {
	Repositories
}
</file>

<file path="internal/app/port/wsmanager.go">
package port

import (
	"context"

	"github.com/gofrs/uuid/v5"
	"github.com/gorilla/websocket"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/session"
	websocketv1 "github.com/trysourcetool/sourcetool/backend/internal/pb/go/websocket/v1"
)

// WSManager defines the interface for WebSocket connection management operations
// that are relevant to the domain or application layers.
type WSManager interface {
	// SendToHost sends a message to a specific connected host instance via the pub/sub system.
	SendToHost(ctx context.Context, hostID uuid.UUID, msg *websocketv1.Message) error
	// SendToClient sends a message to a specific connected client session via the pub/sub system.
	SendToClient(ctx context.Context, sessionID uuid.UUID, msg *websocketv1.Message) error
	// Close gracefully shuts down the connection manager, closing all connections and stopping background processes.
	Close() error
	// PingConnectedHost pings a specific host instance to check if it is online.
	PingConnectedHost(hostID uuid.UUID) error
	// SetConnectedHost sets a specific host instance as connected.
	SetConnectedHost(hostInstance *hostinstance.HostInstance, apiKey *apikey.APIKey, conn *websocket.Conn)
	// DisconnectHost disconnects a specific host instance.
	DisconnectHost(hostID uuid.UUID)
	// SetConnectedClient sets a specific client session as connected.
	SetConnectedClient(session *session.Session, conn *websocket.Conn)
	// DisconnectClient disconnects a specific client session.
	DisconnectClient(sessionID uuid.UUID)
}
</file>

<file path="internal/app/user/email.go">
package user

import (
	"context"
	"fmt"

	"github.com/samber/lo"
)

func (s *ServiceCE) sendUpdateEmailInstructions(ctx context.Context, to, firstName, url string) error {
	subject := "[Sourcetool] Confirm your new email address"
	content := fmt.Sprintf(`Hi %s,

We received a request to change the email address associated with your Sourcetool account. To ensure the security of your account, we need you to verify your new email address.

Please click the following link within the next 24 hours to confirm your email change:
%s

Thank you for being a part of the Sourcetool community!
Regards,

Sourcetool Team`,
		firstName,
		url,
	)

	return s.Mailer.Send(ctx, []string{to}, "Sourcetool Team", subject, content)
}

func (s *ServiceCE) sendInvitationEmail(ctx context.Context, invitees string, emaiURLs map[string]string) error {
	subject := "You've been invited to join Sourcetool!"
	baseContent := `You've been invited to join Sourcetool!

To accept the invitation, please create your account by clicking the URL below within 24 hours.

%s

- This URL will expire in 24 hours.
- This is a send-only email address.
- Your account will not be created unless you complete the next steps.`

	sendEmails := make([]string, 0)
	for email, url := range emaiURLs {
		if lo.Contains(sendEmails, email) {
			continue
		}

		content := fmt.Sprintf(baseContent, url)

		if err := s.Mailer.Send(ctx, []string{email}, "Sourcetool Team", subject, content); err != nil {
			return err
		}

		sendEmails = append(sendEmails, email)
	}

	return nil
}
</file>

<file path="internal/app/user/service.go">
package user

import (
	"context"
	"errors"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/app/permission"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	domainperm "github.com/trysourcetool/sourcetool/backend/internal/domain/permission"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
	"github.com/trysourcetool/sourcetool/backend/internal/jwt"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type Service interface {
	// User management methods
	GetMe(context.Context) (*dto.GetMeOutput, error)
	UpdateMe(context.Context, dto.UpdateMeInput) (*dto.UpdateMeOutput, error)
	SendUpdateMeEmailInstructions(context.Context, dto.SendUpdateMeEmailInstructionsInput) error
	UpdateMeEmail(context.Context, dto.UpdateMeEmailInput) (*dto.UpdateMeEmailOutput, error)

	// Organization methods
	List(context.Context) (*dto.ListUsersOutput, error)
	Update(ctx context.Context, in dto.UpdateUserInput) (*dto.UpdateUserOutput, error)
	Delete(ctx context.Context, in dto.DeleteUserInput) error

	// Invitation methods
	CreateUserInvitations(context.Context, dto.CreateUserInvitationsInput) (*dto.CreateUserInvitationsOutput, error)
	ResendUserInvitation(context.Context, dto.ResendUserInvitationInput) (*dto.ResendUserInvitationOutput, error)
}

type ServiceCE struct {
	*port.Dependencies
}

func NewServiceCE(d *port.Dependencies) *ServiceCE {
	return &ServiceCE{Dependencies: d}
}

func (s *ServiceCE) GetMe(ctx context.Context) (*dto.GetMeOutput, error) {
	currentUser := internal.CurrentUser(ctx)
	currentOrg := internal.CurrentOrganization(ctx)
	orgAccess, err := s.Repository.User().GetOrganizationAccess(ctx,
		user.OrganizationAccessByUserID(currentUser.ID),
		user.OrganizationAccessByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}
	role := orgAccess.Role

	return &dto.GetMeOutput{
		User: dto.UserFromModel(currentUser, currentOrg, role),
	}, nil
}

func (s *ServiceCE) UpdateMe(ctx context.Context, in dto.UpdateMeInput) (*dto.UpdateMeOutput, error) {
	currentUser := internal.CurrentUser(ctx)

	if in.FirstName != nil {
		currentUser.FirstName = internal.SafeValue(in.FirstName)
	}
	if in.LastName != nil {
		currentUser.LastName = internal.SafeValue(in.LastName)
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		return tx.User().Update(ctx, currentUser)
	}); err != nil {
		return nil, err
	}

	org, orgAccess, err := s.getUserOrganizationInfo(ctx)
	if err != nil {
		return nil, err
	}

	var role user.UserOrganizationRole
	if orgAccess != nil {
		role = orgAccess.Role
	}

	return &dto.UpdateMeOutput{
		User: dto.UserFromModel(currentUser, org, role),
	}, nil
}

// SendUpdateMeEmailInstructions sends instructions for updating a user's email address.
func (s *ServiceCE) SendUpdateMeEmailInstructions(ctx context.Context, in dto.SendUpdateMeEmailInstructionsInput) error {
	// Validate email and confirmation match
	if in.Email != in.EmailConfirmation {
		return errdefs.ErrInvalidArgument(errors.New("email and email confirmation do not match"))
	}

	// Check if email already exists
	exists, err := s.Repository.User().IsEmailExists(ctx, in.Email)
	if err != nil {
		return err
	}
	if exists {
		return errdefs.ErrUserEmailAlreadyExists(errors.New("email already exists"))
	}

	// Get current user and organization
	currentUser := internal.CurrentUser(ctx)
	currentOrg := internal.CurrentOrganization(ctx)

	// Create token for email update
	tok, err := createUpdateEmailToken(currentUser.ID.String(), in.Email)
	if err != nil {
		return err
	}

	// Build update URL
	url, err := buildUpdateEmailURL(internal.SafeValue(currentOrg.Subdomain), tok)
	if err != nil {
		return err
	}

	return s.sendUpdateEmailInstructions(ctx, in.Email, currentUser.FirstName, url)
}

func (s *ServiceCE) UpdateMeEmail(ctx context.Context, in dto.UpdateMeEmailInput) (*dto.UpdateMeEmailOutput, error) {
	c, err := jwt.ParseToken[*jwt.UserClaims](in.Token)
	if err != nil {
		return nil, err
	}

	if c.Subject != jwt.UserSignatureSubjectUpdateEmail {
		return nil, errdefs.ErrInvalidArgument(errors.New("invalid jwt subject"))
	}

	userID, err := uuid.FromString(c.UserID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}
	u, err := s.Repository.User().Get(ctx, user.ByID(userID))
	if err != nil {
		return nil, err
	}

	currentUser := internal.CurrentUser(ctx)
	if u.ID != currentUser.ID {
		return nil, errdefs.ErrUnauthenticated(errors.New("unauthorized"))
	}

	currentUser.Email = c.Email

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		return tx.User().Update(ctx, currentUser)
	}); err != nil {
		return nil, err
	}

	org, orgAccess, err := s.getUserOrganizationInfo(ctx)
	if err != nil {
		return nil, err
	}

	var role user.UserOrganizationRole
	if orgAccess != nil {
		role = orgAccess.Role
	}

	return &dto.UpdateMeEmailOutput{
		User: dto.UserFromModel(currentUser, org, role),
	}, nil
}

func (s *ServiceCE) List(ctx context.Context) (*dto.ListUsersOutput, error) {
	currentOrg := internal.CurrentOrganization(ctx)

	users, err := s.Repository.User().List(ctx, user.ByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	userInvitations, err := s.Repository.User().ListInvitations(ctx, user.InvitationByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}

	orgAccesses, err := s.Repository.User().ListOrganizationAccesses(ctx, user.OrganizationAccessByOrganizationID(currentOrg.ID))
	if err != nil {
		return nil, err
	}
	roleMap := make(map[uuid.UUID]user.UserOrganizationRole)
	for _, oa := range orgAccesses {
		roleMap[oa.UserID] = oa.Role
	}

	usersOut := make([]*dto.User, 0, len(users))
	for _, u := range users {
		usersOut = append(usersOut, dto.UserFromModel(u, nil, roleMap[u.ID]))
	}

	userInvitationsOut := make([]*dto.UserInvitation, 0, len(userInvitations))
	for _, ui := range userInvitations {
		userInvitationsOut = append(userInvitationsOut, dto.UserInvitationFromModel(ui))
	}

	return &dto.ListUsersOutput{
		Users:           usersOut,
		UserInvitations: userInvitationsOut,
	}, nil
}

func (s *ServiceCE) Update(ctx context.Context, in dto.UpdateUserInput) (*dto.UpdateUserOutput, error) {
	userID, err := uuid.FromString(in.UserID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}
	u, err := s.Repository.User().Get(ctx, user.ByID(userID))
	if err != nil {
		return nil, err
	}

	currentOrg := internal.CurrentOrganization(ctx)
	if currentOrg == nil {
		return nil, errdefs.ErrUnauthenticated(errors.New("current organization not found"))
	}

	orgAccess, err := s.Repository.User().GetOrganizationAccess(ctx, user.OrganizationAccessByOrganizationID(currentOrg.ID), user.OrganizationAccessByUserID(u.ID))
	if err != nil {
		return nil, err
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if in.Role != nil {
			orgAccess.Role = user.UserOrganizationRoleFromString(internal.SafeValue(in.Role))

			if err := tx.User().UpdateOrganizationAccess(ctx, orgAccess); err != nil {
				return err
			}
		}

		if len(in.GroupIDs) != 0 {
			userGroups := make([]*user.UserGroup, 0, len(in.GroupIDs))
			for _, groupID := range in.GroupIDs {
				groupID, err := uuid.FromString(groupID)
				if err != nil {
					return err
				}
				userGroups = append(userGroups, &user.UserGroup{
					ID:      uuid.Must(uuid.NewV4()),
					UserID:  u.ID,
					GroupID: groupID,
				})
			}

			existingGroups, err := tx.User().ListGroups(ctx, user.GroupByUserID(u.ID))
			if err != nil {
				return err
			}

			if err := tx.User().BulkDeleteGroups(ctx, existingGroups); err != nil {
				return err
			}

			if err := tx.User().BulkInsertGroups(ctx, userGroups); err != nil {
				return err
			}
		}

		return nil
	}); err != nil {
		return nil, err
	}

	return &dto.UpdateUserOutput{
		User: dto.UserFromModel(u, currentOrg, orgAccess.Role),
	}, nil
}

func (s *ServiceCE) Delete(ctx context.Context, in dto.DeleteUserInput) error {
	checker := permission.NewChecker(s.Repository)
	if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditUser); err != nil {
		return err
	}

	currentUser := internal.CurrentUser(ctx)
	currentOrg := internal.CurrentOrganization(ctx)
	if currentOrg == nil {
		return errdefs.ErrUnauthenticated(errors.New("current organization not found"))
	}

	userIDToRemove, err := uuid.FromString(in.UserID)
	if err != nil {
		return errdefs.ErrInvalidArgument(err)
	}

	if currentUser.ID == userIDToRemove {
		return errdefs.ErrPermissionDenied(errors.New("cannot remove yourself from the organization"))
	}

	userToRemove, err := s.Repository.User().Get(ctx, user.ByID(userIDToRemove))
	if err != nil {
		return err
	}

	orgAccess, err := s.Repository.User().GetOrganizationAccess(ctx,
		user.OrganizationAccessByUserID(userToRemove.ID),
		user.OrganizationAccessByOrganizationID(currentOrg.ID))
	if err != nil {
		if errdefs.IsUserOrganizationAccessNotFound(err) {
			return nil
		}
		return err
	}

	if orgAccess.Role == user.UserOrganizationRoleAdmin {
		adminAccesses, err := s.Repository.User().ListOrganizationAccesses(ctx,
			user.OrganizationAccessByOrganizationID(currentOrg.ID),
			user.OrganizationAccessByRole(user.UserOrganizationRoleAdmin))
		if err != nil {
			return err
		}
		if len(adminAccesses) <= 1 {
			return errdefs.ErrPermissionDenied(errors.New("cannot remove the last admin from the organization"))
		}
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.User().DeleteOrganizationAccess(ctx, orgAccess); err != nil {
			return err
		}

		apiKeys, err := tx.APIKey().List(ctx, apikey.ByUserID(userToRemove.ID), apikey.ByOrganizationID(currentOrg.ID))
		if err != nil {
			return err
		}
		for _, apiKey := range apiKeys {
			if err := tx.APIKey().Delete(ctx, apiKey); err != nil {
				return err
			}
		}

		userGroups, err := tx.User().ListGroups(ctx, user.GroupByUserID(userToRemove.ID), user.GroupByOrganizationID(currentOrg.ID))
		if err != nil {
			return err
		}

		if len(userGroups) > 0 {
			if err := tx.User().BulkDeleteGroups(ctx, userGroups); err != nil {
				return err
			}
		}

		return nil
	}); err != nil {
		return err
	}

	return nil
}

func (s *ServiceCE) CreateUserInvitations(ctx context.Context, in dto.CreateUserInvitationsInput) (*dto.CreateUserInvitationsOutput, error) {
	checker := permission.NewChecker(s.Repository)
	if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditUser); err != nil {
		return nil, err
	}

	o := internal.CurrentOrganization(ctx)
	u := internal.CurrentUser(ctx)

	invitations := make([]*user.UserInvitation, 0)
	emailURLs := make(map[string]string)
	for _, email := range in.Emails {
		emailExsts, err := s.Repository.User().IsInvitationEmailExists(ctx, o.ID, email)
		if err != nil {
			return nil, err
		}
		if emailExsts {
			continue
		}

		tok, err := createInvitationToken(email)
		if err != nil {
			return nil, err
		}

		url, err := buildInvitationURL(internal.SafeValue(o.Subdomain), tok, email)
		if err != nil {
			return nil, err
		}

		emailURLs[email] = url

		invitations = append(invitations, &user.UserInvitation{
			ID:             uuid.Must(uuid.NewV4()),
			OrganizationID: o.ID,
			Email:          email,
			Role:           user.UserOrganizationRoleFromString(in.Role),
		})
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.User().BulkInsertInvitations(ctx, invitations); err != nil {
			return err
		}

		if err := s.sendInvitationEmail(ctx, u.FullName(), emailURLs); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	usersInvitationsOut := make([]*dto.UserInvitation, 0, len(invitations))
	for _, ui := range invitations {
		usersInvitationsOut = append(usersInvitationsOut, dto.UserInvitationFromModel(ui))
	}

	return &dto.CreateUserInvitationsOutput{
		UserInvitations: usersInvitationsOut,
	}, nil
}

func (s *ServiceCE) ResendUserInvitation(ctx context.Context, in dto.ResendUserInvitationInput) (*dto.ResendUserInvitationOutput, error) {
	checker := permission.NewChecker(s.Repository)
	if err := checker.AuthorizeOperation(ctx, domainperm.OperationEditUser); err != nil {
		return nil, err
	}

	invitationID, err := uuid.FromString(in.InvitationID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}

	userInvitation, err := s.Repository.User().GetInvitation(ctx, user.InvitationByID(invitationID))
	if err != nil {
		return nil, err
	}

	o := internal.CurrentOrganization(ctx)
	if userInvitation.OrganizationID != o.ID {
		return nil, errdefs.ErrUnauthenticated(errors.New("invalid organization"))
	}

	u := internal.CurrentUser(ctx)

	tok, err := createInvitationToken(userInvitation.Email)
	if err != nil {
		return nil, err
	}

	url, err := buildInvitationURL(internal.SafeValue(o.Subdomain), tok, userInvitation.Email)
	if err != nil {
		return nil, err
	}

	emailURLs := map[string]string{userInvitation.Email: url}
	if err := s.sendInvitationEmail(ctx, u.FullName(), emailURLs); err != nil {
		return nil, err
	}

	return &dto.ResendUserInvitationOutput{
		UserInvitation: dto.UserInvitationFromModel(userInvitation),
	}, nil
}

// getUserOrganizationInfo is a convenience wrapper that retrieves organization
// and access information for the current user from the context.
func (s *ServiceCE) getUserOrganizationInfo(ctx context.Context) (*organization.Organization, *user.UserOrganizationAccess, error) {
	return s.getOrganizationInfo(ctx, internal.CurrentUser(ctx))
}

// getOrganizationInfo retrieves organization and access information for the specified user.
// It handles both cloud and self-hosted editions with appropriate subdomain logic.
func (s *ServiceCE) getOrganizationInfo(ctx context.Context, u *user.User) (*organization.Organization, *user.UserOrganizationAccess, error) {
	if u == nil {
		return nil, nil, errdefs.ErrInvalidArgument(errors.New("user cannot be nil"))
	}

	subdomain := internal.Subdomain(ctx)
	isCloudWithSubdomain := config.Config.IsCloudEdition && subdomain != "" && subdomain != "auth"

	// Different strategies for cloud vs. self-hosted or auth subdomain
	if isCloudWithSubdomain {
		return s.getOrganizationBySubdomain(ctx, u, subdomain)
	}

	return s.getDefaultOrganizationForUser(ctx, u)
}

// getOrganizationBySubdomain retrieves an organization by subdomain and verifies user access.
func (s *ServiceCE) getOrganizationBySubdomain(ctx context.Context, u *user.User, subdomain string) (*organization.Organization, *user.UserOrganizationAccess, error) {
	// Get organization by subdomain
	org, err := s.Repository.Organization().Get(ctx, organization.BySubdomain(subdomain))
	if err != nil {
		return nil, nil, err
	}

	// Verify user has access to this organization
	orgAccess, err := s.Repository.User().GetOrganizationAccess(ctx,
		user.OrganizationAccessByOrganizationID(org.ID),
		user.OrganizationAccessByUserID(u.ID))
	if err != nil {
		return nil, nil, err
	}

	return org, orgAccess, nil
}

// getDefaultOrganizationForUser retrieves the default organization for a user
// (typically the most recently created one).
func (s *ServiceCE) getDefaultOrganizationForUser(ctx context.Context, u *user.User) (*organization.Organization, *user.UserOrganizationAccess, error) {
	// Get user's organization access
	orgAccess, err := s.Repository.User().GetOrganizationAccess(ctx,
		user.OrganizationAccessByUserID(u.ID),
		user.OrganizationAccessOrderBy("created_at DESC"))
	if err != nil {
		return nil, nil, err
	}

	// Get the organization
	org, err := s.Repository.Organization().Get(ctx, organization.ByID(orgAccess.OrganizationID))
	if err != nil {
		return nil, nil, err
	}

	return org, orgAccess, nil
}
</file>

<file path="internal/app/user/sign.go">
package user

import (
	"time"

	gojwt "github.com/golang-jwt/jwt/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/auth"
	"github.com/trysourcetool/sourcetool/backend/internal/jwt"
)

func createUpdateEmailToken(userID, email string) (string, error) {
	return jwt.SignToken(&jwt.UserClaims{
		UserID: userID,
		Email:  email,
		RegisteredClaims: gojwt.RegisteredClaims{
			ExpiresAt: gojwt.NewNumericDate(time.Now().Add(auth.EmailTokenExpiration)),
			Issuer:    jwt.Issuer,
			Subject:   jwt.UserSignatureSubjectUpdateEmail,
		},
	})
}

func createInvitationToken(email string) (string, error) {
	return jwt.SignToken(&jwt.UserClaims{
		Email: email,
		RegisteredClaims: gojwt.RegisteredClaims{
			ExpiresAt: gojwt.NewNumericDate(time.Now().Add(auth.EmailTokenExpiration)),
			Issuer:    jwt.Issuer,
			Subject:   jwt.UserSignatureSubjectInvitation,
		},
	})
}
</file>

<file path="internal/app/user/url_test.go">
package user

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/trysourcetool/sourcetool/backend/config"
)

func TestBuildUpdateEmailURL(t *testing.T) {
	// Setup test config
	config.Config = &config.Cfg{
		BaseURL:      "https://example.com",
		SSL:          true,
		Protocol:     "https",
		BaseDomain:   "example.com",
		BaseHostname: "example.com",
	}

	tests := []struct {
		name      string
		subdomain string
		token     string
		expected  string
	}{
		{
			name:      "valid subdomain and token",
			subdomain: "test",
			token:     "test-token",
			expected:  "https://example.com/users/email/update/confirm?token=test-token",
		},
		{
			name:      "empty subdomain",
			subdomain: "",
			token:     "test-token",
			expected:  "https://example.com/users/email/update/confirm?token=test-token",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := buildUpdateEmailURL(tt.subdomain, tt.token)
			assert.NoError(t, err)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestBuildInvitationURL(t *testing.T) {
	// Setup test config
	config.Config = &config.Cfg{
		BaseURL:      "https://example.com",
		SSL:          true,
		Protocol:     "https",
		BaseDomain:   "example.com",
		BaseHostname: "example.com",
	}

	tests := []struct {
		name      string
		subdomain string
		token     string
		email     string
		expected  string
	}{
		{
			name:      "new user invitation",
			subdomain: "test",
			token:     "test-token",
			email:     "test@example.com",
			expected:  "https://example.com/auth/invitations/login?email=test%40example.com&token=test-token",
		},
		{
			name:      "existing user invitation",
			subdomain: "test",
			token:     "test-token",
			email:     "existing@example.com",
			expected:  "https://example.com/auth/invitations/login?email=existing%40example.com&token=test-token",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := buildInvitationURL(tt.subdomain, tt.token, tt.email)
			assert.NoError(t, err)
			assert.Equal(t, tt.expected, result)
		})
	}
}
</file>

<file path="internal/app/user/url.go">
package user

import (
	"path"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

func buildUpdateEmailURL(subdomain, token string) (string, error) {
	return urlx.BuildURL(config.Config.OrgBaseURL(subdomain), path.Join("users", "email", "update", "confirm"), map[string]string{
		"token": token,
	})
}

func buildInvitationURL(subdomain, token, email string) (string, error) {
	return urlx.BuildURL(config.Config.OrgBaseURL(subdomain), path.Join("auth", "invitations", "login"), map[string]string{
		"token": token,
		"email": email,
	})
}
</file>

<file path="internal/app/ws/service.go">
package ws

import (
	"context"
	"errors"

	"github.com/gofrs/uuid/v5"
	"github.com/gorilla/websocket"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/page"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/session"
	websocketv1 "github.com/trysourcetool/sourcetool/backend/internal/pb/go/websocket/v1"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/ws/message"
	"github.com/trysourcetool/sourcetool/backend/logger"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type Service interface {
	InitializeClient(context.Context, *websocket.Conn, *websocketv1.Message) error
	InitializeHost(context.Context, *websocket.Conn, string, *websocketv1.Message) (*hostinstance.HostInstance, error)
	RerunPage(context.Context, *websocket.Conn, *websocketv1.Message) error
	RenderWidget(context.Context, *websocket.Conn, *websocketv1.Message) error
	CloseSession(context.Context, *websocket.Conn, *websocketv1.Message) error
	ScriptFinished(context.Context, *websocket.Conn, *websocketv1.Message) error
	Exception(context.Context, *websocket.Conn, *websocketv1.Message) error
	UpdateStatus(context.Context, dto.UpdateHostInstanceStatusInput) (*dto.UpdateHostInstanceStatusOutput, error)
}

type ServiceCE struct {
	*port.Dependencies
}

func NewServiceCE(d *port.Dependencies) *ServiceCE {
	return &ServiceCE{Dependencies: d}
}

func (s *ServiceCE) InitializeClient(ctx context.Context, conn *websocket.Conn, msg *websocketv1.Message) error {
	in := msg.GetInitializeClient()
	if in == nil {
		return errors.New("invalid message")
	}

	pageID, err := uuid.FromString(in.PageId)
	if err != nil {
		return errdefs.ErrInvalidArgument(err)
	}

	page, err := s.Repository.Page().Get(ctx, page.ByID(pageID))
	if err != nil {
		return err
	}

	currentOrg := internal.CurrentOrganization(ctx)
	if currentOrg.ID != page.OrganizationID {
		return errdefs.ErrPermissionDenied(errors.New("organization mismatch"))
	}

	apiKey, err := s.Repository.APIKey().Get(ctx, apikey.ByID(page.APIKeyID))
	if err != nil {
		return err
	}

	hostInstances, err := s.Repository.HostInstance().List(ctx, hostinstance.ByAPIKeyID(apiKey.ID))
	if err != nil {
		return err
	}

	// Try to find an online host that responds to ping
	var onlineHostInstance *hostinstance.HostInstance
	for _, hostInstance := range hostInstances {
		if hostInstance.Status == hostinstance.HostInstanceStatusOnline {
			if err := s.WSManager.PingConnectedHost(hostInstance.ID); err != nil {
				// Update host status to offline if ping fails
				hostInstance.Status = hostinstance.HostInstanceStatusOffline
				if err := s.Repository.HostInstance().Update(ctx, hostInstance); err != nil {
					logger.Logger.Sugar().Errorf("Failed to update host status: %v", err)
				}
				continue
			}

			onlineHostInstance = hostInstance
			break
		}
	}

	// If no online host found, try hosts that might be unreachable
	if onlineHostInstance == nil {
		for _, hostInstance := range hostInstances {
			if hostInstance.Status == hostinstance.HostInstanceStatusUnreachable {
				if err := s.WSManager.PingConnectedHost(hostInstance.ID); err == nil {
					// Host is actually reachable, update its status
					hostInstance.Status = hostinstance.HostInstanceStatusOnline
					if err := s.Repository.HostInstance().Update(ctx, hostInstance); err != nil {
						logger.Logger.Sugar().Errorf("Failed to update host status: %v", err)
						continue
					}
					onlineHostInstance = hostInstance
					break
				}
			}
		}
	}

	if onlineHostInstance == nil {
		return errdefs.ErrHostInstanceStatusNotOnline(errors.New("no available host instances"))
	}

	currentUser := internal.CurrentUser(ctx)

	var sess *session.Session
	var sessionExists bool
	if internal.SafeValue(in.SessionId) != "" {
		sessionID, err := uuid.FromString(internal.SafeValue(in.SessionId))
		if err != nil {
			return errdefs.ErrSessionNotFound(err)
		}

		sess, err = s.Repository.Session().Get(ctx, session.ByID(sessionID))
		if err != nil {
			return err
		}
		sessionExists = true
	} else {
		sess = &session.Session{
			ID:             uuid.Must(uuid.NewV4()),
			OrganizationID: page.OrganizationID,
			APIKeyID:       page.APIKeyID,
			HostInstanceID: onlineHostInstance.ID,
			UserID:         currentUser.ID,
		}
		sessionExists = false
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if !sessionExists {
			if err := tx.Session().Create(ctx, sess); err != nil {
				return err
			}
		}
		return nil
	}); err != nil {
		return err
	}

	sess, err = s.Repository.Session().Get(ctx, session.ByID(sess.ID))
	if err != nil {
		return err
	}

	if err := message.SendResponse(conn, &websocketv1.Message{
		Id: msg.Id,
		Type: &websocketv1.Message_InitializeClientCompleted{
			InitializeClientCompleted: &websocketv1.InitializeClientCompleted{
				SessionId: sess.ID.String(),
			},
		},
	}); err != nil {
		return err
	}

	s.WSManager.SetConnectedClient(sess, conn)

	if err := s.WSManager.SendToHost(ctx, onlineHostInstance.ID, &websocketv1.Message{
		Id: uuid.Must(uuid.NewV4()).String(),
		Type: &websocketv1.Message_InitializeClient{
			InitializeClient: &websocketv1.InitializeClient{
				SessionId: internal.NilValue(sess.ID.String()),
				PageId:    page.ID.String(),
			},
		},
	}); err != nil {
		s.Repository.Session().Delete(ctx, sess)
		s.WSManager.DisconnectClient(sess.ID)
		logger.Logger.Sugar().Errorf("Failed to send initialize client message to host: %v", err)
		return err
	}

	return nil
}

func (s *ServiceCE) InitializeHost(ctx context.Context, conn *websocket.Conn, instanceID string, msg *websocketv1.Message) (*hostinstance.HostInstance, error) {
	in := msg.GetInitializeHost()
	if in == nil {
		return nil, errors.New("invalid message")
	}

	apikey, err := s.Repository.APIKey().Get(ctx, apikey.ByKey(in.ApiKey))
	if err != nil {
		return nil, err
	}

	hostInstanceID, err := uuid.FromString(instanceID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}

	hostInstance, err := s.Repository.HostInstance().Get(ctx, hostinstance.ByID(hostInstanceID))
	if err != nil && !errdefs.IsHostInstanceNotFound(err) {
		return nil, err
	}

	hostExists := hostInstance != nil

	if !hostExists {
		hostInstance = &hostinstance.HostInstance{
			ID:             hostInstanceID,
			OrganizationID: apikey.OrganizationID,
			APIKeyID:       apikey.ID,
		}
	}

	hostInstance.SDKName = in.SdkName
	hostInstance.SDKVersion = in.SdkVersion
	hostInstance.Status = hostinstance.HostInstanceStatusOnline

	existingPages, err := s.Repository.Page().List(ctx, page.ByAPIKeyID(apikey.ID))
	if err != nil {
		return nil, err
	}

	existingPageMap := make(map[string]*page.Page)
	for _, p := range existingPages {
		existingPageMap[p.ID.String()] = p
	}

	requestPageIDs := make(map[string]struct{})
	for _, p := range in.Pages {
		requestPageIDs[p.Id] = struct{}{}
	}

	insertPages := make([]*page.Page, 0)
	updatePages := make([]*page.Page, 0)
	deletePages := make([]*page.Page, 0)
	for _, reqPage := range in.Pages {
		if existingPage, ok := existingPageMap[reqPage.Id]; ok {
			existingPage.Name = reqPage.Name
			existingPage.Route = reqPage.Route
			existingPage.Path = reqPage.Path
			updatePages = append(updatePages, existingPage)
		} else {
			pageID, err := uuid.FromString(reqPage.Id)
			if err != nil {
				return nil, err
			}
			newPage := &page.Page{
				ID:             pageID,
				OrganizationID: apikey.OrganizationID,
				EnvironmentID:  apikey.EnvironmentID,
				APIKeyID:       apikey.ID,
				Name:           reqPage.Name,
				Route:          reqPage.Route,
				Path:           reqPage.Path,
			}
			insertPages = append(insertPages, newPage)
		}
	}

	for _, existingPage := range existingPages {
		if _, exists := requestPageIDs[existingPage.ID.String()]; !exists {
			deletePages = append(deletePages, existingPage)
		}
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if hostExists {
			if err := tx.HostInstance().Update(ctx, hostInstance); err != nil {
				return err
			}
		} else {
			if err := tx.HostInstance().Create(ctx, hostInstance); err != nil {
				return err
			}
		}

		if len(deletePages) > 0 {
			if err := tx.Page().BulkDelete(ctx, deletePages); err != nil {
				return err
			}
		}
		if len(updatePages) > 0 {
			if err := tx.Page().BulkUpdate(ctx, updatePages); err != nil {
				return err
			}
		}
		if len(insertPages) > 0 {
			if err := tx.Page().BulkInsert(ctx, insertPages); err != nil {
				return err
			}
		}

		return nil
	}); err != nil {
		return nil, err
	}

	s.WSManager.SetConnectedHost(hostInstance, apikey, conn)

	if err := message.SendResponse(conn, &websocketv1.Message{
		Id: msg.Id,
		Type: &websocketv1.Message_InitializeHostCompleted{
			InitializeHostCompleted: &websocketv1.InitializeHostCompleted{
				HostInstanceId: hostInstance.ID.String(),
			},
		},
	}); err != nil {
		return nil, err
	}

	return hostInstance, nil
}

func (s *ServiceCE) RerunPage(ctx context.Context, conn *websocket.Conn, msg *websocketv1.Message) error {
	in := msg.GetRerunPage()
	if in == nil {
		return errors.New("invalid message")
	}

	sessionID, err := uuid.FromString(in.SessionId)
	if err != nil {
		return err
	}

	sess, err := s.Repository.Session().Get(ctx, session.ByID(sessionID))
	if err != nil {
		return err
	}

	pageID, err := uuid.FromString(in.PageId)
	if err != nil {
		return err
	}

	page, err := s.Repository.Page().Get(ctx, page.ByID(pageID), page.BySessionID(sess.ID))
	if err != nil {
		return err
	}

	if err := s.WSManager.SendToHost(ctx, sess.HostInstanceID, &websocketv1.Message{
		Id: msg.Id,
		Type: &websocketv1.Message_RerunPage{
			RerunPage: &websocketv1.RerunPage{
				SessionId: sess.ID.String(),
				PageId:    page.ID.String(),
				States:    in.States,
			},
		},
	}); err != nil {
		return err
	}

	return nil
}

func (s *ServiceCE) RenderWidget(ctx context.Context, conn *websocket.Conn, msg *websocketv1.Message) error {
	in := msg.GetRenderWidget()
	if in == nil {
		return errors.New("invalid message")
	}

	sessionID, err := uuid.FromString(in.SessionId)
	if err != nil {
		return err
	}

	_, err = s.Repository.Session().Get(ctx, session.ByID(sessionID))
	if err != nil {
		return err
	}

	if err := s.WSManager.SendToClient(ctx, sessionID, msg); err != nil {
		logger.Logger.Sugar().Errorf("Failed to send render widget message to client: %v", err)
		return err
	}

	return nil
}

func (s *ServiceCE) CloseSession(ctx context.Context, conn *websocket.Conn, msg *websocketv1.Message) error {
	in := msg.GetCloseSession()
	if in == nil {
		return errors.New("invalid message")
	}

	sessionID, err := uuid.FromString(in.SessionId)
	if err != nil {
		return errdefs.ErrAPIKeyNotFound(err)
	}

	sess, err := s.Repository.Session().Get(ctx, session.ByID(sessionID))
	if err != nil {
		return err
	}

	_, err = s.Repository.Page().Get(ctx, page.ByAPIKeyID(sess.APIKeyID), page.BySessionID(sess.ID))
	if err != nil {
		return err
	}

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.Session().Delete(ctx, sess); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return err
	}

	if err := s.WSManager.SendToHost(ctx, sess.HostInstanceID, &websocketv1.Message{
		Id: uuid.Must(uuid.NewV4()).String(),
		Type: &websocketv1.Message_CloseSession{
			CloseSession: &websocketv1.CloseSession{
				SessionId: sess.ID.String(),
			},
		},
	}); err != nil {
		logger.Logger.Sugar().Warnf("Failed to send close session message to host %s for session %s: %v", sess.HostInstanceID, sess.ID, err)
	}

	s.WSManager.DisconnectClient(sess.ID)

	return nil
}

func (s *ServiceCE) ScriptFinished(ctx context.Context, conn *websocket.Conn, msg *websocketv1.Message) error {
	in := msg.GetScriptFinished()
	if in == nil {
		return errors.New("invalid message")
	}

	logger.Logger.Sugar().Debug("Payload: ", in)

	sessionID, err := uuid.FromString(in.SessionId)
	if err != nil {
		return errdefs.ErrInvalidArgument(err)
	}

	_, err = s.Repository.Session().Get(ctx, session.ByID(sessionID))
	if err != nil {
		return err
	}

	if err := s.WSManager.SendToClient(ctx, sessionID, msg); err != nil {
		logger.Logger.Sugar().Errorf("Failed to send script finished message to client: %v", err)
	}

	return nil
}

func (s *ServiceCE) Exception(ctx context.Context, conn *websocket.Conn, msg *websocketv1.Message) error {
	in := msg.GetException()
	if in == nil {
		return errors.New("invalid message")
	}

	sessionID, err := uuid.FromString(in.SessionId)
	if err != nil {
		return errdefs.ErrInvalidArgument(err)
	}

	_, err = s.Repository.Session().Get(ctx, session.ByID(sessionID))
	if err != nil {
		return err
	}

	if err := s.WSManager.SendToClient(ctx, sessionID, msg); err != nil {
		logger.Logger.Sugar().Errorf("Failed to send exception message to client: %v", err)
	}

	return nil
}

func (s *ServiceCE) UpdateStatus(ctx context.Context, in dto.UpdateHostInstanceStatusInput) (*dto.UpdateHostInstanceStatusOutput, error) {
	hostInstanceID, err := uuid.FromString(in.ID)
	if err != nil {
		return nil, errdefs.ErrInvalidArgument(err)
	}

	host, err := s.Repository.HostInstance().Get(ctx, hostinstance.ByID(hostInstanceID))
	if err != nil {
		return nil, err
	}

	host.Status = in.Status

	if err := s.Repository.RunTransaction(func(tx port.Transaction) error {
		if err := tx.HostInstance().Update(ctx, host); err != nil {
			return err
		}
		return nil
	}); err != nil {
		return nil, err
	}

	return &dto.UpdateHostInstanceStatusOutput{
		HostInstance: dto.HostInstanceFromModel(host),
	}, nil
}
</file>

<file path="internal/ctxdata/internal.go">
package ctxdata

import (
	"context"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
)

type ctxKey string

const (
	CurrentUserCtxKey         ctxKey = "currentUser"
	CurrentOrganizationCtxKey ctxKey = "currentOrganization"
	SubdomainCtxKey           ctxKey = "subdomain"
)

func CurrentUser(ctx context.Context) *user.User {
	v, ok := ctx.Value(CurrentUserCtxKey).(*user.User)
	if !ok {
		return nil
	}
	return v
}

func CurrentOrganization(ctx context.Context) *organization.Organization {
	v, ok := ctx.Value(CurrentOrganizationCtxKey).(*organization.Organization)
	if !ok {
		return nil
	}
	return v
}

func Subdomain(ctx context.Context) string {
	v, ok := ctx.Value(SubdomainCtxKey).(string)
	if !ok {
		return ""
	}
	return v
}

func withUser(ctx context.Context, user *user.User) context.Context {
	return context.WithValue(ctx, CurrentUserCtxKey, user)
}

func withOrganization(ctx context.Context, org *organization.Organization) context.Context {
	return context.WithValue(ctx, CurrentOrganizationCtxKey, org)
}

func withSubdomain(ctx context.Context, subdomain string) context.Context {
	return context.WithValue(ctx, SubdomainCtxKey, subdomain)
}

func NewBackgroundContext(ctx context.Context) context.Context {
	bgCtx := context.Background()

	if user := CurrentUser(ctx); user != nil {
		bgCtx = withUser(bgCtx, user)
	}
	if org := CurrentOrganization(ctx); org != nil {
		bgCtx = withOrganization(bgCtx, org)
	}
	if subdomain := Subdomain(ctx); subdomain != "" {
		bgCtx = withSubdomain(bgCtx, subdomain)
	}

	return bgCtx
}
</file>

<file path="internal/domain/apikey/apikey.go">
package apikey

import (
	"time"

	"github.com/gofrs/uuid/v5"
)

type APIKey struct {
	ID             uuid.UUID `db:"id"`
	OrganizationID uuid.UUID `db:"organization_id"`
	EnvironmentID  uuid.UUID `db:"environment_id"`
	UserID         uuid.UUID `db:"user_id"`
	Name           string    `db:"name"`
	Key            string    `db:"key"`
	CreatedAt      time.Time `db:"created_at"`
	UpdatedAt      time.Time `db:"updated_at"`
}
</file>

<file path="internal/domain/apikey/repository.go">
package apikey

import (
	"context"

	"github.com/gofrs/uuid/v5"
)

type Query interface{ isQuery() }

type ByIDQuery struct{ ID uuid.UUID }

func (ByIDQuery) isQuery() {}

func ByID(id uuid.UUID) Query { return ByIDQuery{ID: id} }

type ByOrganizationIDQuery struct{ OrganizationID uuid.UUID }

func (ByOrganizationIDQuery) isQuery() {}

func ByOrganizationID(organizationID uuid.UUID) Query {
	return ByOrganizationIDQuery{OrganizationID: organizationID}
}

type ByEnvironmentIDQuery struct{ EnvironmentID uuid.UUID }

func (ByEnvironmentIDQuery) isQuery() {}

func ByEnvironmentID(environmentID uuid.UUID) Query {
	return ByEnvironmentIDQuery{EnvironmentID: environmentID}
}

type ByEnvironmentIDsQuery struct{ EnvironmentIDs []uuid.UUID }

func (ByEnvironmentIDsQuery) isQuery() {}

func ByEnvironmentIDs(environmentIDs []uuid.UUID) Query {
	return ByEnvironmentIDsQuery{EnvironmentIDs: environmentIDs}
}

type ByUserIDQuery struct{ UserID uuid.UUID }

func (ByUserIDQuery) isQuery() {}

func ByUserID(userID uuid.UUID) Query { return ByUserIDQuery{UserID: userID} }

type ByKeyQuery struct{ Key string }

func (ByKeyQuery) isQuery() {}

func ByKey(key string) Query { return ByKeyQuery{Key: key} }

type Repository interface {
	Get(context.Context, ...Query) (*APIKey, error)
	List(context.Context, ...Query) ([]*APIKey, error)
	Create(context.Context, *APIKey) error
	Update(context.Context, *APIKey) error
	Delete(context.Context, *APIKey) error
}
</file>

<file path="internal/domain/auth/auth.go">
package auth

import (
	"time"

	"github.com/trysourcetool/sourcetool/backend/config"
)

const (
	EmailTokenExpiration     = time.Duration(24) * time.Hour
	tokenExpiration          = time.Duration(60) * time.Minute
	tokenExpirationDev       = time.Duration(365*24) * time.Hour
	RefreshTokenExpiration   = time.Duration(30*24) * time.Hour
	XSRFTokenExpiration      = time.Duration(30*24) * time.Hour
	RefreshTokenMaxAgeBuffer = time.Duration(7*24) * time.Hour
	TmpTokenExpiration       = time.Duration(30) * time.Minute

	SaveAuthPath = "/api/v1/auth/save"
)

func TokenExpiration() time.Duration {
	if config.Config.Env == config.EnvLocal {
		return tokenExpirationDev
	}
	return tokenExpiration
}
</file>

<file path="internal/domain/environment/environment.go">
package environment

import (
	"crypto/rand"
	"fmt"
	"time"

	"github.com/gofrs/uuid/v5"
)

const (
	EnvironmentNameProduction   = "Production"
	EnvironmentNameDevelopment  = "Development"
	EnvironmentSlugProduction   = "production"
	EnvironmentSlugDevelopment  = "development"
	EnvironmentColorProduction  = "#9333EA"
	EnvironmentColorDevelopment = "#33ADEA"
)

type Environment struct {
	ID             uuid.UUID `db:"id"`
	OrganizationID uuid.UUID `db:"organization_id"`
	Name           string    `db:"name"`
	Slug           string    `db:"slug"`
	Color          string    `db:"color"`
	CreatedAt      time.Time `db:"created_at"`
	UpdatedAt      time.Time `db:"updated_at"`
}

func (e *Environment) GenerateAPIKey() (string, error) {
	randomBytes := make([]byte, 32)
	if _, err := rand.Read(randomBytes); err != nil {
		return "", err
	}

	const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
	randomStr := make([]byte, 51)
	for i := range randomStr {
		randomStr[i] = charset[randomBytes[i%len(randomBytes)]%byte(len(charset))]
	}

	return fmt.Sprintf("%s_%s", e.Slug, string(randomStr)), nil
}
</file>

<file path="internal/domain/environment/repository.go">
package environment

import (
	"context"

	"github.com/gofrs/uuid/v5"
)

type Query interface{ isQuery() }

type ByIDQuery struct{ ID uuid.UUID }

func (ByIDQuery) isQuery() {}

func ByID(id uuid.UUID) Query { return ByIDQuery{ID: id} }

type ByOrganizationIDQuery struct{ OrganizationID uuid.UUID }

func (ByOrganizationIDQuery) isQuery() {}

func ByOrganizationID(organizationID uuid.UUID) Query {
	return ByOrganizationIDQuery{OrganizationID: organizationID}
}

type BySlugQuery struct{ Slug string }

func (BySlugQuery) isQuery() {}

func BySlug(slug string) Query { return BySlugQuery{Slug: slug} }

type Repository interface {
	Get(context.Context, ...Query) (*Environment, error)
	List(context.Context, ...Query) ([]*Environment, error)
	Create(context.Context, *Environment) error
	Update(context.Context, *Environment) error
	Delete(context.Context, *Environment) error
	IsSlugExistsInOrganization(context.Context, uuid.UUID, string) (bool, error)
	BulkInsert(context.Context, []*Environment) error
	MapByAPIKeyIDs(context.Context, []uuid.UUID) (map[uuid.UUID]*Environment, error)
}
</file>

<file path="internal/domain/group/group.go">
package group

import (
	"time"

	"github.com/gofrs/uuid/v5"
)

type Group struct {
	ID             uuid.UUID `db:"id"`
	OrganizationID uuid.UUID `db:"organization_id"`
	Name           string    `db:"name"`
	Slug           string    `db:"slug"`
	CreatedAt      time.Time `db:"created_at"`
	UpdatedAt      time.Time `db:"updated_at"`
}

type GroupPage struct {
	ID        uuid.UUID `db:"id"`
	GroupID   uuid.UUID `db:"group_id"`
	PageID    uuid.UUID `db:"page_id"`
	CreatedAt time.Time `db:"created_at"`
	UpdatedAt time.Time `db:"updated_at"`
}
</file>

<file path="internal/domain/group/repository.go">
package group

import (
	"context"

	"github.com/gofrs/uuid/v5"
)

type Query interface{ isQuery() }

type ByIDQuery struct{ ID uuid.UUID }

func (ByIDQuery) isQuery() {}

func ByID(id uuid.UUID) Query { return ByIDQuery{ID: id} }

type ByOrganizationIDQuery struct{ OrganizationID uuid.UUID }

func (ByOrganizationIDQuery) isQuery() {}

func ByOrganizationID(organizationID uuid.UUID) Query {
	return ByOrganizationIDQuery{OrganizationID: organizationID}
}

type BySlugQuery struct{ Slug string }

func (BySlugQuery) isQuery() {}

func BySlug(slug string) Query { return BySlugQuery{Slug: slug} }

type BySlugsQuery struct{ Slugs []string }

func (BySlugsQuery) isQuery() {}

func BySlugs(slugs []string) Query { return BySlugsQuery{Slugs: slugs} }

type PageQuery interface{ isPageQuery() }

type PageByOrganizationIDQuery struct{ OrganizationID uuid.UUID }

func (PageByOrganizationIDQuery) isPageQuery() {}

func PageByOrganizationID(organizationID uuid.UUID) PageQuery {
	return PageByOrganizationIDQuery{OrganizationID: organizationID}
}

type PageByPageIDsQuery struct{ PageIDs []uuid.UUID }

func (PageByPageIDsQuery) isPageQuery() {}

func PageByPageIDs(pageIDs []uuid.UUID) PageQuery {
	return PageByPageIDsQuery{PageIDs: pageIDs}
}

type PageByEnvironmentIDQuery struct{ EnvironmentID uuid.UUID }

func (PageByEnvironmentIDQuery) isPageQuery() {}

func PageByEnvironmentID(environmentID uuid.UUID) PageQuery {
	return PageByEnvironmentIDQuery{EnvironmentID: environmentID}
}

type Repository interface {
	Get(context.Context, ...Query) (*Group, error)
	List(context.Context, ...Query) ([]*Group, error)
	Create(context.Context, *Group) error
	Update(context.Context, *Group) error
	Delete(context.Context, *Group) error
	IsSlugExistsInOrganization(context.Context, uuid.UUID, string) (bool, error)

	ListPages(context.Context, ...PageQuery) ([]*GroupPage, error)
	BulkInsertPages(context.Context, []*GroupPage) error
	BulkUpdatePages(context.Context, []*GroupPage) error
	BulkDeletePages(context.Context, []*GroupPage) error
}
</file>

<file path="internal/domain/hostinstance/hostinstance.go">
package hostinstance

import (
	"time"

	"github.com/gofrs/uuid/v5"
)

type HostInstanceStatus int

const (
	HostInstanceStatusUnknown HostInstanceStatus = iota
	HostInstanceStatusOnline
	HostInstanceStatusUnreachable
	HostInstanceStatusOffline
	HostInstanceStatusShuttingDown

	hostInstanceStatusUnknown      = "unknown"
	hostInstanceStatusOnline       = "online"
	hostInstanceStatusUnreachable  = "unreachable"
	hostInstanceStatusOffline      = "offline"
	hostInstanceStatusShuttingDown = "shuttingDown"
)

func (s HostInstanceStatus) String() string {
	switch s {
	case HostInstanceStatusOnline:
		return hostInstanceStatusOnline
	case HostInstanceStatusUnreachable:
		return hostInstanceStatusUnreachable
	case HostInstanceStatusOffline:
		return hostInstanceStatusOffline
	case HostInstanceStatusShuttingDown:
		return hostInstanceStatusShuttingDown
	default:
		return hostInstanceStatusUnknown
	}
}

func HostInstanceStatusFromString(s string) HostInstanceStatus {
	switch s {
	case hostInstanceStatusOnline:
		return HostInstanceStatusOnline
	case hostInstanceStatusUnreachable:
		return HostInstanceStatusUnreachable
	case hostInstanceStatusOffline:
		return HostInstanceStatusOffline
	case hostInstanceStatusShuttingDown:
		return HostInstanceStatusShuttingDown
	default:
		return HostInstanceStatusUnknown
	}
}

type HostInstance struct {
	ID             uuid.UUID          `db:"id"`
	OrganizationID uuid.UUID          `db:"organization_id"`
	APIKeyID       uuid.UUID          `db:"api_key_id"`
	SDKName        string             `db:"sdk_name"`
	SDKVersion     string             `db:"sdk_version"`
	Status         HostInstanceStatus `db:"status"`
	CreatedAt      time.Time          `db:"created_at"`
	UpdatedAt      time.Time          `db:"updated_at"`
}
</file>

<file path="internal/domain/hostinstance/repository.go">
package hostinstance

import (
	"context"

	"github.com/gofrs/uuid/v5"
)

type Query interface{ isQuery() }

type ByIDQuery struct{ ID uuid.UUID }

func (ByIDQuery) isQuery() {}

func ByID(id uuid.UUID) Query { return ByIDQuery{ID: id} }

type ByOrganizationIDQuery struct{ OrganizationID uuid.UUID }

func (ByOrganizationIDQuery) isQuery() {}

func ByOrganizationID(organizationID uuid.UUID) Query {
	return ByOrganizationIDQuery{OrganizationID: organizationID}
}

type ByAPIKeyIDQuery struct{ APIKeyID uuid.UUID }

func (ByAPIKeyIDQuery) isQuery() {}

func ByAPIKeyID(apiKeyID uuid.UUID) Query { return ByAPIKeyIDQuery{APIKeyID: apiKeyID} }

type ByAPIKeyQuery struct{ APIKey string }

func (ByAPIKeyQuery) isQuery() {}

func ByAPIKey(apiKey string) Query { return ByAPIKeyQuery{APIKey: apiKey} }

type Repository interface {
	Get(context.Context, ...Query) (*HostInstance, error)
	List(context.Context, ...Query) ([]*HostInstance, error)
	Create(context.Context, *HostInstance) error
	Update(context.Context, *HostInstance) error
}
</file>

<file path="internal/domain/organization/organization.go">
package organization

import (
	"time"

	"github.com/gofrs/uuid/v5"
)

type Organization struct {
	ID        uuid.UUID `db:"id"`
	Subdomain *string   `db:"subdomain"`
	CreatedAt time.Time `db:"created_at"`
	UpdatedAt time.Time `db:"updated_at"`
}
</file>

<file path="internal/domain/organization/repository.go">
package organization

import (
	"context"

	"github.com/gofrs/uuid/v5"
)

type Query interface{ isQuery() }

type ByIDQuery struct{ ID uuid.UUID }

func (ByIDQuery) isQuery() {}

func ByID(id uuid.UUID) Query { return ByIDQuery{ID: id} }

type BySubdomainQuery struct{ Subdomain string }

func (BySubdomainQuery) isQuery() {}

func BySubdomain(subdomain string) Query { return BySubdomainQuery{Subdomain: subdomain} }

type ByUserIDQuery struct{ ID uuid.UUID }

func (ByUserIDQuery) isQuery() {}

func ByUserID(id uuid.UUID) Query { return ByUserIDQuery{ID: id} }

type Repository interface {
	Get(context.Context, ...Query) (*Organization, error)
	List(context.Context, ...Query) ([]*Organization, error)
	Create(context.Context, *Organization) error
	IsSubdomainExists(context.Context, string) (bool, error)
}
</file>

<file path="internal/domain/page/page.go">
package page

import (
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/lib/pq"
)

type Page struct {
	ID             uuid.UUID     `db:"id"`
	OrganizationID uuid.UUID     `db:"organization_id"`
	EnvironmentID  uuid.UUID     `db:"environment_id"`
	APIKeyID       uuid.UUID     `db:"api_key_id"`
	Name           string        `db:"name"`
	Route          string        `db:"route"`
	Path           pq.Int32Array `db:"path"`
	CreatedAt      time.Time     `db:"created_at"`
	UpdatedAt      time.Time     `db:"updated_at"`
}
</file>

<file path="internal/domain/page/repository.go">
package page

import (
	"context"

	"github.com/gofrs/uuid/v5"
)

type Query interface{ isQuery() }

type ByIDQuery struct{ ID uuid.UUID }

func (q ByIDQuery) isQuery() {}

func ByID(id uuid.UUID) Query { return ByIDQuery{ID: id} }

type ByOrganizationIDQuery struct{ OrganizationID uuid.UUID }

func (q ByOrganizationIDQuery) isQuery() {}

func ByOrganizationID(id uuid.UUID) Query { return ByOrganizationIDQuery{OrganizationID: id} }

type ByAPIKeyIDQuery struct{ APIKeyID uuid.UUID }

func (q ByAPIKeyIDQuery) isQuery() {}

func ByAPIKeyID(id uuid.UUID) Query { return ByAPIKeyIDQuery{APIKeyID: id} }

type BySessionIDQuery struct{ SessionID uuid.UUID }

func (q BySessionIDQuery) isQuery() {}

func BySessionID(id uuid.UUID) Query { return BySessionIDQuery{SessionID: id} }

type ByEnvironmentIDQuery struct{ EnvironmentID uuid.UUID }

func (q ByEnvironmentIDQuery) isQuery() {}

func ByEnvironmentID(id uuid.UUID) Query { return ByEnvironmentIDQuery{EnvironmentID: id} }

type LimitQuery struct{ Limit uint64 }

func (q LimitQuery) isQuery() {}

func Limit(limit uint64) Query { return LimitQuery{Limit: limit} }

type OffsetQuery struct{ Offset uint64 }

func (q OffsetQuery) isQuery() {}

func Offset(offset uint64) Query { return OffsetQuery{Offset: offset} }

type OrderByQuery struct{ OrderBy string }

func (q OrderByQuery) isQuery() {}

func OrderBy(orderBy string) Query { return OrderByQuery{OrderBy: orderBy} }

type Repository interface {
	Get(context.Context, ...Query) (*Page, error)
	List(context.Context, ...Query) ([]*Page, error)
	BulkInsert(context.Context, []*Page) error
	BulkUpdate(context.Context, []*Page) error
	BulkDelete(context.Context, []*Page) error
}
</file>

<file path="internal/domain/permission/permission.go">
package permission

import (
	"golang.org/x/exp/slices"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
)

type Operation string

const (
	OperationEditOrganization   Operation = "EDIT_ORGANIZATION"
	OperationEditBilling        Operation = "EDIT_BILLING"
	OperationEditLiveModeAPIKey Operation = "EDIT_LIVE_MODE_API_KEY" // #nosec G101
	OperationEditDevModeAPIKey  Operation = "EDIT_DEV_MODE_API_KEY"  // #nosec G101
	OperationEditEnvironment    Operation = "EDIT_ENVIRONMENT"
	OperationEditGroup          Operation = "EDIT_GROUP"
	OperationEditUser           Operation = "EDIT_USER"
)

var rolesAllowedByOperation = map[Operation][]user.UserOrganizationRole{
	OperationEditOrganization:   {user.UserOrganizationRoleAdmin},
	OperationEditBilling:        {user.UserOrganizationRoleAdmin},
	OperationEditLiveModeAPIKey: {user.UserOrganizationRoleAdmin},
	OperationEditDevModeAPIKey:  {user.UserOrganizationRoleAdmin, user.UserOrganizationRoleDeveloper},
	OperationEditEnvironment:    {user.UserOrganizationRoleAdmin},
	OperationEditGroup:          {user.UserOrganizationRoleAdmin},
	OperationEditUser:           {user.UserOrganizationRoleAdmin},
}

func CanPerform(role user.UserOrganizationRole, op Operation) bool {
	allowed, ok := rolesAllowedByOperation[op]
	if !ok {
		return false
	}
	return slices.Contains(allowed, role)
}
</file>

<file path="internal/domain/session/repository.go">
package session

import (
	"context"

	"github.com/gofrs/uuid/v5"
)

type Query interface{ isQuery() }

type ByIDQuery struct{ ID uuid.UUID }

func (q ByIDQuery) isQuery() {}

func ByID(id uuid.UUID) Query { return ByIDQuery{ID: id} }

type Repository interface {
	Get(context.Context, ...Query) (*Session, error)
	Create(context.Context, *Session) error
	Delete(context.Context, *Session) error
}
</file>

<file path="internal/domain/session/session.go">
package session

import (
	"time"

	"github.com/gofrs/uuid/v5"
)

type Session struct {
	ID             uuid.UUID `db:"id"`
	OrganizationID uuid.UUID `db:"organization_id"`
	UserID         uuid.UUID `db:"user_id"`
	APIKeyID       uuid.UUID `db:"api_key_id"`
	HostInstanceID uuid.UUID `db:"host_instance_id"`
	CreatedAt      time.Time `db:"created_at"`
	UpdatedAt      time.Time `db:"updated_at"`
}
</file>

<file path="internal/domain/user/repository.go">
package user

import (
	"context"

	"github.com/gofrs/uuid/v5"
)

type Query interface{ isQuery() }

type ByIDQuery struct{ ID uuid.UUID }

func (q ByIDQuery) isQuery() {}

func ByID(id uuid.UUID) Query { return ByIDQuery{ID: id} }

type ByEmailQuery struct{ Email string }

func (q ByEmailQuery) isQuery() {}

func ByEmail(email string) Query { return ByEmailQuery{Email: email} }

type ByRefreshTokenHashQuery struct{ RefreshTokenHash string }

func (q ByRefreshTokenHashQuery) isQuery() {}

func ByRefreshTokenHash(refreshTokenHash string) Query {
	return ByRefreshTokenHashQuery{RefreshTokenHash: refreshTokenHash}
}

type ByOrganizationIDQuery struct{ OrganizationID uuid.UUID }

func (q ByOrganizationIDQuery) isQuery() {}

func ByOrganizationID(organizationID uuid.UUID) Query {
	return ByOrganizationIDQuery{OrganizationID: organizationID}
}

type LimitQuery struct{ Limit uint64 }

func (q LimitQuery) isQuery() {}

func Limit(limit uint64) Query { return LimitQuery{Limit: limit} }

type OffsetQuery struct{ Offset uint64 }

func (q OffsetQuery) isQuery() {}

func Offset(offset uint64) Query { return OffsetQuery{Offset: offset} }

type OrderByQuery struct{ OrderBy string }

func (q OrderByQuery) isQuery() {}

func OrderBy(orderBy string) Query { return OrderByQuery{OrderBy: orderBy} }

type OrganizationAccessQuery interface{ isOrganizationAccessQuery() }

type OrganizationAccessByUserIDQuery struct{ UserID uuid.UUID }

func (q OrganizationAccessByUserIDQuery) isOrganizationAccessQuery() {}

func OrganizationAccessByUserID(userID uuid.UUID) OrganizationAccessQuery {
	return OrganizationAccessByUserIDQuery{UserID: userID}
}

type OrganizationAccessByUserIDsQuery struct{ UserIDs []uuid.UUID }

func (q OrganizationAccessByUserIDsQuery) isOrganizationAccessQuery() {}

func OrganizationAccessByUserIDs(userIDs []uuid.UUID) OrganizationAccessQuery {
	return OrganizationAccessByUserIDsQuery{UserIDs: userIDs}
}

type OrganizationAccessByOrganizationIDQuery struct{ OrganizationID uuid.UUID }

func (q OrganizationAccessByOrganizationIDQuery) isOrganizationAccessQuery() {}

func OrganizationAccessByOrganizationID(organizationID uuid.UUID) OrganizationAccessQuery {
	return OrganizationAccessByOrganizationIDQuery{OrganizationID: organizationID}
}

type OrganizationAccessByOrganizationSubdomainQuery struct{ OrganizationSubdomain string }

func (q OrganizationAccessByOrganizationSubdomainQuery) isOrganizationAccessQuery() {}

func OrganizationAccessByOrganizationSubdomain(subdomain string) OrganizationAccessQuery {
	return OrganizationAccessByOrganizationSubdomainQuery{OrganizationSubdomain: subdomain}
}

type OrganizationAccessOrderByQuery struct{ OrderBy string }

func (q OrganizationAccessOrderByQuery) isOrganizationAccessQuery() {}

func OrganizationAccessOrderBy(orderBy string) OrganizationAccessQuery {
	return OrganizationAccessOrderByQuery{OrderBy: orderBy}
}

type OrganizationAccessByRoleQuery struct{ Role UserOrganizationRole }

func (q OrganizationAccessByRoleQuery) isOrganizationAccessQuery() {}

func OrganizationAccessByRole(role UserOrganizationRole) OrganizationAccessQuery {
	return OrganizationAccessByRoleQuery{Role: role}
}

type GroupQuery interface{ isGroupQuery() }

type GroupByUserIDQuery struct{ UserID uuid.UUID }

func (q GroupByUserIDQuery) isGroupQuery() {}

func GroupByUserID(userID uuid.UUID) GroupQuery { return GroupByUserIDQuery{UserID: userID} }

type GroupByGroupIDQuery struct{ GroupID uuid.UUID }

func (q GroupByGroupIDQuery) isGroupQuery() {}

func GroupByGroupID(groupID uuid.UUID) GroupQuery { return GroupByGroupIDQuery{GroupID: groupID} }

type GroupByOrganizationIDQuery struct{ OrganizationID uuid.UUID }

func (q GroupByOrganizationIDQuery) isGroupQuery() {}

func GroupByOrganizationID(organizationID uuid.UUID) GroupQuery {
	return GroupByOrganizationIDQuery{OrganizationID: organizationID}
}

type InvitationQuery interface{ isInvitationQuery() }

type InvitationByOrganizationIDQuery struct{ OrganizationID uuid.UUID }

func (q InvitationByOrganizationIDQuery) isInvitationQuery() {}

func InvitationByOrganizationID(organizationID uuid.UUID) InvitationQuery {
	return InvitationByOrganizationIDQuery{OrganizationID: organizationID}
}

type InvitationByIDQuery struct{ ID uuid.UUID }

func (q InvitationByIDQuery) isInvitationQuery() {}

func InvitationByID(id uuid.UUID) InvitationQuery { return InvitationByIDQuery{ID: id} }

type InvitationByEmailQuery struct{ Email string }

func (q InvitationByEmailQuery) isInvitationQuery() {}

func InvitationByEmail(email string) InvitationQuery { return InvitationByEmailQuery{Email: email} }

type Repository interface {
	Get(context.Context, ...Query) (*User, error)
	List(context.Context, ...Query) ([]*User, error)
	Create(context.Context, *User) error
	Update(context.Context, *User) error
	IsEmailExists(context.Context, string) (bool, error)

	GetOrganizationAccess(context.Context, ...OrganizationAccessQuery) (*UserOrganizationAccess, error)
	ListOrganizationAccesses(context.Context, ...OrganizationAccessQuery) ([]*UserOrganizationAccess, error)
	CreateOrganizationAccess(context.Context, *UserOrganizationAccess) error
	UpdateOrganizationAccess(context.Context, *UserOrganizationAccess) error
	DeleteOrganizationAccess(context.Context, *UserOrganizationAccess) error

	GetGroup(context.Context, ...GroupQuery) (*UserGroup, error)
	ListGroups(context.Context, ...GroupQuery) ([]*UserGroup, error)
	BulkInsertGroups(context.Context, []*UserGroup) error
	BulkDeleteGroups(context.Context, []*UserGroup) error

	GetInvitation(context.Context, ...InvitationQuery) (*UserInvitation, error)
	ListInvitations(context.Context, ...InvitationQuery) ([]*UserInvitation, error)
	DeleteInvitation(context.Context, *UserInvitation) error
	BulkInsertInvitations(context.Context, []*UserInvitation) error
	IsInvitationEmailExists(context.Context, uuid.UUID, string) (bool, error)
}
</file>

<file path="internal/domain/user/user.go">
package user

import (
	"fmt"
	"time"

	"github.com/gofrs/uuid/v5"
)

type UserOrganizationRole int

const (
	UserOrganizationRoleUnknown UserOrganizationRole = iota
	UserOrganizationRoleAdmin
	UserOrganizationRoleDeveloper
	UserOrganizationRoleMember

	userOrganizationRoleUnknown   = "unknown"
	userOrganizationRoleAdmin     = "admin"
	userOrganizationRoleDeveloper = "developer"
	userOrganizationRoleMember    = "member"
)

func (r UserOrganizationRole) String() string {
	switch r {
	case UserOrganizationRoleAdmin:
		return userOrganizationRoleAdmin
	case UserOrganizationRoleDeveloper:
		return userOrganizationRoleDeveloper
	case UserOrganizationRoleMember:
		return userOrganizationRoleMember
	}
	return userOrganizationRoleUnknown
}

func UserOrganizationRoleFromString(s string) UserOrganizationRole {
	switch s {
	case userOrganizationRoleAdmin:
		return UserOrganizationRoleAdmin
	case userOrganizationRoleDeveloper:
		return UserOrganizationRoleDeveloper
	case userOrganizationRoleMember:
		return UserOrganizationRoleMember
	}
	return UserOrganizationRoleUnknown
}

type User struct {
	ID               uuid.UUID `db:"id"`
	Email            string    `db:"email"`
	FirstName        string    `db:"first_name"`
	LastName         string    `db:"last_name"`
	RefreshTokenHash string    `db:"refresh_token_hash"`
	GoogleID         string    `db:"google_id"`
	CreatedAt        time.Time `db:"created_at"`
	UpdatedAt        time.Time `db:"updated_at"`
}

type UserInvitation struct {
	ID             uuid.UUID            `db:"id"`
	OrganizationID uuid.UUID            `db:"organization_id"`
	Email          string               `db:"email"`
	Role           UserOrganizationRole `db:"role"`
	CreatedAt      time.Time            `db:"created_at"`
	UpdatedAt      time.Time            `db:"updated_at"`
}

type UserOrganizationAccess struct {
	ID             uuid.UUID            `db:"id"`
	UserID         uuid.UUID            `db:"user_id"`
	OrganizationID uuid.UUID            `db:"organization_id"`
	Role           UserOrganizationRole `db:"role"`
	CreatedAt      time.Time            `db:"created_at"`
	UpdatedAt      time.Time            `db:"updated_at"`
}

type UserGroup struct {
	ID        uuid.UUID `db:"id"`
	UserID    uuid.UUID `db:"user_id"`
	GroupID   uuid.UUID `db:"group_id"`
	CreatedAt time.Time `db:"created_at"`
	UpdatedAt time.Time `db:"updated_at"`
}

func (m *User) FullName() string {
	return fmt.Sprintf("%s %s", m.FirstName, m.LastName)
}
</file>

<file path="internal/infra/postgres/apikey/repository.go">
package apikey

import (
	"context"
	"database/sql"

	sq "github.com/Masterminds/squirrel"
	"github.com/lib/pq"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

type RepositoryCE struct {
	db      db.DB
	builder sq.StatementBuilderType
}

func NewRepositoryCE(db db.DB) *RepositoryCE {
	return &RepositoryCE{
		db:      db,
		builder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

func (r *RepositoryCE) Get(ctx context.Context, queries ...apikey.Query) (*apikey.APIKey, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := apikey.APIKey{}
	if err := r.db.GetContext(ctx, &m, query, args...); err != nil {
		if err == sql.ErrNoRows {
			return nil, errdefs.ErrAPIKeyNotFound(err)
		}
		return nil, errdefs.ErrDatabase(err)
	}

	return &m, nil
}

func (r *RepositoryCE) List(ctx context.Context, queries ...apikey.Query) ([]*apikey.APIKey, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := make([]*apikey.APIKey, 0)
	if err := r.db.SelectContext(ctx, &m, query, args...); err != nil {
		return nil, errdefs.ErrDatabase(err)
	}

	return m, nil
}

func (r *RepositoryCE) buildQuery(ctx context.Context, queries ...apikey.Query) (string, []any, error) {
	q := r.builder.Select(
		`ak."id"`,
		`ak."organization_id"`,
		`ak."environment_id"`,
		`ak."user_id"`,
		`ak."name"`,
		`ak."key"`,
		`ak."created_at"`,
		`ak."updated_at"`,
	).
		From(`"api_key" ak`)

	q = r.applyQueries(q, queries...)

	query, args, err := q.ToSql()
	if err != nil {
		return "", nil, errdefs.ErrDatabase(err)
	}

	return query, args, err
}

func (r *RepositoryCE) applyQueries(b sq.SelectBuilder, queries ...apikey.Query) sq.SelectBuilder {
	for _, q := range queries {
		switch q := q.(type) {
		case apikey.ByIDQuery:
			b = b.Where(sq.Eq{`ak."id"`: q.ID})
		case apikey.ByOrganizationIDQuery:
			b = b.Where(sq.Eq{`ak."organization_id"`: q.OrganizationID})
		case apikey.ByEnvironmentIDQuery:
			b = b.Where(sq.Eq{`ak."environment_id"`: q.EnvironmentID})
		case apikey.ByEnvironmentIDsQuery:
			b = b.Where(sq.Eq{`ak."environment_id"`: q.EnvironmentIDs})
		case apikey.ByUserIDQuery:
			b = b.Where(sq.Eq{`ak."user_id"`: q.UserID})
		case apikey.ByKeyQuery:
			b = b.Where(sq.Eq{`ak."key"`: q.Key})
		}
	}
	return b
}

func (r *RepositoryCE) Create(ctx context.Context, m *apikey.APIKey) error {
	if _, err := r.builder.
		Insert(`"api_key"`).
		Columns(
			`"id"`,
			`"organization_id"`,
			`"environment_id"`,
			`"user_id"`,
			`"name"`,
			`"key"`,
		).
		Values(
			m.ID,
			m.OrganizationID,
			m.EnvironmentID,
			m.UserID,
			m.Name,
			m.Key,
		).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		if pqErr, ok := err.(*pq.Error); ok && pqErr.Code == "23505" {
			return errdefs.ErrAlreadyExists(err)
		}
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) Update(ctx context.Context, m *apikey.APIKey) error {
	if _, err := r.builder.
		Update(`"api_key"`).
		Set(`"user_id"`, m.UserID).
		Set(`"name"`, m.Name).
		Set(`"key"`, m.Key).
		Where(sq.Eq{`"id"`: m.ID}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) Delete(ctx context.Context, m *apikey.APIKey) error {
	if _, err := r.builder.
		Delete(`"api_key"`).
		Where(sq.Eq{`"id"`: m.ID}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}
</file>

<file path="internal/infra/postgres/db/db.go">
package db

import (
	"context"
	"database/sql"

	"github.com/jmoiron/sqlx"

	"github.com/trysourcetool/sourcetool/backend/logger"
)

type DB interface {
	Query(string, ...any) (*sql.Rows, error)
	QueryContext(context.Context, string, ...any) (*sql.Rows, error)
	Exec(string, ...any) (sql.Result, error)
	ExecContext(context.Context, string, ...any) (sql.Result, error)
	GetContext(context.Context, any, string, ...any) error
	QueryxContext(context.Context, string, ...any) (*sqlx.Rows, error)
	SelectContext(context.Context, any, string, ...any) error
}

type queryLogger struct {
	db DB
}

func NewQueryLogger(db DB) *queryLogger {
	return &queryLogger{db}
}

func (l *queryLogger) Query(query string, args ...any) (*sql.Rows, error) {
	logger.Logger.Sugar().Debugf("%s, args: %s", query, args)
	return l.db.Query(query, args...)
}

func (l *queryLogger) QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error) {
	logger.Logger.Sugar().Debugf("%s, args: %s", query, args)
	return l.db.QueryContext(ctx, query, args...)
}

func (l *queryLogger) Exec(query string, args ...any) (sql.Result, error) {
	logger.Logger.Sugar().Debugf("%s, args: %s", query, args)
	return l.db.Exec(query, args...)
}

func (l *queryLogger) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	logger.Logger.Sugar().Debugf("%s, args: %s", query, args)
	return l.db.ExecContext(ctx, query, args...)
}

func (l *queryLogger) GetContext(ctx context.Context, dest any, query string, args ...any) error {
	logger.Logger.Sugar().Debugf("%s, args: %s", query, args)
	return l.db.GetContext(ctx, dest, query, args...)
}

func (l *queryLogger) QueryxContext(ctx context.Context, query string, args ...any) (*sqlx.Rows, error) {
	logger.Logger.Sugar().Debugf("%s, args: %s", query, args)
	return l.db.QueryxContext(ctx, query, args...)
}

func (l *queryLogger) SelectContext(ctx context.Context, dest any, query string, args ...any) error {
	logger.Logger.Sugar().Debugf("%s, args: %s", query, args)
	return l.db.SelectContext(ctx, dest, query, args...)
}
</file>

<file path="internal/infra/postgres/environment/repository.go">
package environment

import (
	"context"
	"database/sql"

	sq "github.com/Masterminds/squirrel"
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

type RepositoryCE struct {
	db      db.DB
	builder sq.StatementBuilderType
}

func NewRepositoryCE(db db.DB) *RepositoryCE {
	return &RepositoryCE{
		db:      db,
		builder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

func (r *RepositoryCE) Get(ctx context.Context, queries ...environment.Query) (*environment.Environment, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := environment.Environment{}
	if err := r.db.GetContext(ctx, &m, query, args...); err != nil {
		if err == sql.ErrNoRows {
			return nil, errdefs.ErrEnvironmentNotFound(err)
		}
		return nil, errdefs.ErrDatabase(err)
	}

	return &m, nil
}

func (r *RepositoryCE) List(ctx context.Context, queries ...environment.Query) ([]*environment.Environment, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := make([]*environment.Environment, 0)
	if err := r.db.SelectContext(ctx, &m, query, args...); err != nil {
		return nil, errdefs.ErrDatabase(err)
	}

	return m, nil
}

func (r *RepositoryCE) buildQuery(ctx context.Context, queries ...environment.Query) (string, []any, error) {
	q := r.builder.Select(r.columns()...).
		From(`"environment" e`)

	q = r.applyQueries(q, queries...)

	query, args, err := q.ToSql()
	if err != nil {
		return "", nil, errdefs.ErrDatabase(err)
	}

	return query, args, err
}

func (r *RepositoryCE) applyQueries(b sq.SelectBuilder, queries ...environment.Query) sq.SelectBuilder {
	for _, q := range queries {
		switch q := q.(type) {
		case environment.ByIDQuery:
			b = b.Where(sq.Eq{`e."id"`: q.ID})
		case environment.ByOrganizationIDQuery:
			b = b.Where(sq.Eq{`e."organization_id"`: q.OrganizationID})
		case environment.BySlugQuery:
			b = b.Where(sq.Eq{`e."slug"`: q.Slug})
		}
	}
	return b
}

func (r *RepositoryCE) Create(ctx context.Context, m *environment.Environment) error {
	if _, err := r.builder.
		Insert(`"environment"`).
		Columns(
			`"id"`,
			`"organization_id"`,
			`"name"`,
			`"slug"`,
			`"color"`,
		).
		Values(
			m.ID,
			m.OrganizationID,
			m.Name,
			m.Slug,
			m.Color,
		).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) Update(ctx context.Context, m *environment.Environment) error {
	if _, err := r.builder.
		Update(`"environment"`).
		Set(`"name"`, m.Name).
		Set(`"slug"`, m.Slug).
		Set(`"color"`, m.Color).
		Where(sq.Eq{`"id"`: m.ID}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) Delete(ctx context.Context, m *environment.Environment) error {
	if _, err := r.builder.
		Delete(`"environment"`).
		Where(sq.Eq{`"id"`: m.ID}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) BulkInsert(ctx context.Context, m []*environment.Environment) error {
	if len(m) == 0 {
		return nil
	}

	q := r.builder.
		Insert(`"environment"`).
		Columns(
			`"id"`,
			`"organization_id"`,
			`"name"`,
			`"slug"`,
			`"color"`,
		)

	for _, v := range m {
		q = q.Values(
			v.ID,
			v.OrganizationID,
			v.Name,
			v.Slug,
			v.Color,
		)
	}

	if _, err := q.
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) MapByAPIKeyIDs(ctx context.Context, ids []uuid.UUID) (map[uuid.UUID]*environment.Environment, error) {
	cols := append(r.columns(), `ak."id" AS "api_key_id"`)
	query, args, err := r.builder.Select(cols...).
		From(`"environment" e`).
		InnerJoin(`"api_key" ak ON ak."environment_id" = e."id"`).
		Where(sq.Eq{`ak."id"`: ids}).
		ToSql()
	if err != nil {
		return nil, err
	}

	rows, err := r.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, errdefs.ErrDatabase(err)
	}
	defer rows.Close()

	type EnvironmentEmbedded struct {
		*environment.Environment
		APIKeyID uuid.UUID `db:"api_key_id"`
	}
	m := make(map[uuid.UUID]*environment.Environment)
	for rows.Next() {
		ee := EnvironmentEmbedded{}
		if err := rows.StructScan(&ee); err != nil {
			return nil, errdefs.ErrDatabase(err)
		}

		m[ee.APIKeyID] = ee.Environment
	}

	return m, nil
}

func (r *RepositoryCE) columns() []string {
	return []string{
		`e."id"`,
		`e."organization_id"`,
		`e."name"`,
		`e."slug"`,
		`e."color"`,
		`e."created_at"`,
		`e."updated_at"`,
	}
}

func (r *RepositoryCE) IsSlugExistsInOrganization(ctx context.Context, orgID uuid.UUID, slug string) (bool, error) {
	if _, err := r.Get(ctx, environment.ByOrganizationID(orgID), environment.BySlug(slug)); err != nil {
		if errdefs.IsEnvironmentNotFound(err) {
			return false, nil
		}
		return false, err
	}

	return true, nil
}
</file>

<file path="internal/infra/postgres/group/repository.go">
package group

import (
	"context"
	"errors"

	sq "github.com/Masterminds/squirrel"
	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/group"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
)

type RepositoryCE struct {
	db      db.DB
	builder sq.StatementBuilderType
}

func NewRepositoryCE(db db.DB) *RepositoryCE {
	return &RepositoryCE{
		db:      db,
		builder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

func (r *RepositoryCE) Get(ctx context.Context, queries ...group.Query) (*group.Group, error) {
	return nil, errors.New("group functionality is not available in CE version")
}

func (r *RepositoryCE) List(ctx context.Context, queries ...group.Query) ([]*group.Group, error) {
	return nil, errors.New("group functionality is not available in CE version")
}

func (r *RepositoryCE) Create(ctx context.Context, m *group.Group) error {
	return errors.New("group functionality is not available in CE version")
}

func (r *RepositoryCE) Update(ctx context.Context, m *group.Group) error {
	return errors.New("group functionality is not available in CE version")
}

func (r *RepositoryCE) Delete(ctx context.Context, m *group.Group) error {
	return errors.New("group functionality is not available in CE version")
}

func (r *RepositoryCE) IsSlugExistsInOrganization(ctx context.Context, orgID uuid.UUID, slug string) (bool, error) {
	return false, errors.New("group functionality is not available in CE version")
}

func (r *RepositoryCE) ListPages(ctx context.Context, queries ...group.PageQuery) ([]*group.GroupPage, error) {
	return nil, errors.New("group functionality is not available in CE version")
}

func (r *RepositoryCE) BulkInsertPages(ctx context.Context, pages []*group.GroupPage) error {
	return errors.New("group functionality is not available in CE version")
}

func (r *RepositoryCE) BulkUpdatePages(ctx context.Context, pages []*group.GroupPage) error {
	return errors.New("group functionality is not available in CE version")
}

func (r *RepositoryCE) BulkDeletePages(ctx context.Context, pages []*group.GroupPage) error {
	return errors.New("group functionality is not available in CE version")
}
</file>

<file path="internal/infra/postgres/hostinstance/repository.go">
package hostinstance

import (
	"context"
	"database/sql"

	sq "github.com/Masterminds/squirrel"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

type RepositoryCE struct {
	db      db.DB
	builder sq.StatementBuilderType
}

func NewRepositoryCE(db db.DB) *RepositoryCE {
	return &RepositoryCE{
		db:      db,
		builder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

func (r *RepositoryCE) Get(ctx context.Context, queries ...hostinstance.Query) (*hostinstance.HostInstance, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := hostinstance.HostInstance{}
	if err := r.db.GetContext(ctx, &m, query, args...); err != nil {
		if err == sql.ErrNoRows {
			return nil, errdefs.ErrHostInstanceNotFound(err)
		}
		return nil, errdefs.ErrDatabase(err)
	}

	return &m, nil
}

func (r *RepositoryCE) List(ctx context.Context, queries ...hostinstance.Query) ([]*hostinstance.HostInstance, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := make([]*hostinstance.HostInstance, 0)
	if err := r.db.SelectContext(ctx, &m, query, args...); err != nil {
		return nil, errdefs.ErrDatabase(err)
	}

	return m, nil
}

func (r *RepositoryCE) buildQuery(ctx context.Context, queries ...hostinstance.Query) (string, []any, error) {
	q := r.builder.Select(
		`hi."id"`,
		`hi."organization_id"`,
		`hi."api_key_id"`,
		`hi."sdk_name"`,
		`hi."sdk_version"`,
		`hi."status"`,
		`hi."created_at"`,
		`hi."updated_at"`,
	).
		From(`"host_instance" hi`)

	q = r.applyQueries(q, queries...)

	query, args, err := q.ToSql()
	if err != nil {
		return "", nil, errdefs.ErrDatabase(err)
	}

	return query, args, err
}

func (r *RepositoryCE) applyQueries(b sq.SelectBuilder, queries ...hostinstance.Query) sq.SelectBuilder {
	for _, q := range queries {
		switch q := q.(type) {
		case hostinstance.ByIDQuery:
			b = b.Where(sq.Eq{`hi."id"`: q.ID})
		case hostinstance.ByOrganizationIDQuery:
			b = b.Where(sq.Eq{`hi."organization_id"`: q.OrganizationID})
		case hostinstance.ByAPIKeyIDQuery:
			b = b.Where(sq.Eq{`hi."api_key_id"`: q.APIKeyID})
		case hostinstance.ByAPIKeyQuery:
			b = b.
				InnerJoin(`"api_key" ak ON ak."id" = hi."api_key_id"`).
				Where(sq.Eq{`ak."key"`: q.APIKey})
		}
	}

	return b
}

func (r *RepositoryCE) Create(ctx context.Context, m *hostinstance.HostInstance) error {
	if _, err := r.builder.
		Insert(`"host_instance"`).
		Columns(
			`"id"`,
			`"organization_id"`,
			`"api_key_id"`,
			`"sdk_name"`,
			`"sdk_version"`,
			`"status"`,
		).
		Values(
			m.ID,
			m.OrganizationID,
			m.APIKeyID,
			m.SDKName,
			m.SDKVersion,
			m.Status,
		).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) Update(ctx context.Context, m *hostinstance.HostInstance) error {
	if _, err := r.builder.
		Update(`"host_instance"`).
		Set(`"sdk_name"`, m.SDKName).
		Set(`"sdk_version"`, m.SDKVersion).
		Set(`"status"`, m.Status).
		Where(sq.Eq{`"id"`: m.ID}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}
</file>

<file path="internal/infra/postgres/organization/repository.go">
package organization

import (
	"context"
	"database/sql"

	sq "github.com/Masterminds/squirrel"
	"github.com/lib/pq"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

type RepositoryCE struct {
	db      db.DB
	builder sq.StatementBuilderType
}

func NewRepositoryCE(db db.DB) *RepositoryCE {
	return &RepositoryCE{
		db:      db,
		builder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

func (r *RepositoryCE) Get(ctx context.Context, queries ...organization.Query) (*organization.Organization, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := organization.Organization{}
	if err := r.db.GetContext(ctx, &m, query, args...); err != nil {
		if err == sql.ErrNoRows {
			return nil, errdefs.ErrOrganizationNotFound(err)
		}
		return nil, errdefs.ErrDatabase(err)
	}

	return &m, nil
}

func (r *RepositoryCE) List(ctx context.Context, queries ...organization.Query) ([]*organization.Organization, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	var orgs []*organization.Organization
	if err := r.db.SelectContext(ctx, &orgs, query, args...); err != nil {
		return nil, errdefs.ErrDatabase(err)
	}

	return orgs, nil
}

func (r *RepositoryCE) buildQuery(ctx context.Context, queries ...organization.Query) (string, []any, error) {
	q := r.builder.Select(
		`o."id"`,
		`o."subdomain"`,
		`o."created_at"`,
		`o."updated_at"`,
	).
		From(`"organization" o`)

	q = r.applyQueries(q, queries...)

	query, args, err := q.ToSql()
	if err != nil {
		return "", nil, errdefs.ErrDatabase(err)
	}

	return query, args, err
}

func (r *RepositoryCE) applyQueries(b sq.SelectBuilder, queries ...organization.Query) sq.SelectBuilder {
	for _, q := range queries {
		switch q := q.(type) {
		case organization.ByIDQuery:
			b = b.Where(sq.Eq{`o."id"`: q.ID})
		case organization.BySubdomainQuery:
			b = b.Where(sq.Eq{`o."subdomain"`: q.Subdomain})
		case organization.ByUserIDQuery:
			b = b.
				InnerJoin(`"user_organization_access" uoa ON uoa."organization_id" = o."id"`).
				Where(sq.Eq{`uoa."user_id"`: q.ID})
		}
	}
	return b
}

func (r *RepositoryCE) Create(ctx context.Context, m *organization.Organization) error {
	if _, err := r.builder.
		Insert(`"organization"`).
		Columns(
			`"id"`,
			`"subdomain"`,
		).
		Values(
			m.ID,
			m.Subdomain,
		).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		if pqErr, ok := err.(*pq.Error); ok && pqErr.Code == "23505" {
			return errdefs.ErrAlreadyExists(err)
		}
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) IsSubdomainExists(ctx context.Context, subdomain string) (bool, error) {
	if _, err := r.Get(ctx, organization.BySubdomain(subdomain)); err != nil {
		if errdefs.IsOrganizationNotFound(err) {
			return false, nil
		}
		return false, err
	}
	return true, nil
}
</file>

<file path="internal/infra/postgres/page/repository.go">
package page

import (
	"context"
	"database/sql"

	sq "github.com/Masterminds/squirrel"
	"github.com/gofrs/uuid/v5"
	"github.com/samber/lo"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/page"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

type RepositoryCE struct {
	db      db.DB
	builder sq.StatementBuilderType
}

func NewRepositoryCE(db db.DB) *RepositoryCE {
	return &RepositoryCE{
		db:      db,
		builder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

func (r *RepositoryCE) Get(ctx context.Context, queries ...page.Query) (*page.Page, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := page.Page{}
	if err := r.db.GetContext(ctx, &m, query, args...); err != nil {
		if err == sql.ErrNoRows {
			return nil, errdefs.ErrPageNotFound(err)
		}
		return nil, errdefs.ErrDatabase(err)
	}

	return &m, nil
}

func (r *RepositoryCE) List(ctx context.Context, queries ...page.Query) ([]*page.Page, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := make([]*page.Page, 0)
	if err := r.db.SelectContext(ctx, &m, query, args...); err != nil {
		return nil, errdefs.ErrDatabase(err)
	}

	return m, nil
}

func (r *RepositoryCE) buildQuery(ctx context.Context, queries ...page.Query) (string, []any, error) {
	q := r.builder.Select(
		`p."id"`,
		`p."organization_id"`,
		`p."environment_id"`,
		`p."api_key_id"`,
		`p."name"`,
		`p."route"`,
		`p."path"`,
		`p."created_at"`,
		`p."updated_at"`,
	).
		From(`"page" p`)

	q = r.applyQueries(q, queries...)

	query, args, err := q.ToSql()
	if err != nil {
		return "", nil, errdefs.ErrDatabase(err)
	}

	return query, args, err
}

func (r *RepositoryCE) applyQueries(b sq.SelectBuilder, queries ...page.Query) sq.SelectBuilder {
	for _, q := range queries {
		switch q := q.(type) {
		case page.ByIDQuery:
			b = b.Where(sq.Eq{`p."id"`: q.ID})
		case page.ByOrganizationIDQuery:
			b = b.Where(sq.Eq{`p."organization_id"`: q.OrganizationID})
		case page.ByAPIKeyIDQuery:
			b = b.Where(sq.Eq{`p."api_key_id"`: q.APIKeyID})
		case page.BySessionIDQuery:
			b = b.
				InnerJoin(`"api_key" ak ON ak."id" = p."api_key_id"`).
				InnerJoin(`"session" s ON s."api_key_id" = ak."id"`).
				Where(sq.Eq{`s."id"`: q.SessionID})
		case page.ByEnvironmentIDQuery:
			b = b.Where(sq.Eq{`p."environment_id"`: q.EnvironmentID})
		case page.LimitQuery:
			b = b.Limit(q.Limit)
		case page.OffsetQuery:
			b = b.Offset(q.Offset)
		case page.OrderByQuery:
			b = b.OrderBy(q.OrderBy)
		}
	}

	return b
}

func (r *RepositoryCE) BulkInsert(ctx context.Context, m []*page.Page) error {
	if len(m) == 0 {
		return nil
	}

	q := r.builder.
		Insert(`"page"`).
		Columns(
			`"id"`,
			`"organization_id"`,
			`"environment_id"`,
			`"api_key_id"`,
			`"name"`,
			`"route"`,
			`"path"`,
		)

	for _, v := range m {
		q = q.Values(
			v.ID,
			v.OrganizationID,
			v.EnvironmentID,
			v.APIKeyID,
			v.Name,
			v.Route,
			v.Path,
		)
	}

	if _, err := q.
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) BulkUpdate(ctx context.Context, m []*page.Page) error {
	if len(m) == 0 {
		return nil
	}

	for _, v := range m {
		if _, err := r.builder.
			Update(`"page"`).
			Set(`"name"`, v.Name).
			Set(`"route"`, v.Route).
			Set(`"path"`, v.Path).
			Where(sq.Eq{`"id"`: v.ID}).
			RunWith(r.db).
			ExecContext(ctx); err != nil {
			return errdefs.ErrDatabase(err)
		}
	}

	return nil
}

func (r *RepositoryCE) BulkDelete(ctx context.Context, m []*page.Page) error {
	if len(m) == 0 {
		return nil
	}

	ids := lo.Map(m, func(x *page.Page, _ int) uuid.UUID {
		return x.ID
	})

	if _, err := r.builder.
		Delete(`"page"`).
		Where(sq.Eq{`"id"`: ids}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}
</file>

<file path="internal/infra/postgres/session/repository.go">
package session

import (
	"context"
	"database/sql"

	sq "github.com/Masterminds/squirrel"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/session"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

type RepositoryCE struct {
	db      db.DB
	builder sq.StatementBuilderType
}

func NewRepositoryCE(db db.DB) *RepositoryCE {
	return &RepositoryCE{
		db:      db,
		builder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

func (r *RepositoryCE) Get(ctx context.Context, queries ...session.Query) (*session.Session, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := session.Session{}
	if err := r.db.GetContext(ctx, &m, query, args...); err != nil {
		if err == sql.ErrNoRows {
			return nil, errdefs.ErrSessionNotFound(err)
		}
		return nil, errdefs.ErrDatabase(err)
	}

	return &m, nil
}

func (r *RepositoryCE) buildQuery(ctx context.Context, queries ...session.Query) (string, []any, error) {
	q := r.builder.Select(
		`s."id"`,
		`s."organization_id"`,
		`s."user_id"`,
		`s."api_key_id"`,
		`s."host_instance_id"`,
		`s."created_at"`,
		`s."updated_at"`,
	).
		From(`"session" s`)

	q = r.applyQueries(q, queries...)

	query, args, err := q.ToSql()
	if err != nil {
		return "", nil, errdefs.ErrDatabase(err)
	}

	return query, args, err
}

func (r *RepositoryCE) applyQueries(b sq.SelectBuilder, queries ...session.Query) sq.SelectBuilder {
	for _, q := range queries {
		switch q := q.(type) {
		case session.ByIDQuery:
			b = b.Where(sq.Eq{`s."id"`: q.ID})
		}
	}

	return b
}

func (r *RepositoryCE) Create(ctx context.Context, m *session.Session) error {
	if _, err := r.builder.
		Insert(`"session"`).
		Columns(
			`"id"`,
			`"organization_id"`,
			`"user_id"`,
			`"api_key_id"`,
			`"host_instance_id"`,
		).
		Values(
			m.ID,
			m.OrganizationID,
			m.UserID,
			m.APIKeyID,
			m.HostInstanceID,
		).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) Delete(ctx context.Context, m *session.Session) error {
	if _, err := r.builder.
		Delete(`"session"`).
		Where(sq.Eq{`"id"`: m.ID}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}
</file>

<file path="internal/infra/postgres/user/repository.go">
package user

import (
	"context"
	"database/sql"

	sq "github.com/Masterminds/squirrel"
	"github.com/gofrs/uuid/v5"
	"github.com/lib/pq"
	"github.com/samber/lo"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

type RepositoryCE struct {
	db      db.DB
	builder sq.StatementBuilderType
}

func NewRepositoryCE(db db.DB) *RepositoryCE {
	return &RepositoryCE{
		db:      db,
		builder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

func (r *RepositoryCE) Get(ctx context.Context, queries ...user.Query) (*user.User, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := user.User{}
	if err := r.db.GetContext(ctx, &m, query, args...); err != nil {
		if err == sql.ErrNoRows {
			return nil, errdefs.ErrUserNotFound(err)
		}
		return nil, errdefs.ErrDatabase(err)
	}

	return &m, nil
}

func (r *RepositoryCE) List(ctx context.Context, queries ...user.Query) ([]*user.User, error) {
	query, args, err := r.buildQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := make([]*user.User, 0)
	if err := r.db.SelectContext(ctx, &m, query, args...); err != nil {
		return nil, errdefs.ErrDatabase(err)
	}

	return m, nil
}

func (r *RepositoryCE) buildQuery(ctx context.Context, queries ...user.Query) (string, []any, error) {
	q := r.builder.Select(
		`u."id"`,
		`u."created_at"`,
		`u."email"`,
		`u."first_name"`,
		`u."last_name"`,
		`u."updated_at"`,
		`u."refresh_token_hash"`,
		`u."google_id"`,
	).
		From(`"user" u`)

	q = r.applyQueries(q, queries...)

	query, args, err := q.ToSql()
	if err != nil {
		return "", nil, errdefs.ErrDatabase(err)
	}

	return query, args, err
}

func (r *RepositoryCE) applyQueries(b sq.SelectBuilder, queries ...user.Query) sq.SelectBuilder {
	for _, q := range queries {
		switch q := q.(type) {
		case user.ByIDQuery:
			b = b.Where(sq.Eq{`u."id"`: q.ID})
		case user.ByEmailQuery:
			b = b.Where(sq.Eq{`u."email"`: q.Email})
		case user.ByRefreshTokenHashQuery:
			b = b.Where(sq.Eq{`u."refresh_token_hash"`: q.RefreshTokenHash})
		case user.ByOrganizationIDQuery:
			b = b.
				InnerJoin(`"user_organization_access" uoa ON u."id" = uoa."user_id"`).
				Where(sq.Eq{`uoa."organization_id"`: q.OrganizationID})
		case user.LimitQuery:
			b = b.Limit(q.Limit)
		case user.OffsetQuery:
			b = b.Offset(q.Offset)
		case user.OrderByQuery:
			b = b.OrderBy(q.OrderBy)
		}
	}
	return b
}

func (r *RepositoryCE) Create(ctx context.Context, m *user.User) error {
	if _, err := r.builder.
		Insert(`"user"`).
		Columns(
			`"id"`,
			`"email"`,
			`"first_name"`,
			`"last_name"`,
			`"refresh_token_hash"`,
			`"google_id"`,
		).
		Values(
			m.ID,
			m.Email,
			m.FirstName,
			m.LastName,
			m.RefreshTokenHash,
			m.GoogleID,
		).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		if pqErr, ok := err.(*pq.Error); ok && pqErr.Code == "23505" {
			return errdefs.ErrAlreadyExists(err)
		}
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) Update(ctx context.Context, m *user.User) error {
	if _, err := r.builder.
		Update(`"user"`).
		Set(`"email"`, m.Email).
		Set(`"first_name"`, m.FirstName).
		Set(`"last_name"`, m.LastName).
		Set(`"refresh_token_hash"`, m.RefreshTokenHash).
		Set(`"google_id"`, m.GoogleID).
		Where(sq.Eq{`"id"`: m.ID}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		if pqErr, ok := err.(*pq.Error); ok && pqErr.Code == "23505" {
			return errdefs.ErrAlreadyExists(err)
		}
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) IsEmailExists(ctx context.Context, email string) (bool, error) {
	if _, err := r.Get(ctx, user.ByEmail(email)); err != nil {
		if errdefs.IsUserNotFound(err) {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

func (r *RepositoryCE) GetOrganizationAccess(ctx context.Context, queries ...user.OrganizationAccessQuery) (*user.UserOrganizationAccess, error) {
	query, args, err := r.buildOrganizationAccessQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := user.UserOrganizationAccess{}
	if err := r.db.GetContext(ctx, &m, query, args...); err != nil {
		if err == sql.ErrNoRows {
			return nil, errdefs.ErrUserOrganizationAccessNotFound(err)
		}
		return nil, errdefs.ErrDatabase(err)
	}

	return &m, nil
}

func (r *RepositoryCE) ListOrganizationAccesses(ctx context.Context, queries ...user.OrganizationAccessQuery) ([]*user.UserOrganizationAccess, error) {
	query, args, err := r.buildOrganizationAccessQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := make([]*user.UserOrganizationAccess, 0)
	if err := r.db.SelectContext(ctx, &m, query, args...); err != nil {
		return nil, errdefs.ErrDatabase(err)
	}

	return m, nil
}

func (r *RepositoryCE) buildOrganizationAccessQuery(ctx context.Context, queries ...user.OrganizationAccessQuery) (string, []any, error) {
	q := r.builder.Select(
		`uoa."id"`,
		`uoa."user_id"`,
		`uoa."organization_id"`,
		`uoa."role"`,
		`uoa."created_at"`,
		`uoa."updated_at"`,
	).
		From(`"user_organization_access" uoa`)

	q = r.applyOrganizationAccessQueries(q, queries...)

	query, args, err := q.ToSql()
	if err != nil {
		return "", nil, errdefs.ErrDatabase(err)
	}

	return query, args, err
}

func (r *RepositoryCE) applyOrganizationAccessQueries(b sq.SelectBuilder, queries ...user.OrganizationAccessQuery) sq.SelectBuilder {
	for _, q := range queries {
		switch q := q.(type) {
		case user.OrganizationAccessByUserIDQuery:
			b = b.Where(sq.Eq{`uoa."user_id"`: q.UserID})
		case user.OrganizationAccessByUserIDsQuery:
			b = b.Where(sq.Eq{`uoa."user_id"`: q.UserIDs})
		case user.OrganizationAccessByOrganizationIDQuery:
			b = b.
				InnerJoin(`"organization" o ON o."id" = uoa."organization_id"`).
				Where(sq.Eq{`o."id"`: q.OrganizationID})
		case user.OrganizationAccessByOrganizationSubdomainQuery:
			b = b.
				InnerJoin(`"organization" o ON o."id" = uoa."organization_id"`).
				Where(sq.Eq{`o."subdomain"`: q.OrganizationSubdomain})
		case user.OrganizationAccessByRoleQuery:
			b = b.Where(sq.Eq{`uoa."role"`: q.Role})
		}
	}
	return b
}

func (r *RepositoryCE) CreateOrganizationAccess(ctx context.Context, m *user.UserOrganizationAccess) error {
	if _, err := r.builder.
		Insert(`"user_organization_access"`).
		Columns(
			`"id"`,
			`"user_id"`,
			`"organization_id"`,
			`"role"`,
		).
		Values(
			m.ID,
			m.UserID,
			m.OrganizationID,
			m.Role,
		).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) UpdateOrganizationAccess(ctx context.Context, m *user.UserOrganizationAccess) error {
	if _, err := r.builder.
		Update(`"user_organization_access"`).
		Set(`"role"`, m.Role).
		Where(sq.Eq{`"id"`: m.ID}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) DeleteOrganizationAccess(ctx context.Context, m *user.UserOrganizationAccess) error {
	if _, err := r.builder.
		Delete(`"user_organization_access"`).
		Where(sq.Eq{`"user_id"`: m.UserID, `"organization_id"`: m.OrganizationID}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		if err == sql.ErrNoRows {
			return errdefs.ErrUserOrganizationAccessNotFound(err)
		}
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) GetGroup(ctx context.Context, queries ...user.GroupQuery) (*user.UserGroup, error) {
	query, args, err := r.buildGroupQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := user.UserGroup{}
	if err := r.db.GetContext(ctx, &m, query, args...); err != nil {
		if err == sql.ErrNoRows {
			return nil, errdefs.ErrUserGroupNotFound(err)
		}
		return nil, errdefs.ErrDatabase(err)
	}

	return &m, nil
}

func (r *RepositoryCE) ListGroups(ctx context.Context, queries ...user.GroupQuery) ([]*user.UserGroup, error) {
	query, args, err := r.buildGroupQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := make([]*user.UserGroup, 0)
	if err := r.db.SelectContext(ctx, &m, query, args...); err != nil {
		return nil, errdefs.ErrDatabase(err)
	}

	return m, nil
}

func (r *RepositoryCE) buildGroupQuery(ctx context.Context, queries ...user.GroupQuery) (string, []any, error) {
	q := r.builder.Select(
		`ug."id"`,
		`ug."user_id"`,
		`ug."group_id"`,
		`ug."created_at"`,
		`ug."updated_at"`,
	).
		From(`"user_group" ug`)

	q = r.applyGroupQueries(q, queries...)

	query, args, err := q.ToSql()
	if err != nil {
		return "", nil, errdefs.ErrDatabase(err)
	}

	return query, args, err
}

func (r *RepositoryCE) applyGroupQueries(b sq.SelectBuilder, queries ...user.GroupQuery) sq.SelectBuilder {
	for _, q := range queries {
		switch q := q.(type) {
		case user.GroupByUserIDQuery:
			b = b.Where(sq.Eq{`ug."user_id"`: q.UserID})
		case user.GroupByGroupIDQuery:
			b = b.Where(sq.Eq{`ug."group_id"`: q.GroupID})
		case user.GroupByOrganizationIDQuery:
			b = b.
				InnerJoin(`"group" g ON g."id" = ug."group_id"`).
				Where(sq.Eq{`g."organization_id"`: q.OrganizationID})
		}
	}
	return b
}

func (r *RepositoryCE) BulkInsertGroups(ctx context.Context, m []*user.UserGroup) error {
	if len(m) == 0 {
		return nil
	}

	q := r.builder.
		Insert(`"user_group"`).
		Columns(`"id"`, `"user_id"`, `"group_id"`)

	for _, v := range m {
		q = q.Values(v.ID, v.UserID, v.GroupID)
	}

	if _, err := q.
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) BulkDeleteGroups(ctx context.Context, m []*user.UserGroup) error {
	if len(m) == 0 {
		return nil
	}

	ids := lo.Map(m, func(x *user.UserGroup, _ int) uuid.UUID {
		return x.ID
	})

	if _, err := r.builder.
		Delete(`"user_group"`).
		Where(sq.Eq{`"id"`: ids}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) GetInvitation(ctx context.Context, queries ...user.InvitationQuery) (*user.UserInvitation, error) {
	query, args, err := r.buildInvitationQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := user.UserInvitation{}
	if err := r.db.GetContext(ctx, &m, query, args...); err != nil {
		if err == sql.ErrNoRows {
			return nil, errdefs.ErrUserInvitationNotFound(err)
		}
		return nil, errdefs.ErrDatabase(err)
	}

	return &m, nil
}

func (r *RepositoryCE) ListInvitations(ctx context.Context, queries ...user.InvitationQuery) ([]*user.UserInvitation, error) {
	query, args, err := r.buildInvitationQuery(ctx, queries...)
	if err != nil {
		return nil, err
	}

	m := make([]*user.UserInvitation, 0)
	if err := r.db.SelectContext(ctx, &m, query, args...); err != nil {
		return nil, errdefs.ErrDatabase(err)
	}

	return m, nil
}

func (r *RepositoryCE) buildInvitationQuery(ctx context.Context, queries ...user.InvitationQuery) (string, []any, error) {
	q := r.builder.Select(
		`ui."id"`,
		`ui."organization_id"`,
		`ui."email"`,
		`ui."role"`,
		`ui."created_at"`,
		`ui."updated_at"`,
	).
		From(`"user_invitation" ui`)

	q = r.applyInvitationQueries(q, queries...)

	query, args, err := q.ToSql()
	if err != nil {
		return "", nil, errdefs.ErrDatabase(err)
	}

	return query, args, err
}

func (r *RepositoryCE) applyInvitationQueries(b sq.SelectBuilder, queries ...user.InvitationQuery) sq.SelectBuilder {
	for _, q := range queries {
		switch q := q.(type) {
		case user.InvitationByOrganizationIDQuery:
			b = b.Where(sq.Eq{`ui."organization_id"`: q.OrganizationID})
		case user.InvitationByIDQuery:
			b = b.Where(sq.Eq{`ui."id"`: q.ID})
		case user.InvitationByEmailQuery:
			b = b.Where(sq.Eq{`ui."email"`: q.Email})
		}
	}
	return b
}

func (r *RepositoryCE) DeleteInvitation(ctx context.Context, m *user.UserInvitation) error {
	if _, err := r.builder.
		Delete(`"user_invitation"`).
		Where(sq.Eq{`"id"`: m.ID}).
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) BulkInsertInvitations(ctx context.Context, m []*user.UserInvitation) error {
	if len(m) == 0 {
		return nil
	}

	q := r.builder.
		Insert(`"user_invitation"`).
		Columns(`"id"`, `"organization_id"`, `"email"`, `"role"`)

	for _, v := range m {
		q = q.Values(v.ID, v.OrganizationID, v.Email, v.Role)
	}

	if _, err := q.
		RunWith(r.db).
		ExecContext(ctx); err != nil {
		return errdefs.ErrDatabase(err)
	}

	return nil
}

func (r *RepositoryCE) IsInvitationEmailExists(ctx context.Context, orgID uuid.UUID, email string) (bool, error) {
	if _, err := r.GetInvitation(ctx, user.InvitationByOrganizationID(orgID), user.InvitationByEmail(email)); err != nil {
		if errdefs.IsUserInvitationNotFound(err) {
			return false, nil
		}
		return false, err
	}
	return true, nil
}
</file>

<file path="internal/infra/postgres/migrate.go">
package postgres

import (
	"github.com/golang-migrate/migrate/v4"
	"github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/source/file"
)

func Migrate(dir string) error {
	db, err := New()
	if err != nil {
		return err
	}

	driver, err := postgres.WithInstance(db.DB, &postgres.Config{})
	if err != nil {
		return err
	}

	m, err := migrate.NewWithDatabaseInstance("file://"+dir, "postgres", driver)
	if err != nil {
		return err
	}

	if err := m.Up(); err != nil && err != migrate.ErrNoChange {
		return err
	}

	return nil
}
</file>

<file path="internal/infra/postgres/postgres.go">
package postgres

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/jmoiron/sqlx"

	"github.com/trysourcetool/sourcetool/backend/config"
)

const (
	maxIdleConns = 25
	maxOpenConns = 100
)

func New() (*sqlx.DB, error) {
	sqlDB, err := sql.Open("postgres", dsn())
	if err != nil {
		return nil, err
	}

	sqlDB.SetMaxIdleConns(maxIdleConns)
	sqlDB.SetMaxOpenConns(maxOpenConns)

	for {
		if err := sqlDB.Ping(); err == nil {
			break
		}
		time.Sleep(1 * time.Second)
	}

	return sqlx.NewDb(sqlDB, "postgres"), nil
}

func dsn() string {
	return fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		config.Config.Postgres.Host,
		config.Config.Postgres.Port,
		config.Config.Postgres.User,
		config.Config.Postgres.Password,
		config.Config.Postgres.DB,
	)
}
</file>

<file path="internal/infra/postgres/repository.go">
package postgres

import (
	"github.com/jmoiron/sqlx"

	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/environment"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/group"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/page"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/session"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
	apikeyRepo "github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/db"
	environmentRepo "github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/environment"
	groupRepo "github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/group"
	hostinstanceRepo "github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/hostinstance"
	organizationRepo "github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/organization"
	pageRepo "github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/page"
	sessionRepo "github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/session"
	userRepo "github.com/trysourcetool/sourcetool/backend/internal/infra/postgres/user"
)

var _ port.Repository = (*repositoryCE)(nil)

type repositoryCE struct {
	db *sqlx.DB
}

func NewRepositoryCE(db *sqlx.DB) *repositoryCE {
	return &repositoryCE{
		db: db,
	}
}

func (r *repositoryCE) Close() error {
	return r.db.Close()
}

func (r *repositoryCE) RunTransaction(f func(port.Transaction) error) error {
	tx, err := r.db.Beginx()
	if err != nil {
		return err
	}

	t := &transactionCE{db: tx}
	if err := f(t); err != nil {
		if err := tx.Rollback(); err != nil {
			return err
		}
		return err
	}

	if err := tx.Commit(); err != nil {
		return err
	}

	return nil
}

func (r *repositoryCE) APIKey() apikey.Repository {
	return apikeyRepo.NewRepositoryCE(db.NewQueryLogger(r.db))
}

func (r *repositoryCE) Environment() environment.Repository {
	return environmentRepo.NewRepositoryCE(db.NewQueryLogger(r.db))
}

func (r *repositoryCE) Group() group.Repository {
	return groupRepo.NewRepositoryCE(db.NewQueryLogger(r.db))
}

func (r *repositoryCE) HostInstance() hostinstance.Repository {
	return hostinstanceRepo.NewRepositoryCE(db.NewQueryLogger(r.db))
}

func (r *repositoryCE) Organization() organization.Repository {
	return organizationRepo.NewRepositoryCE(db.NewQueryLogger(r.db))
}

func (r *repositoryCE) Page() page.Repository {
	return pageRepo.NewRepositoryCE(db.NewQueryLogger(r.db))
}

func (r *repositoryCE) Session() session.Repository {
	return sessionRepo.NewRepositoryCE(db.NewQueryLogger(r.db))
}

func (r *repositoryCE) User() user.Repository {
	return userRepo.NewRepositoryCE(db.NewQueryLogger(r.db))
}

type transactionCE struct {
	db *sqlx.Tx
}

func (t *transactionCE) APIKey() apikey.Repository {
	return apikeyRepo.NewRepositoryCE(db.NewQueryLogger(t.db))
}

func (t *transactionCE) Environment() environment.Repository {
	return environmentRepo.NewRepositoryCE(db.NewQueryLogger(t.db))
}

func (t *transactionCE) Group() group.Repository {
	return groupRepo.NewRepositoryCE(db.NewQueryLogger(t.db))
}

func (t *transactionCE) HostInstance() hostinstance.Repository {
	return hostinstanceRepo.NewRepositoryCE(db.NewQueryLogger(t.db))
}

func (t *transactionCE) Organization() organization.Repository {
	return organizationRepo.NewRepositoryCE(db.NewQueryLogger(t.db))
}

func (t *transactionCE) Page() page.Repository {
	return pageRepo.NewRepositoryCE(db.NewQueryLogger(t.db))
}

func (t *transactionCE) Session() session.Repository {
	return sessionRepo.NewRepositoryCE(db.NewQueryLogger(t.db))
}

func (t *transactionCE) User() user.Repository {
	return userRepo.NewRepositoryCE(db.NewQueryLogger(t.db))
}
</file>

<file path="internal/infra/redis/client.go">
package redis

import (
	"context"
	"fmt"

	"github.com/redis/go-redis/v9"
	"google.golang.org/protobuf/proto"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	redisv1 "github.com/trysourcetool/sourcetool/backend/internal/pb/go/redis/v1"
)

type clientCE struct {
	redisClient *redis.Client
}

// Compile-time check to ensure client implements the PubSub interface.
var _ port.PubSub = (*clientCE)(nil)

// NewClient creates a new Redis client implementing the PubSub interface.
func NewClientCE() (port.PubSub, error) {
	redisClient := redis.NewClient(&redis.Options{
		Addr:     fmt.Sprintf("%s:%s", config.Config.Redis.Host, config.Config.Redis.Port),
		Password: config.Config.Redis.Password,
	})

	if err := redisClient.Ping(context.Background()).Err(); err != nil {
		return nil, fmt.Errorf("failed to connect to Redis: %w", err)
	}

	return &clientCE{
		redisClient: redisClient,
	}, nil
}

func (c *clientCE) Publish(ctx context.Context, channel, id string, payload []byte) error {
	message := &redisv1.RedisMessage{
		Id:      id,
		Payload: payload,
	}
	data, err := proto.Marshal(message)
	if err != nil {
		return fmt.Errorf("failed to marshal redis message: %w", err)
	}

	return c.redisClient.Publish(ctx, channel, data).Err()
}

func (c *clientCE) Subscribe(ctx context.Context, channel string) (<-chan *port.Message, error) {
	redisPubSub := c.redisClient.Subscribe(ctx, channel)
	// Wait for confirmation that subscription is created before receiving anything.
	if _, err := redisPubSub.Receive(ctx); err != nil {
		return nil, fmt.Errorf("failed to subscribe to channel %q: %w", channel, err)
	}

	// Create a Go channel to forward messages.
	msgChan := make(chan *port.Message)

	go func() {
		defer close(msgChan)
		defer redisPubSub.Close() // Ensure Redis PubSub is closed when the goroutine exits.

		redisChan := redisPubSub.Channel()

		for {
			select {
			case <-ctx.Done():
				// Context canceled, stop listening.
				return
			case redisMsg, ok := <-redisChan:
				if !ok {
					// Redis channel closed.
					return
				}

				// Unmarshal the received message.
				var message redisv1.RedisMessage
				err := proto.Unmarshal([]byte(redisMsg.Payload), &message)
				if err != nil {
					// Log error or handle it appropriately.
					// For now, we'll just skip this message.
					// Consider adding logging here.
					fmt.Printf("Error unmarshalling message: %v\n", err) // TODO: Replace with proper logging
					continue
				}

				// Forward the message in the application's format.
				msgChan <- &port.Message{
					ID:      message.Id,
					Payload: message.Payload,
				}
			}
		}
	}()

	return msgChan, nil
}

func (c *clientCE) Close() error {
	return c.redisClient.Close()
}
</file>

<file path="internal/infra/smtp/mailer.go">
package smtp

import (
	"context"
	"crypto/tls"
	"fmt"
	"net/smtp"
	"strings"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/logger"
)

var _ port.Mailer = (*mailerCE)(nil)

type mailerCE struct {
	auth      smtp.Auth
	addr      string
	fromEmail string
	tlsConf   *tls.Config
	host      string
}

func NewMailerCE() *mailerCE {
	cfg := config.Config.SMTP
	auth := smtp.PlainAuth("", cfg.Username, cfg.Password, cfg.Host)
	addr := fmt.Sprintf("%s:%s", cfg.Host, cfg.Port)
	tlsConf := &tls.Config{
		ServerName: cfg.Host,
		MinVersion: tls.VersionTLS12,
	}
	return &mailerCE{
		auth:      auth,
		addr:      addr,
		fromEmail: cfg.FromEmail,
		tlsConf:   tlsConf,
		host:      cfg.Host,
	}
}

func (c *mailerCE) Send(ctx context.Context, to []string, from, subject, body string) error {
	msg := fmt.Sprintf("From: %s <%s>\r\n"+
		"To: %s\r\n"+
		"Subject: %s\r\n"+
		"\r\n"+
		"%s\r\n", from, c.fromEmail, strings.Join(to, ","), subject, body)

	if config.Config.Env == config.EnvLocal {
		// In local environment, just log the email content
		logger.Logger.Sugar().Debug("================= EMAIL CONTENT =================")
		logger.Logger.Sugar().Debug(msg)
		logger.Logger.Sugar().Debug("================= EMAIL CONTENT =================")

		// Don't actually send in local environment
		return nil
	}

	conn, err := tls.Dial("tcp", c.addr, c.tlsConf)
	if err != nil {
		return fmt.Errorf("failed to create TLS connection: %w", err)
	}
	defer conn.Close()

	client, err := smtp.NewClient(conn, c.host)
	if err != nil {
		return fmt.Errorf("failed to create SMTP client: %w", err)
	}
	defer client.Close()

	if err = client.Auth(c.auth); err != nil {
		return fmt.Errorf("failed to authenticate: %w", err)
	}

	if err = client.Mail(c.fromEmail); err != nil {
		return fmt.Errorf("failed to set FROM address: %w", err)
	}

	for _, addr := range to {
		if err = client.Rcpt(addr); err != nil {
			return fmt.Errorf("failed to set TO address: %w", err)
		}
	}

	w, err := client.Data()
	if err != nil {
		return fmt.Errorf("failed to create message writer: %w", err)
	}

	if _, err = w.Write([]byte(msg)); err != nil {
		return fmt.Errorf("failed to write message: %w", err)
	}

	if err = w.Close(); err != nil {
		return fmt.Errorf("failed to close message writer: %w", err)
	}

	return client.Quit()
}
</file>

<file path="internal/infra/wsmanager/ping.go">
package wsmanager

import (
	"context"
	"fmt"
	"time"

	"github.com/gorilla/websocket"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/logger"
)

const (
	// Time allowed to write a message to the peer.
	writeWait = 10 * time.Second

	// Send pings to peer with this period.
	pingPeriod = 30 * time.Second
)

// pingConnection sends a ping control message to the given websocket connection.
func (m *manager) pingConnection(conn *websocket.Conn) error {
	// Set write deadline
	if err := conn.SetWriteDeadline(time.Now().Add(writeWait)); err != nil {
		return fmt.Errorf("failed to set write deadline: %w", err)
	}

	// Write ping message directly
	if err := conn.WriteControl(websocket.PingMessage, []byte{}, time.Now().Add(writeWait)); err != nil {
		return fmt.Errorf("failed to write ping message: %w", err)
	}

	return nil
}

// startHostPingLoop starts a goroutine that periodically sends ping messages to a connected host.
// It stops when the host's done channel is closed.
func (m *manager) startHostPingLoop(host *connectedHost) {
	ticker := time.NewTicker(pingPeriod)
	defer ticker.Stop()

	for {
		select {
		case <-host.done:
			return
		case <-ticker.C:
			if err := m.pingConnection(host.conn); err != nil {
				// Consider retrying the connection a few times before disconnecting the host immediately.

				logger.Logger.Sugar().Errorf("Failed to ping host %s: %v", host.hostInstance.ID, err)

				host.hostInstance.Status = hostinstance.HostInstanceStatusUnreachable

				if err := m.repo.HostInstance().Update(context.Background(), host.hostInstance); err != nil {
					logger.Logger.Sugar().Errorf("Failed to update host status: %v", err)
				}

				m.DisconnectHost(host.hostInstance.ID) // Use manager method
				return
			}

			logger.Logger.Sugar().Debugf("Successfully pinged host %s", host.hostInstance.ID)
		}
	}
}

// startClientPingLoop starts a goroutine that periodically sends ping messages to a connected client.
// It stops when the client's done channel is closed.
func (m *manager) startClientPingLoop(client *connectedClient) {
	ticker := time.NewTicker(pingPeriod)
	defer ticker.Stop()

	for {
		select {
		case <-client.done:
			return
		case <-ticker.C:
			if err := m.pingConnection(client.conn); err != nil {
				// Consider retrying the connection a few times before disconnecting the client immediately.

				logger.Logger.Sugar().Errorf("Failed to ping client %s: %v", client.session.ID, err)

				if err := m.repo.Session().Delete(context.Background(), client.session); err != nil {
					logger.Logger.Sugar().Errorf("Failed to delete session %s: %v", client.session.ID, err)
				}

				m.DisconnectClient(client.session.ID) // Use manager method
				return
			}

			logger.Logger.Sugar().Debugf("Successfully pinged client %s", client.session.ID)
		}
	}
}
</file>

<file path="internal/infra/wsmanager/subscriber.go">
package wsmanager

import (
	"fmt"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/gorilla/websocket"
	"google.golang.org/protobuf/proto"

	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	websocketv1 "github.com/trysourcetool/sourcetool/backend/internal/pb/go/websocket/v1"
	"github.com/trysourcetool/sourcetool/backend/logger"
)

const (
	// Maximum number of reconnection attempts for subscribers.
	maxReconnectAttempts = 5

	// Base delay for exponential backoff (in milliseconds).
	baseReconnectDelay = 100
)

// subscribeToHostMessages starts a goroutine to subscribe to messages for hosts from the pub/sub system.
// It handles reconnection logic with exponential backoff.
func (m *manager) subscribeToHostMessages() {
	defer m.wg.Done()

	for attempt := range maxReconnectAttempts {
		if err := m.subscribeToHostMessagesWithRetry(); err != nil {
			if m.ctx.Err() != nil {
				logger.Logger.Sugar().Info("Host message subscriber stopping due to context cancellation during retry.")
				return // Context canceled, stop trying
			}
			if attempt == maxReconnectAttempts-1 {
				logger.Logger.Sugar().Errorf("Failed to subscribe to host messages after %d attempts: %v", maxReconnectAttempts, err)
				return
			}
			// Exponential backoff
			delay := time.Duration(baseReconnectDelay*(1<<attempt)) * time.Millisecond
			logger.Logger.Sugar().Warnf("Retrying host message subscription in %v (attempt %d/%d)", delay, attempt+1, maxReconnectAttempts)
			time.Sleep(delay)
			continue
		}
		// Successful subscription or context canceled during subscription
		return
	}
}

// subscribeToHostMessagesWithRetry attempts to subscribe to the host message channel and process messages.
// It returns an error if the subscription fails or the channel closes unexpectedly.
func (m *manager) subscribeToHostMessagesWithRetry() error {
	ch, err := m.pubsubClient.Subscribe(m.ctx, "host_messages")
	if err != nil {
		return fmt.Errorf("failed to subscribe to host messages: %w", err)
	}
	logger.Logger.Sugar().Info("Subscribed to host messages")

	for {
		select {
		case <-m.ctx.Done():
			logger.Logger.Sugar().Info("Host message subscriber stopping due to context cancellation.")
			return nil // Normal shutdown
		case msg, ok := <-ch:
			if !ok {
				// Check context again to differentiate between unexpected close and shutdown
				if m.ctx.Err() != nil {
					logger.Logger.Sugar().Info("Host message channel closed due to context cancellation.")
					return nil
				}
				return fmt.Errorf("host message channel closed unexpectedly")
			}

			if err := m.processHostMessage(msg); err != nil {
				logger.Logger.Sugar().Errorf("Failed to process host message: %v", err)
				// Continue processing other messages even if one fails
				continue
			}
		}
	}
}

// processHostMessage unmarshals a message from pub/sub and forwards it to the appropriate connected host.
func (m *manager) processHostMessage(msg *port.Message) error {
	// The pubsub layer already unwraps redisv1.RedisMessage and gives us the ID and Payload.
	hostInstanceID, err := uuid.FromString(msg.ID)
	if err != nil {
		return fmt.Errorf("invalid host instance ID: %w", err)
	}

	var protoMsg websocketv1.Message
	if err := proto.Unmarshal(msg.Payload, &protoMsg); err != nil {
		return fmt.Errorf("failed to unmarshal websocket message: %w", err)
	}

	// logger.Logger.Sugar().Debugf("Received message for host: %s, type: %T", hostInstanceID, protoMsg.GetPayload()) // Example Debugging

	m.hostsMutex.RLock()
	host, ok := m.connectedHosts[hostInstanceID]
	m.hostsMutex.RUnlock()

	if !ok {
		// This can happen normally if the host disconnected between message publish and processing
		logger.Logger.Sugar().Debugf("Host %s not found for message ID %s, likely disconnected.", hostInstanceID, protoMsg.Id)
		return nil
	}

	logger.Logger.Sugar().Debugf("Sending message %s to host %s", protoMsg.Id, host.hostInstance.ID)

	data, err := proto.Marshal(&protoMsg)
	if err != nil {
		return fmt.Errorf("failed to marshal message for host %s: %w", host.hostInstance.ID, err)
	}

	if err := host.conn.SetWriteDeadline(time.Now().Add(writeWait)); err != nil {
		// Log the error but attempt to send anyway, or disconnect?
		logger.Logger.Sugar().Warnf("Failed to set write deadline for host %s before sending message %s: %v", host.hostInstance.ID, protoMsg.Id, err)
		// Let the WriteMessage handle the error more definitively
	}

	if err := host.conn.WriteMessage(websocket.BinaryMessage, data); err != nil {
		logger.Logger.Sugar().Errorf("Failed to send message %s to host %s, disconnecting: %v", protoMsg.Id, host.hostInstance.ID, err)
		m.DisconnectHost(hostInstanceID) // Disconnect on write failure
		return fmt.Errorf("failed to send message to host %s: %w", host.hostInstance.ID, err)
	}

	return nil
}

// subscribeToClientMessages starts a goroutine to subscribe to messages for clients from the pub/sub system.
// It handles reconnection logic with exponential backoff.
func (m *manager) subscribeToClientMessages() {
	defer m.wg.Done()

	for attempt := range maxReconnectAttempts {
		if err := m.subscribeToClientMessagesWithRetry(); err != nil {
			if m.ctx.Err() != nil {
				logger.Logger.Sugar().Info("Client message subscriber stopping due to context cancellation during retry.")
				return // Context canceled, stop trying
			}
			if attempt == maxReconnectAttempts-1 {
				logger.Logger.Sugar().Errorf("Failed to subscribe to client messages after %d attempts: %v", maxReconnectAttempts, err)
				return
			}
			// Exponential backoff
			delay := time.Duration(baseReconnectDelay*(1<<attempt)) * time.Millisecond
			logger.Logger.Sugar().Warnf("Retrying client message subscription in %v (attempt %d/%d)", delay, attempt+1, maxReconnectAttempts)
			time.Sleep(delay)
			continue
		}
		// Successful subscription or context canceled during subscription
		return
	}
}

// subscribeToClientMessagesWithRetry attempts to subscribe to the client message channel and process messages.
// It returns an error if the subscription fails or the channel closes unexpectedly.
func (m *manager) subscribeToClientMessagesWithRetry() error {
	ch, err := m.pubsubClient.Subscribe(m.ctx, "client_messages")
	if err != nil {
		return fmt.Errorf("failed to subscribe to client messages: %w", err)
	}
	logger.Logger.Sugar().Info("Subscribed to client messages")

	for {
		select {
		case <-m.ctx.Done():
			logger.Logger.Sugar().Info("Client message subscriber stopping due to context cancellation.")
			return nil // Normal shutdown
		case msg, ok := <-ch:
			if !ok {
				// Check context again to differentiate between unexpected close and shutdown
				if m.ctx.Err() != nil {
					logger.Logger.Sugar().Info("Client message channel closed due to context cancellation.")
					return nil
				}
				return fmt.Errorf("client message channel closed unexpectedly")
			}

			if err := m.processClientMessage(msg); err != nil {
				logger.Logger.Sugar().Errorf("Failed to process client message: %v", err)
				// Continue processing other messages even if one fails
				continue
			}
		}
	}
}

// processClientMessage unmarshals a message from pub/sub and forwards it to the appropriate connected client.
func (m *manager) processClientMessage(msg *port.Message) error {
	sessionID, err := uuid.FromString(msg.ID)
	if err != nil {
		return fmt.Errorf("invalid session ID: %w", err)
	}

	var protoMsg websocketv1.Message
	if err := proto.Unmarshal(msg.Payload, &protoMsg); err != nil {
		return fmt.Errorf("failed to unmarshal websocket message: %w", err)
	}

	// logger.Logger.Sugar().Debugf("Received message for client: %s, type: %T", sessionID, protoMsg.GetPayload()) // Example Debugging

	m.clientsMutex.RLock()
	client, ok := m.connectedClients[sessionID]
	m.clientsMutex.RUnlock()

	if !ok {
		// This can happen normally if the client disconnected between message publish and processing
		logger.Logger.Sugar().Debugf("Client %s not found for message ID %s, likely disconnected.", sessionID, protoMsg.Id)
		return nil
	}

	logger.Logger.Sugar().Debugf("Sending message %s to client %s", protoMsg.Id, client.session.ID)

	data, err := proto.Marshal(&protoMsg)
	if err != nil {
		return fmt.Errorf("failed to marshal message for client %s: %w", client.session.ID, err)
	}

	if err := client.conn.SetWriteDeadline(time.Now().Add(writeWait)); err != nil {
		// Log the error but attempt to send anyway, or disconnect?
		logger.Logger.Sugar().Warnf("Failed to set write deadline for client %s before sending message %s: %v", client.session.ID, protoMsg.Id, err)
		// Let the WriteMessage handle the error more definitively
	}

	if err := client.conn.WriteMessage(websocket.BinaryMessage, data); err != nil {
		logger.Logger.Sugar().Errorf("Failed to send message %s to client %s, disconnecting: %v", protoMsg.Id, client.session.ID, err)
		m.DisconnectClient(sessionID) // Disconnect on write failure
		return fmt.Errorf("failed to send message to client %s: %w", client.session.ID, err)
	}

	return nil
}
</file>

<file path="internal/infra/wsmanager/types.go">
package wsmanager

import (
	"github.com/gorilla/websocket"

	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/session"
)

// connectedHost represents a connected host instance with its associated data.
type connectedHost struct {
	hostInstance *hostinstance.HostInstance
	apiKey       *apikey.APIKey
	conn         *websocket.Conn
	done         chan struct{} // Channel to signal termination for the host's goroutines (e.g., ping loop)
}

// connectedClient represents a connected client session with its associated data.
type connectedClient struct {
	session *session.Session
	conn    *websocket.Conn
	done    chan struct{} // Channel to signal termination for the client's goroutines (e.g., ping loop)
}
</file>

<file path="internal/infra/wsmanager/wsmanager.go">
package wsmanager

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/gorilla/websocket"
	"google.golang.org/protobuf/proto"

	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/session"
	websocketv1 "github.com/trysourcetool/sourcetool/backend/internal/pb/go/websocket/v1"
	"github.com/trysourcetool/sourcetool/backend/logger"
)

const (
	// Time allowed to read the next pong message from the client.
	clientPongWait = 1 * time.Minute

	// Time allowed to read the next pong message from the host.
	hostPongWait = 6 * time.Hour
)

// manager handles WebSocket connections for hosts and clients.
// It implements the port.WSManager interface.
type manager struct {
	connectedHosts   map[uuid.UUID]*connectedHost
	connectedClients map[uuid.UUID]*connectedClient
	hostsMutex       sync.RWMutex
	clientsMutex     sync.RWMutex
	pubsubClient     port.PubSub
	repo             port.Repository
	ctx              context.Context    // Context for managing goroutine lifecycle
	cancel           context.CancelFunc // Function to cancel the context
	wg               sync.WaitGroup     // WaitGroup to wait for goroutines to finish
}

// Compile-time check to ensure manager implements port.WSManager.
var _ port.WSManager = (*manager)(nil)

// NewManager creates and initializes a new WebSocket connection manager.
// It starts the background goroutines for handling pub/sub messages.
func NewManager(ctx context.Context, repo port.Repository, pubsubClient port.PubSub) port.WSManager {
	managerCtx, cancel := context.WithCancel(ctx) // Use parent context
	m := &manager{
		connectedHosts:   make(map[uuid.UUID]*connectedHost),
		connectedClients: make(map[uuid.UUID]*connectedClient),
		pubsubClient:     pubsubClient,
		repo:             repo,
		ctx:              managerCtx,
		cancel:           cancel,
	}

	m.wg.Add(2) // Add count for the two subscriber goroutines
	go m.subscribeToHostMessages()
	go m.subscribeToClientMessages()

	return m
}

// SendToHost publishes a message destined for a specific host to the pub/sub system.
func (m *manager) SendToHost(ctx context.Context, hostInstanceID uuid.UUID, msg *websocketv1.Message) error {
	data, err := proto.Marshal(msg)
	if err != nil {
		return fmt.Errorf("failed to marshal protobuf message for host %s: %w", hostInstanceID, err)
	}

	logger.Logger.Sugar().Debugf("Publishing message %s to host_messages for host %s", msg.Id, hostInstanceID)
	return m.pubsubClient.Publish(ctx, "host_messages", hostInstanceID.String(), data)
}

// SendToClient publishes a message destined for a specific client to the pub/sub system.
func (m *manager) SendToClient(ctx context.Context, sessionID uuid.UUID, msg *websocketv1.Message) error {
	data, err := proto.Marshal(msg)
	if err != nil {
		return fmt.Errorf("failed to marshal protobuf message for client %s: %w", sessionID, err)
	}

	logger.Logger.Sugar().Debugf("Publishing message %s to client_messages for client %s", msg.Id, sessionID)
	return m.pubsubClient.Publish(ctx, "client_messages", sessionID.String(), data)
}

// SetConnectedHost registers a new host connection with the manager.
// It handles potential existing connections and starts the ping loop.
func (m *manager) SetConnectedHost(hostInstance *hostinstance.HostInstance, apiKey *apikey.APIKey, conn *websocket.Conn) {
	// Disconnect any existing connection for the same host ID first.
	m.DisconnectHost(hostInstance.ID)

	logger.Logger.Sugar().Infof("Registering new connection for host: %s", hostInstance.ID)

	conn.SetPongHandler(func(string) error {
		logger.Logger.Sugar().Debugf("Received pong from host %s", hostInstance.ID)
		return conn.SetReadDeadline(time.Now().Add(hostPongWait))
	})

	host := &connectedHost{
		hostInstance: hostInstance,
		apiKey:       apiKey,
		conn:         conn,
		done:         make(chan struct{}),
	}

	m.hostsMutex.Lock()
	m.connectedHosts[hostInstance.ID] = host
	m.hostsMutex.Unlock()

	m.wg.Add(1) // Add to WaitGroup for the ping loop
	go func() {
		defer m.wg.Done()
		m.startHostPingLoop(host)
	}()
}

// DisconnectHost removes a host connection from the manager and closes the connection.
func (m *manager) DisconnectHost(hostInstanceID uuid.UUID) {
	m.hostsMutex.Lock()
	host, ok := m.connectedHosts[hostInstanceID]
	if ok {
		delete(m.connectedHosts, hostInstanceID)
	}
	m.hostsMutex.Unlock()

	if ok {
		close(host.done) // Stop ping loop
		logger.Logger.Sugar().Infof("Disconnecting host: %s", hostInstanceID)

		// Explicitly close the WebSocket connection
		if err := host.conn.Close(); err != nil {
			logger.Logger.Sugar().Errorf("Failed to close host WebSocket connection for %s: %v", hostInstanceID, err)
		} else {
			logger.Logger.Sugar().Debugf("Closed host WebSocket connection for %s", hostInstanceID)
		}
	} else {
		logger.Logger.Sugar().Debugf("Attempted to disconnect host %s, but it was not found.", hostInstanceID)
	}
}

// SetConnectedClient registers a new client connection with the manager.
// It handles potential existing connections and starts the ping loop.
func (m *manager) SetConnectedClient(session *session.Session, conn *websocket.Conn) {
	// Disconnect any existing connection for the same session ID first.
	m.DisconnectClient(session.ID)

	logger.Logger.Sugar().Infof("Registering new connection for client session: %s", session.ID)

	conn.SetPongHandler(func(string) error {
		logger.Logger.Sugar().Debugf("Received pong from client %s", session.ID)
		return conn.SetReadDeadline(time.Now().Add(clientPongWait))
	})

	client := &connectedClient{
		session: session,
		conn:    conn,
		done:    make(chan struct{}),
	}

	m.clientsMutex.Lock()
	m.connectedClients[session.ID] = client
	m.clientsMutex.Unlock()

	m.wg.Add(1) // Add to WaitGroup for the ping loop
	go func() {
		defer m.wg.Done()
		m.startClientPingLoop(client)
	}()
}

// DisconnectClient removes a client connection from the manager and closes the connection.
func (m *manager) DisconnectClient(sessionID uuid.UUID) {
	m.clientsMutex.Lock()
	client, ok := m.connectedClients[sessionID]
	if ok {
		delete(m.connectedClients, sessionID)
	}
	m.clientsMutex.Unlock()

	if ok {
		close(client.done) // Stop ping loop
		logger.Logger.Sugar().Infof("Disconnecting client: %s", sessionID)

		// Explicitly close the WebSocket connection
		if err := client.conn.Close(); err != nil {
			logger.Logger.Sugar().Errorf("Failed to close client WebSocket connection for %s: %v", sessionID, err)
		} else {
			logger.Logger.Sugar().Debugf("Closed client WebSocket connection for %s", sessionID)
		}
	} else {
		logger.Logger.Sugar().Debugf("Attempted to disconnect client %s, but it was not found.", sessionID)
	}
}

// Close gracefully shuts down the connection manager.
// It stops all background goroutines (ping loops, subscribers) and closes connections.
func (m *manager) Close() error {
	logger.Logger.Sugar().Info("Closing WebSocket connection manager...")

	logger.Logger.Sugar().Info("Canceling connection manager context...")
	m.cancel() // This signals subscribers to stop

	logger.Logger.Sugar().Info("Signaling ping loops to stop...")
	m.hostsMutex.Lock()
	for id, host := range m.connectedHosts {
		logger.Logger.Sugar().Debugf("Closing done channel for host %s", id)
		close(host.done)
		if err := host.conn.Close(); err != nil {
			logger.Logger.Sugar().Errorf("Failed to close host WebSocket connection for %s: %v", id, err)
		} else {
			logger.Logger.Sugar().Debugf("Closed host WebSocket connection for %s", id)
		}
	}
	m.hostsMutex.Unlock()

	m.clientsMutex.Lock()
	for id, client := range m.connectedClients {
		logger.Logger.Sugar().Debugf("Closing done channel for client %s", id)
		close(client.done)
		if err := client.conn.Close(); err != nil {
			logger.Logger.Sugar().Errorf("Failed to close client WebSocket connection for %s: %v", id, err)
		} else {
			logger.Logger.Sugar().Debugf("Closed client WebSocket connection for %s", id)
		}
	}
	m.clientsMutex.Unlock()

	logger.Logger.Sugar().Info("Waiting for background goroutines to stop...")
	done := make(chan struct{})
	go func() {
		m.wg.Wait()
		close(done)
	}()

	select {
	case <-done:
		logger.Logger.Sugar().Info("All background goroutines stopped.")
	case <-time.After(30 * time.Second): // Add a timeout
		logger.Logger.Sugar().Error("Timeout waiting for background goroutines to stop.")
		return errors.New("timeout closing connection manager goroutines")
	}

	m.hostsMutex.Lock()
	m.connectedHosts = make(map[uuid.UUID]*connectedHost)
	m.hostsMutex.Unlock()

	m.clientsMutex.Lock()
	m.connectedClients = make(map[uuid.UUID]*connectedClient)
	m.clientsMutex.Unlock()

	logger.Logger.Sugar().Info("WebSocket connection manager closed.")
	return nil
}

// PingConnectedHost is an internal method (not part of port.WSManager) for sending a direct ping.
// It's kept separate as direct pinging might be an infra-specific detail.
// Renamed to PingConnectedHost to avoid conflict with interface methods if any.
func (m *manager) PingConnectedHost(hostInstanceID uuid.UUID) error {
	m.hostsMutex.RLock()
	host, ok := m.connectedHosts[hostInstanceID]
	m.hostsMutex.RUnlock()

	if ok {
		return m.pingConnection(host.conn)
	}
	return fmt.Errorf("host connection %s not found for ping", hostInstanceID)
}
</file>

<file path="internal/jwt/claims.go">
package jwt

import (
	"github.com/gofrs/uuid/v5"
	"github.com/golang-jwt/jwt/v5"
)

const (
	Issuer = "trysourcetool.com"

	UserSignatureSubjectEmail                 = "email"
	UserSignatureSubjectUpdateEmail           = "update_email"
	UserSignatureSubjectActivate              = "activate"
	UserSignatureSubjectInvitation            = "invitation"
	UserSignatureSubjectInvitationMagicLink   = "invitation_magic_link"
	UserSignatureSubjectMagicLink             = "magic_link"
	UserSignatureSubjectMagicLinkRegistration = "magic_link_registration"
	UserSignatureSubjectGoogleAuthLink        = "google_auth_link"
	UserSignatureSubjectGoogleRegistration    = "google_registration"
)

type RegisteredClaims jwt.RegisteredClaims

// UserClaims represents claims for general user authentication.
type UserClaims struct {
	UserID string
	Email  string
	jwt.RegisteredClaims
}

// UserEmailClaims represents claims for email-related operations.
type UserEmailClaims struct {
	Email string
	jwt.RegisteredClaims
}

// UserAuthClaims represents claims for user authentication with XSRF token.
type UserAuthClaims struct {
	UserID    string
	XSRFToken string
	jwt.RegisteredClaims
}

// UserMagicLinkRegistrationClaims represents claims for magic link registration.
type UserMagicLinkRegistrationClaims struct {
	Email string
	jwt.RegisteredClaims
}

type GoogleAuthFlow string

const (
	GoogleAuthFlowStandard   GoogleAuthFlow = "standard"
	GoogleAuthFlowInvitation GoogleAuthFlow = "invitation"
)

// UserGoogleAuthLinkClaims represents claims for Google authentication link.
type UserGoogleAuthLinkClaims struct {
	Flow            GoogleAuthFlow
	InvitationOrgID uuid.UUID
	HostSubdomain   string
	jwt.RegisteredClaims
}

// UserGoogleRegistrationClaims represents claims for Google registration.
type UserGoogleRegistrationClaims struct {
	GoogleID        string
	Email           string
	FirstName       string
	LastName        string
	Flow            GoogleAuthFlow
	InvitationOrgID uuid.UUID
	Role            string // Only for invitation flow
	jwt.RegisteredClaims
}
</file>

<file path="internal/jwt/jwt.go">
package jwt

import (
	"errors"
	"fmt"

	"github.com/golang-jwt/jwt/v5"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

// JWTClaims is a generic constraint for all JWT claims types.
type JWTClaims interface {
	jwt.Claims
	*UserClaims | *UserEmailClaims | *UserAuthClaims | *UserMagicLinkRegistrationClaims | *UserGoogleRegistrationClaims | *UserGoogleAuthLinkClaims
}

// NewClaims creates a new instance of the claims type.
func NewClaims[T JWTClaims]() T {
	var zero T
	switch any(zero).(type) {
	case *UserClaims:
		return any(&UserClaims{}).(T)
	case *UserEmailClaims:
		return any(&UserEmailClaims{}).(T)
	case *UserAuthClaims:
		return any(&UserAuthClaims{}).(T)
	case *UserGoogleRegistrationClaims:
		return any(&UserGoogleRegistrationClaims{}).(T)
	case *UserGoogleAuthLinkClaims:
		return any(&UserGoogleAuthLinkClaims{}).(T)
	case *UserMagicLinkRegistrationClaims:
		return any(&UserMagicLinkRegistrationClaims{}).(T)
	default:
		return zero
	}
}

// SignToken is a generic function to sign JWT tokens.
func SignToken[T JWTClaims](claims T) (string, error) {
	tok := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	token, err := tok.SignedString([]byte(config.Config.Jwt.Key))
	if err != nil {
		return "", errdefs.ErrInternal(err)
	}

	return token, nil
}

// ParseToken is a generic function to parse JWT tokens.
func ParseToken[T JWTClaims](token string) (T, error) {
	if token == "" {
		var zero T
		return zero, errdefs.ErrInternal(errors.New("failed to get token"))
	}

	result := NewClaims[T]()
	_, err := jwt.ParseWithClaims(token, result, func(token *jwt.Token) (any, error) {
		return []byte(config.Config.Jwt.Key), nil
	})
	if err != nil {
		var zero T
		return zero, errdefs.ErrInternal(fmt.Errorf("failed to parse token: %s", err))
	}

	return result, nil
}
</file>

<file path="internal/pb/go/exception/v1/exception.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: exception/v1/exception.proto

package exceptionv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Exception struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Title         string                 `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	StackTrace    []string               `protobuf:"bytes,3,rep,name=stack_trace,json=stackTrace,proto3" json:"stack_trace,omitempty"`
	SessionId     string                 `protobuf:"bytes,4,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Exception) Reset() {
	*x = Exception{}
	mi := &file_exception_v1_exception_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Exception) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Exception) ProtoMessage() {}

func (x *Exception) ProtoReflect() protoreflect.Message {
	mi := &file_exception_v1_exception_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Exception.ProtoReflect.Descriptor instead.
func (*Exception) Descriptor() ([]byte, []int) {
	return file_exception_v1_exception_proto_rawDescGZIP(), []int{0}
}

func (x *Exception) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *Exception) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *Exception) GetStackTrace() []string {
	if x != nil {
		return x.StackTrace
	}
	return nil
}

func (x *Exception) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

var File_exception_v1_exception_proto protoreflect.FileDescriptor

const file_exception_v1_exception_proto_rawDesc = "" +
	"\n" +
	"\x1cexception/v1/exception.proto\x12\fexception.v1\"{\n" +
	"\tException\x12\x14\n" +
	"\x05title\x18\x01 \x01(\tR\x05title\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x1f\n" +
	"\vstack_trace\x18\x03 \x03(\tR\n" +
	"stackTrace\x12\x1d\n" +
	"\n" +
	"session_id\x18\x04 \x01(\tR\tsessionIdB\xca\x01\n" +
	"\x10com.exception.v1B\x0eExceptionProtoP\x01ZSgithub.com/trysourcetool/sourcetool/backend/internal/pb/go/exception/v1;exceptionv1\xa2\x02\x03EXX\xaa\x02\fException.V1\xca\x02\rException_\\V1\xe2\x02\x19Exception_\\V1\\GPBMetadata\xea\x02\rException::V1b\x06proto3"

var (
	file_exception_v1_exception_proto_rawDescOnce sync.Once
	file_exception_v1_exception_proto_rawDescData []byte
)

func file_exception_v1_exception_proto_rawDescGZIP() []byte {
	file_exception_v1_exception_proto_rawDescOnce.Do(func() {
		file_exception_v1_exception_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_exception_v1_exception_proto_rawDesc), len(file_exception_v1_exception_proto_rawDesc)))
	})
	return file_exception_v1_exception_proto_rawDescData
}

var file_exception_v1_exception_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_exception_v1_exception_proto_goTypes = []any{
	(*Exception)(nil), // 0: exception.v1.Exception
}
var file_exception_v1_exception_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_exception_v1_exception_proto_init() }
func file_exception_v1_exception_proto_init() {
	if File_exception_v1_exception_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_exception_v1_exception_proto_rawDesc), len(file_exception_v1_exception_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_exception_v1_exception_proto_goTypes,
		DependencyIndexes: file_exception_v1_exception_proto_depIdxs,
		MessageInfos:      file_exception_v1_exception_proto_msgTypes,
	}.Build()
	File_exception_v1_exception_proto = out.File
	file_exception_v1_exception_proto_goTypes = nil
	file_exception_v1_exception_proto_depIdxs = nil
}
</file>

<file path="internal/pb/go/page/v1/page.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: page/v1/page.proto

package pagev1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Page struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Route         string                 `protobuf:"bytes,3,opt,name=route,proto3" json:"route,omitempty"`
	Path          []int32                `protobuf:"varint,4,rep,packed,name=path,proto3" json:"path,omitempty"`
	Groups        []string               `protobuf:"bytes,5,rep,name=groups,proto3" json:"groups,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Page) Reset() {
	*x = Page{}
	mi := &file_page_v1_page_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Page) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Page) ProtoMessage() {}

func (x *Page) ProtoReflect() protoreflect.Message {
	mi := &file_page_v1_page_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Page.ProtoReflect.Descriptor instead.
func (*Page) Descriptor() ([]byte, []int) {
	return file_page_v1_page_proto_rawDescGZIP(), []int{0}
}

func (x *Page) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Page) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Page) GetRoute() string {
	if x != nil {
		return x.Route
	}
	return ""
}

func (x *Page) GetPath() []int32 {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *Page) GetGroups() []string {
	if x != nil {
		return x.Groups
	}
	return nil
}

var File_page_v1_page_proto protoreflect.FileDescriptor

const file_page_v1_page_proto_rawDesc = "" +
	"\n" +
	"\x12page/v1/page.proto\x12\apage.v1\"l\n" +
	"\x04Page\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05route\x18\x03 \x01(\tR\x05route\x12\x12\n" +
	"\x04path\x18\x04 \x03(\x05R\x04path\x12\x16\n" +
	"\x06groups\x18\x05 \x03(\tR\x06groupsB\xa0\x01\n" +
	"\vcom.page.v1B\tPageProtoP\x01ZIgithub.com/trysourcetool/sourcetool/backend/internal/pb/go/page/v1;pagev1\xa2\x02\x03PXX\xaa\x02\aPage.V1\xca\x02\aPage\\V1\xe2\x02\x13Page\\V1\\GPBMetadata\xea\x02\bPage::V1b\x06proto3"

var (
	file_page_v1_page_proto_rawDescOnce sync.Once
	file_page_v1_page_proto_rawDescData []byte
)

func file_page_v1_page_proto_rawDescGZIP() []byte {
	file_page_v1_page_proto_rawDescOnce.Do(func() {
		file_page_v1_page_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_page_v1_page_proto_rawDesc), len(file_page_v1_page_proto_rawDesc)))
	})
	return file_page_v1_page_proto_rawDescData
}

var file_page_v1_page_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_page_v1_page_proto_goTypes = []any{
	(*Page)(nil), // 0: page.v1.Page
}
var file_page_v1_page_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_page_v1_page_proto_init() }
func file_page_v1_page_proto_init() {
	if File_page_v1_page_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_page_v1_page_proto_rawDesc), len(file_page_v1_page_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_page_v1_page_proto_goTypes,
		DependencyIndexes: file_page_v1_page_proto_depIdxs,
		MessageInfos:      file_page_v1_page_proto_msgTypes,
	}.Build()
	File_page_v1_page_proto = out.File
	file_page_v1_page_proto_goTypes = nil
	file_page_v1_page_proto_depIdxs = nil
}
</file>

<file path="internal/pb/go/redis/v1/redis.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: redis/v1/redis.proto

package redisv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RedisMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Payload       []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RedisMessage) Reset() {
	*x = RedisMessage{}
	mi := &file_redis_v1_redis_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisMessage) ProtoMessage() {}

func (x *RedisMessage) ProtoReflect() protoreflect.Message {
	mi := &file_redis_v1_redis_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisMessage.ProtoReflect.Descriptor instead.
func (*RedisMessage) Descriptor() ([]byte, []int) {
	return file_redis_v1_redis_proto_rawDescGZIP(), []int{0}
}

func (x *RedisMessage) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *RedisMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

var File_redis_v1_redis_proto protoreflect.FileDescriptor

const file_redis_v1_redis_proto_rawDesc = "" +
	"\n" +
	"\x14redis/v1/redis.proto\x12\bredis.v1\"8\n" +
	"\fRedisMessage\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayloadB\xa8\x01\n" +
	"\fcom.redis.v1B\n" +
	"RedisProtoP\x01ZKgithub.com/trysourcetool/sourcetool/backend/internal/pb/go/redis/v1;redisv1\xa2\x02\x03RXX\xaa\x02\bRedis.V1\xca\x02\bRedis\\V1\xe2\x02\x14Redis\\V1\\GPBMetadata\xea\x02\tRedis::V1b\x06proto3"

var (
	file_redis_v1_redis_proto_rawDescOnce sync.Once
	file_redis_v1_redis_proto_rawDescData []byte
)

func file_redis_v1_redis_proto_rawDescGZIP() []byte {
	file_redis_v1_redis_proto_rawDescOnce.Do(func() {
		file_redis_v1_redis_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_redis_v1_redis_proto_rawDesc), len(file_redis_v1_redis_proto_rawDesc)))
	})
	return file_redis_v1_redis_proto_rawDescData
}

var file_redis_v1_redis_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_redis_v1_redis_proto_goTypes = []any{
	(*RedisMessage)(nil), // 0: redis.v1.RedisMessage
}
var file_redis_v1_redis_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_redis_v1_redis_proto_init() }
func file_redis_v1_redis_proto_init() {
	if File_redis_v1_redis_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_redis_v1_redis_proto_rawDesc), len(file_redis_v1_redis_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_redis_v1_redis_proto_goTypes,
		DependencyIndexes: file_redis_v1_redis_proto_depIdxs,
		MessageInfos:      file_redis_v1_redis_proto_msgTypes,
	}.Build()
	File_redis_v1_redis_proto = out.File
	file_redis_v1_redis_proto_goTypes = nil
	file_redis_v1_redis_proto_depIdxs = nil
}
</file>

<file path="internal/pb/go/websocket/v1/message.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: websocket/v1/message.proto

package websocketv1

import (
	v1 "github.com/trysourcetool/sourcetool/backend/internal/pb/go/exception/v1"
	v11 "github.com/trysourcetool/sourcetool/backend/internal/pb/go/page/v1"
	v12 "github.com/trysourcetool/sourcetool/backend/internal/pb/go/widget/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ScriptFinished_Status int32

const (
	ScriptFinished_STATUS_UNSPECIFIED ScriptFinished_Status = 0
	ScriptFinished_STATUS_SUCCESS     ScriptFinished_Status = 1
	ScriptFinished_STATUS_FAILURE     ScriptFinished_Status = 2
)

// Enum value maps for ScriptFinished_Status.
var (
	ScriptFinished_Status_name = map[int32]string{
		0: "STATUS_UNSPECIFIED",
		1: "STATUS_SUCCESS",
		2: "STATUS_FAILURE",
	}
	ScriptFinished_Status_value = map[string]int32{
		"STATUS_UNSPECIFIED": 0,
		"STATUS_SUCCESS":     1,
		"STATUS_FAILURE":     2,
	}
)

func (x ScriptFinished_Status) Enum() *ScriptFinished_Status {
	p := new(ScriptFinished_Status)
	*p = x
	return p
}

func (x ScriptFinished_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ScriptFinished_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_websocket_v1_message_proto_enumTypes[0].Descriptor()
}

func (ScriptFinished_Status) Type() protoreflect.EnumType {
	return &file_websocket_v1_message_proto_enumTypes[0]
}

func (x ScriptFinished_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ScriptFinished_Status.Descriptor instead.
func (ScriptFinished_Status) EnumDescriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{8, 0}
}

type Message struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Id    string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to Type:
	//
	//	*Message_Exception
	//	*Message_InitializeHost
	//	*Message_InitializeHostCompleted
	//	*Message_InitializeClient
	//	*Message_InitializeClientCompleted
	//	*Message_RenderWidget
	//	*Message_RerunPage
	//	*Message_CloseSession
	//	*Message_ScriptFinished
	Type          isMessage_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Message) Reset() {
	*x = Message{}
	mi := &file_websocket_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Message) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Message) ProtoMessage() {}

func (x *Message) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Message.ProtoReflect.Descriptor instead.
func (*Message) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{0}
}

func (x *Message) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Message) GetType() isMessage_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *Message) GetException() *v1.Exception {
	if x != nil {
		if x, ok := x.Type.(*Message_Exception); ok {
			return x.Exception
		}
	}
	return nil
}

func (x *Message) GetInitializeHost() *InitializeHost {
	if x != nil {
		if x, ok := x.Type.(*Message_InitializeHost); ok {
			return x.InitializeHost
		}
	}
	return nil
}

func (x *Message) GetInitializeHostCompleted() *InitializeHostCompleted {
	if x != nil {
		if x, ok := x.Type.(*Message_InitializeHostCompleted); ok {
			return x.InitializeHostCompleted
		}
	}
	return nil
}

func (x *Message) GetInitializeClient() *InitializeClient {
	if x != nil {
		if x, ok := x.Type.(*Message_InitializeClient); ok {
			return x.InitializeClient
		}
	}
	return nil
}

func (x *Message) GetInitializeClientCompleted() *InitializeClientCompleted {
	if x != nil {
		if x, ok := x.Type.(*Message_InitializeClientCompleted); ok {
			return x.InitializeClientCompleted
		}
	}
	return nil
}

func (x *Message) GetRenderWidget() *RenderWidget {
	if x != nil {
		if x, ok := x.Type.(*Message_RenderWidget); ok {
			return x.RenderWidget
		}
	}
	return nil
}

func (x *Message) GetRerunPage() *RerunPage {
	if x != nil {
		if x, ok := x.Type.(*Message_RerunPage); ok {
			return x.RerunPage
		}
	}
	return nil
}

func (x *Message) GetCloseSession() *CloseSession {
	if x != nil {
		if x, ok := x.Type.(*Message_CloseSession); ok {
			return x.CloseSession
		}
	}
	return nil
}

func (x *Message) GetScriptFinished() *ScriptFinished {
	if x != nil {
		if x, ok := x.Type.(*Message_ScriptFinished); ok {
			return x.ScriptFinished
		}
	}
	return nil
}

type isMessage_Type interface {
	isMessage_Type()
}

type Message_Exception struct {
	Exception *v1.Exception `protobuf:"bytes,2,opt,name=exception,proto3,oneof"`
}

type Message_InitializeHost struct {
	InitializeHost *InitializeHost `protobuf:"bytes,3,opt,name=initialize_host,json=initializeHost,proto3,oneof"`
}

type Message_InitializeHostCompleted struct {
	InitializeHostCompleted *InitializeHostCompleted `protobuf:"bytes,4,opt,name=initialize_host_completed,json=initializeHostCompleted,proto3,oneof"`
}

type Message_InitializeClient struct {
	InitializeClient *InitializeClient `protobuf:"bytes,5,opt,name=initialize_client,json=initializeClient,proto3,oneof"`
}

type Message_InitializeClientCompleted struct {
	InitializeClientCompleted *InitializeClientCompleted `protobuf:"bytes,6,opt,name=initialize_client_completed,json=initializeClientCompleted,proto3,oneof"`
}

type Message_RenderWidget struct {
	RenderWidget *RenderWidget `protobuf:"bytes,7,opt,name=render_widget,json=renderWidget,proto3,oneof"`
}

type Message_RerunPage struct {
	RerunPage *RerunPage `protobuf:"bytes,8,opt,name=rerun_page,json=rerunPage,proto3,oneof"`
}

type Message_CloseSession struct {
	CloseSession *CloseSession `protobuf:"bytes,9,opt,name=close_session,json=closeSession,proto3,oneof"`
}

type Message_ScriptFinished struct {
	ScriptFinished *ScriptFinished `protobuf:"bytes,10,opt,name=script_finished,json=scriptFinished,proto3,oneof"`
}

func (*Message_Exception) isMessage_Type() {}

func (*Message_InitializeHost) isMessage_Type() {}

func (*Message_InitializeHostCompleted) isMessage_Type() {}

func (*Message_InitializeClient) isMessage_Type() {}

func (*Message_InitializeClientCompleted) isMessage_Type() {}

func (*Message_RenderWidget) isMessage_Type() {}

func (*Message_RerunPage) isMessage_Type() {}

func (*Message_CloseSession) isMessage_Type() {}

func (*Message_ScriptFinished) isMessage_Type() {}

type InitializeHost struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ApiKey        string                 `protobuf:"bytes,1,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty"`
	SdkName       string                 `protobuf:"bytes,2,opt,name=sdk_name,json=sdkName,proto3" json:"sdk_name,omitempty"`
	SdkVersion    string                 `protobuf:"bytes,3,opt,name=sdk_version,json=sdkVersion,proto3" json:"sdk_version,omitempty"`
	Pages         []*v11.Page            `protobuf:"bytes,4,rep,name=pages,proto3" json:"pages,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitializeHost) Reset() {
	*x = InitializeHost{}
	mi := &file_websocket_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitializeHost) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitializeHost) ProtoMessage() {}

func (x *InitializeHost) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitializeHost.ProtoReflect.Descriptor instead.
func (*InitializeHost) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{1}
}

func (x *InitializeHost) GetApiKey() string {
	if x != nil {
		return x.ApiKey
	}
	return ""
}

func (x *InitializeHost) GetSdkName() string {
	if x != nil {
		return x.SdkName
	}
	return ""
}

func (x *InitializeHost) GetSdkVersion() string {
	if x != nil {
		return x.SdkVersion
	}
	return ""
}

func (x *InitializeHost) GetPages() []*v11.Page {
	if x != nil {
		return x.Pages
	}
	return nil
}

type InitializeHostCompleted struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	HostInstanceId string                 `protobuf:"bytes,1,opt,name=host_instance_id,json=hostInstanceId,proto3" json:"host_instance_id,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *InitializeHostCompleted) Reset() {
	*x = InitializeHostCompleted{}
	mi := &file_websocket_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitializeHostCompleted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitializeHostCompleted) ProtoMessage() {}

func (x *InitializeHostCompleted) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitializeHostCompleted.ProtoReflect.Descriptor instead.
func (*InitializeHostCompleted) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{2}
}

func (x *InitializeHostCompleted) GetHostInstanceId() string {
	if x != nil {
		return x.HostInstanceId
	}
	return ""
}

type InitializeClient struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     *string                `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3,oneof" json:"session_id,omitempty"`
	PageId        string                 `protobuf:"bytes,2,opt,name=page_id,json=pageId,proto3" json:"page_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitializeClient) Reset() {
	*x = InitializeClient{}
	mi := &file_websocket_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitializeClient) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitializeClient) ProtoMessage() {}

func (x *InitializeClient) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitializeClient.ProtoReflect.Descriptor instead.
func (*InitializeClient) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{3}
}

func (x *InitializeClient) GetSessionId() string {
	if x != nil && x.SessionId != nil {
		return *x.SessionId
	}
	return ""
}

func (x *InitializeClient) GetPageId() string {
	if x != nil {
		return x.PageId
	}
	return ""
}

type InitializeClientCompleted struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitializeClientCompleted) Reset() {
	*x = InitializeClientCompleted{}
	mi := &file_websocket_v1_message_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitializeClientCompleted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitializeClientCompleted) ProtoMessage() {}

func (x *InitializeClientCompleted) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitializeClientCompleted.ProtoReflect.Descriptor instead.
func (*InitializeClientCompleted) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{4}
}

func (x *InitializeClientCompleted) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type RenderWidget struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	PageId        string                 `protobuf:"bytes,2,opt,name=page_id,json=pageId,proto3" json:"page_id,omitempty"`
	Path          []int32                `protobuf:"varint,3,rep,packed,name=path,proto3" json:"path,omitempty"`
	Widget        *v12.Widget            `protobuf:"bytes,4,opt,name=widget,proto3" json:"widget,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RenderWidget) Reset() {
	*x = RenderWidget{}
	mi := &file_websocket_v1_message_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenderWidget) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenderWidget) ProtoMessage() {}

func (x *RenderWidget) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenderWidget.ProtoReflect.Descriptor instead.
func (*RenderWidget) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{5}
}

func (x *RenderWidget) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *RenderWidget) GetPageId() string {
	if x != nil {
		return x.PageId
	}
	return ""
}

func (x *RenderWidget) GetPath() []int32 {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *RenderWidget) GetWidget() *v12.Widget {
	if x != nil {
		return x.Widget
	}
	return nil
}

type RerunPage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	PageId        string                 `protobuf:"bytes,2,opt,name=page_id,json=pageId,proto3" json:"page_id,omitempty"`
	States        []*v12.Widget          `protobuf:"bytes,3,rep,name=states,proto3" json:"states,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RerunPage) Reset() {
	*x = RerunPage{}
	mi := &file_websocket_v1_message_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RerunPage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RerunPage) ProtoMessage() {}

func (x *RerunPage) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RerunPage.ProtoReflect.Descriptor instead.
func (*RerunPage) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{6}
}

func (x *RerunPage) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *RerunPage) GetPageId() string {
	if x != nil {
		return x.PageId
	}
	return ""
}

func (x *RerunPage) GetStates() []*v12.Widget {
	if x != nil {
		return x.States
	}
	return nil
}

type CloseSession struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CloseSession) Reset() {
	*x = CloseSession{}
	mi := &file_websocket_v1_message_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloseSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloseSession) ProtoMessage() {}

func (x *CloseSession) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloseSession.ProtoReflect.Descriptor instead.
func (*CloseSession) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{7}
}

func (x *CloseSession) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type ScriptFinished struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Status        ScriptFinished_Status  `protobuf:"varint,2,opt,name=status,proto3,enum=websocket.v1.ScriptFinished_Status" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScriptFinished) Reset() {
	*x = ScriptFinished{}
	mi := &file_websocket_v1_message_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScriptFinished) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScriptFinished) ProtoMessage() {}

func (x *ScriptFinished) ProtoReflect() protoreflect.Message {
	mi := &file_websocket_v1_message_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScriptFinished.ProtoReflect.Descriptor instead.
func (*ScriptFinished) Descriptor() ([]byte, []int) {
	return file_websocket_v1_message_proto_rawDescGZIP(), []int{8}
}

func (x *ScriptFinished) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *ScriptFinished) GetStatus() ScriptFinished_Status {
	if x != nil {
		return x.Status
	}
	return ScriptFinished_STATUS_UNSPECIFIED
}

var File_websocket_v1_message_proto protoreflect.FileDescriptor

const file_websocket_v1_message_proto_rawDesc = "" +
	"\n" +
	"\x1awebsocket/v1/message.proto\x12\fwebsocket.v1\x1a\x1cexception/v1/exception.proto\x1a\x12page/v1/page.proto\x1a\x16widget/v1/widget.proto\"\xcb\x05\n" +
	"\aMessage\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x127\n" +
	"\texception\x18\x02 \x01(\v2\x17.exception.v1.ExceptionH\x00R\texception\x12G\n" +
	"\x0finitialize_host\x18\x03 \x01(\v2\x1c.websocket.v1.InitializeHostH\x00R\x0einitializeHost\x12c\n" +
	"\x19initialize_host_completed\x18\x04 \x01(\v2%.websocket.v1.InitializeHostCompletedH\x00R\x17initializeHostCompleted\x12M\n" +
	"\x11initialize_client\x18\x05 \x01(\v2\x1e.websocket.v1.InitializeClientH\x00R\x10initializeClient\x12i\n" +
	"\x1binitialize_client_completed\x18\x06 \x01(\v2'.websocket.v1.InitializeClientCompletedH\x00R\x19initializeClientCompleted\x12A\n" +
	"\rrender_widget\x18\a \x01(\v2\x1a.websocket.v1.RenderWidgetH\x00R\frenderWidget\x128\n" +
	"\n" +
	"rerun_page\x18\b \x01(\v2\x17.websocket.v1.RerunPageH\x00R\trerunPage\x12A\n" +
	"\rclose_session\x18\t \x01(\v2\x1a.websocket.v1.CloseSessionH\x00R\fcloseSession\x12G\n" +
	"\x0fscript_finished\x18\n" +
	" \x01(\v2\x1c.websocket.v1.ScriptFinishedH\x00R\x0escriptFinishedB\x06\n" +
	"\x04type\"\x8a\x01\n" +
	"\x0eInitializeHost\x12\x17\n" +
	"\aapi_key\x18\x01 \x01(\tR\x06apiKey\x12\x19\n" +
	"\bsdk_name\x18\x02 \x01(\tR\asdkName\x12\x1f\n" +
	"\vsdk_version\x18\x03 \x01(\tR\n" +
	"sdkVersion\x12#\n" +
	"\x05pages\x18\x04 \x03(\v2\r.page.v1.PageR\x05pages\"C\n" +
	"\x17InitializeHostCompleted\x12(\n" +
	"\x10host_instance_id\x18\x01 \x01(\tR\x0ehostInstanceId\"^\n" +
	"\x10InitializeClient\x12\"\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tH\x00R\tsessionId\x88\x01\x01\x12\x17\n" +
	"\apage_id\x18\x02 \x01(\tR\x06pageIdB\r\n" +
	"\v_session_id\":\n" +
	"\x19InitializeClientCompleted\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\"\x85\x01\n" +
	"\fRenderWidget\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x17\n" +
	"\apage_id\x18\x02 \x01(\tR\x06pageId\x12\x12\n" +
	"\x04path\x18\x03 \x03(\x05R\x04path\x12)\n" +
	"\x06widget\x18\x04 \x01(\v2\x11.widget.v1.WidgetR\x06widget\"n\n" +
	"\tRerunPage\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x17\n" +
	"\apage_id\x18\x02 \x01(\tR\x06pageId\x12)\n" +
	"\x06states\x18\x03 \x03(\v2\x11.widget.v1.WidgetR\x06states\"-\n" +
	"\fCloseSession\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\"\xb6\x01\n" +
	"\x0eScriptFinished\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12;\n" +
	"\x06status\x18\x02 \x01(\x0e2#.websocket.v1.ScriptFinished.StatusR\x06status\"H\n" +
	"\x06Status\x12\x16\n" +
	"\x12STATUS_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eSTATUS_SUCCESS\x10\x01\x12\x12\n" +
	"\x0eSTATUS_FAILURE\x10\x02B\xc6\x01\n" +
	"\x10com.websocket.v1B\fMessageProtoP\x01ZSgithub.com/trysourcetool/sourcetool/backend/internal/pb/go/websocket/v1;websocketv1\xa2\x02\x03WXX\xaa\x02\fWebsocket.V1\xca\x02\fWebsocket\\V1\xe2\x02\x18Websocket\\V1\\GPBMetadata\xea\x02\rWebsocket::V1b\x06proto3"

var (
	file_websocket_v1_message_proto_rawDescOnce sync.Once
	file_websocket_v1_message_proto_rawDescData []byte
)

func file_websocket_v1_message_proto_rawDescGZIP() []byte {
	file_websocket_v1_message_proto_rawDescOnce.Do(func() {
		file_websocket_v1_message_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_websocket_v1_message_proto_rawDesc), len(file_websocket_v1_message_proto_rawDesc)))
	})
	return file_websocket_v1_message_proto_rawDescData
}

var file_websocket_v1_message_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_websocket_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_websocket_v1_message_proto_goTypes = []any{
	(ScriptFinished_Status)(0),        // 0: websocket.v1.ScriptFinished.Status
	(*Message)(nil),                   // 1: websocket.v1.Message
	(*InitializeHost)(nil),            // 2: websocket.v1.InitializeHost
	(*InitializeHostCompleted)(nil),   // 3: websocket.v1.InitializeHostCompleted
	(*InitializeClient)(nil),          // 4: websocket.v1.InitializeClient
	(*InitializeClientCompleted)(nil), // 5: websocket.v1.InitializeClientCompleted
	(*RenderWidget)(nil),              // 6: websocket.v1.RenderWidget
	(*RerunPage)(nil),                 // 7: websocket.v1.RerunPage
	(*CloseSession)(nil),              // 8: websocket.v1.CloseSession
	(*ScriptFinished)(nil),            // 9: websocket.v1.ScriptFinished
	(*v1.Exception)(nil),              // 10: exception.v1.Exception
	(*v11.Page)(nil),                  // 11: page.v1.Page
	(*v12.Widget)(nil),                // 12: widget.v1.Widget
}
var file_websocket_v1_message_proto_depIdxs = []int32{
	10, // 0: websocket.v1.Message.exception:type_name -> exception.v1.Exception
	2,  // 1: websocket.v1.Message.initialize_host:type_name -> websocket.v1.InitializeHost
	3,  // 2: websocket.v1.Message.initialize_host_completed:type_name -> websocket.v1.InitializeHostCompleted
	4,  // 3: websocket.v1.Message.initialize_client:type_name -> websocket.v1.InitializeClient
	5,  // 4: websocket.v1.Message.initialize_client_completed:type_name -> websocket.v1.InitializeClientCompleted
	6,  // 5: websocket.v1.Message.render_widget:type_name -> websocket.v1.RenderWidget
	7,  // 6: websocket.v1.Message.rerun_page:type_name -> websocket.v1.RerunPage
	8,  // 7: websocket.v1.Message.close_session:type_name -> websocket.v1.CloseSession
	9,  // 8: websocket.v1.Message.script_finished:type_name -> websocket.v1.ScriptFinished
	11, // 9: websocket.v1.InitializeHost.pages:type_name -> page.v1.Page
	12, // 10: websocket.v1.RenderWidget.widget:type_name -> widget.v1.Widget
	12, // 11: websocket.v1.RerunPage.states:type_name -> widget.v1.Widget
	0,  // 12: websocket.v1.ScriptFinished.status:type_name -> websocket.v1.ScriptFinished.Status
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_websocket_v1_message_proto_init() }
func file_websocket_v1_message_proto_init() {
	if File_websocket_v1_message_proto != nil {
		return
	}
	file_websocket_v1_message_proto_msgTypes[0].OneofWrappers = []any{
		(*Message_Exception)(nil),
		(*Message_InitializeHost)(nil),
		(*Message_InitializeHostCompleted)(nil),
		(*Message_InitializeClient)(nil),
		(*Message_InitializeClientCompleted)(nil),
		(*Message_RenderWidget)(nil),
		(*Message_RerunPage)(nil),
		(*Message_CloseSession)(nil),
		(*Message_ScriptFinished)(nil),
	}
	file_websocket_v1_message_proto_msgTypes[3].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_websocket_v1_message_proto_rawDesc), len(file_websocket_v1_message_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_websocket_v1_message_proto_goTypes,
		DependencyIndexes: file_websocket_v1_message_proto_depIdxs,
		EnumInfos:         file_websocket_v1_message_proto_enumTypes,
		MessageInfos:      file_websocket_v1_message_proto_msgTypes,
	}.Build()
	File_websocket_v1_message_proto = out.File
	file_websocket_v1_message_proto_goTypes = nil
	file_websocket_v1_message_proto_depIdxs = nil
}
</file>

<file path="internal/pb/go/widget/v1/widget.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: widget/v1/widget.proto

package widgetv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Button struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         bool                   `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Disabled      bool                   `protobuf:"varint,3,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Button) Reset() {
	*x = Button{}
	mi := &file_widget_v1_widget_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Button) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Button) ProtoMessage() {}

func (x *Button) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Button.ProtoReflect.Descriptor instead.
func (*Button) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{0}
}

func (x *Button) GetValue() bool {
	if x != nil {
		return x.Value
	}
	return false
}

func (x *Button) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *Button) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type Checkbox struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         bool                   `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	DefaultValue  bool                   `protobuf:"varint,3,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,4,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,5,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Checkbox) Reset() {
	*x = Checkbox{}
	mi := &file_widget_v1_widget_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Checkbox) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Checkbox) ProtoMessage() {}

func (x *Checkbox) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Checkbox.ProtoReflect.Descriptor instead.
func (*Checkbox) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{1}
}

func (x *Checkbox) GetValue() bool {
	if x != nil {
		return x.Value
	}
	return false
}

func (x *Checkbox) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *Checkbox) GetDefaultValue() bool {
	if x != nil {
		return x.DefaultValue
	}
	return false
}

func (x *Checkbox) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *Checkbox) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type CheckboxGroup struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         []int32                `protobuf:"varint,1,rep,packed,name=value,proto3" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Options       []string               `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
	DefaultValue  []int32                `protobuf:"varint,4,rep,packed,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckboxGroup) Reset() {
	*x = CheckboxGroup{}
	mi := &file_widget_v1_widget_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckboxGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckboxGroup) ProtoMessage() {}

func (x *CheckboxGroup) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckboxGroup.ProtoReflect.Descriptor instead.
func (*CheckboxGroup) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{2}
}

func (x *CheckboxGroup) GetValue() []int32 {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *CheckboxGroup) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *CheckboxGroup) GetOptions() []string {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *CheckboxGroup) GetDefaultValue() []int32 {
	if x != nil {
		return x.DefaultValue
	}
	return nil
}

func (x *CheckboxGroup) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *CheckboxGroup) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type ColumnItem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Weight        float64                `protobuf:"fixed64,1,opt,name=weight,proto3" json:"weight,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ColumnItem) Reset() {
	*x = ColumnItem{}
	mi := &file_widget_v1_widget_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ColumnItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ColumnItem) ProtoMessage() {}

func (x *ColumnItem) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ColumnItem.ProtoReflect.Descriptor instead.
func (*ColumnItem) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{3}
}

func (x *ColumnItem) GetWeight() float64 {
	if x != nil {
		return x.Weight
	}
	return 0
}

type Columns struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Columns       int32                  `protobuf:"varint,1,opt,name=columns,proto3" json:"columns,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Columns) Reset() {
	*x = Columns{}
	mi := &file_widget_v1_widget_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Columns) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Columns) ProtoMessage() {}

func (x *Columns) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Columns.ProtoReflect.Descriptor instead.
func (*Columns) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{4}
}

func (x *Columns) GetColumns() int32 {
	if x != nil {
		return x.Columns
	}
	return 0
}

type DateInput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *string                `protobuf:"bytes,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Placeholder   string                 `protobuf:"bytes,3,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *string                `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	Format        string                 `protobuf:"bytes,7,opt,name=format,proto3" json:"format,omitempty"`
	MaxValue      string                 `protobuf:"bytes,8,opt,name=max_value,json=maxValue,proto3" json:"max_value,omitempty"`
	MinValue      string                 `protobuf:"bytes,9,opt,name=min_value,json=minValue,proto3" json:"min_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DateInput) Reset() {
	*x = DateInput{}
	mi := &file_widget_v1_widget_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DateInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DateInput) ProtoMessage() {}

func (x *DateInput) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DateInput.ProtoReflect.Descriptor instead.
func (*DateInput) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{5}
}

func (x *DateInput) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

func (x *DateInput) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *DateInput) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *DateInput) GetDefaultValue() string {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return ""
}

func (x *DateInput) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *DateInput) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *DateInput) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *DateInput) GetMaxValue() string {
	if x != nil {
		return x.MaxValue
	}
	return ""
}

func (x *DateInput) GetMinValue() string {
	if x != nil {
		return x.MinValue
	}
	return ""
}

type DateTimeInput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *string                `protobuf:"bytes,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Placeholder   string                 `protobuf:"bytes,3,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *string                `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	Format        string                 `protobuf:"bytes,7,opt,name=format,proto3" json:"format,omitempty"`
	MaxValue      string                 `protobuf:"bytes,8,opt,name=max_value,json=maxValue,proto3" json:"max_value,omitempty"`
	MinValue      string                 `protobuf:"bytes,9,opt,name=min_value,json=minValue,proto3" json:"min_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DateTimeInput) Reset() {
	*x = DateTimeInput{}
	mi := &file_widget_v1_widget_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DateTimeInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DateTimeInput) ProtoMessage() {}

func (x *DateTimeInput) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DateTimeInput.ProtoReflect.Descriptor instead.
func (*DateTimeInput) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{6}
}

func (x *DateTimeInput) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

func (x *DateTimeInput) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *DateTimeInput) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *DateTimeInput) GetDefaultValue() string {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return ""
}

func (x *DateTimeInput) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *DateTimeInput) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *DateTimeInput) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *DateTimeInput) GetMaxValue() string {
	if x != nil {
		return x.MaxValue
	}
	return ""
}

func (x *DateTimeInput) GetMinValue() string {
	if x != nil {
		return x.MinValue
	}
	return ""
}

type Form struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Value          bool                   `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	ButtonLabel    string                 `protobuf:"bytes,2,opt,name=button_label,json=buttonLabel,proto3" json:"button_label,omitempty"`
	ButtonDisabled bool                   `protobuf:"varint,3,opt,name=button_disabled,json=buttonDisabled,proto3" json:"button_disabled,omitempty"`
	ClearOnSubmit  bool                   `protobuf:"varint,4,opt,name=clear_on_submit,json=clearOnSubmit,proto3" json:"clear_on_submit,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Form) Reset() {
	*x = Form{}
	mi := &file_widget_v1_widget_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Form) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Form) ProtoMessage() {}

func (x *Form) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Form.ProtoReflect.Descriptor instead.
func (*Form) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{7}
}

func (x *Form) GetValue() bool {
	if x != nil {
		return x.Value
	}
	return false
}

func (x *Form) GetButtonLabel() string {
	if x != nil {
		return x.ButtonLabel
	}
	return ""
}

func (x *Form) GetButtonDisabled() bool {
	if x != nil {
		return x.ButtonDisabled
	}
	return false
}

func (x *Form) GetClearOnSubmit() bool {
	if x != nil {
		return x.ClearOnSubmit
	}
	return false
}

type Markdown struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Body          string                 `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Markdown) Reset() {
	*x = Markdown{}
	mi := &file_widget_v1_widget_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Markdown) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Markdown) ProtoMessage() {}

func (x *Markdown) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Markdown.ProtoReflect.Descriptor instead.
func (*Markdown) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{8}
}

func (x *Markdown) GetBody() string {
	if x != nil {
		return x.Body
	}
	return ""
}

type MultiSelect struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         []int32                `protobuf:"varint,1,rep,packed,name=value,proto3" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Options       []string               `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
	Placeholder   string                 `protobuf:"bytes,4,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  []int32                `protobuf:"varint,5,rep,packed,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,6,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,7,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiSelect) Reset() {
	*x = MultiSelect{}
	mi := &file_widget_v1_widget_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiSelect) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiSelect) ProtoMessage() {}

func (x *MultiSelect) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiSelect.ProtoReflect.Descriptor instead.
func (*MultiSelect) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{9}
}

func (x *MultiSelect) GetValue() []int32 {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *MultiSelect) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *MultiSelect) GetOptions() []string {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *MultiSelect) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *MultiSelect) GetDefaultValue() []int32 {
	if x != nil {
		return x.DefaultValue
	}
	return nil
}

func (x *MultiSelect) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *MultiSelect) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type NumberInput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *float64               `protobuf:"fixed64,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Placeholder   string                 `protobuf:"bytes,3,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *float64               `protobuf:"fixed64,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	MaxValue      *float64               `protobuf:"fixed64,7,opt,name=max_value,json=maxValue,proto3,oneof" json:"max_value,omitempty"`
	MinValue      *float64               `protobuf:"fixed64,8,opt,name=min_value,json=minValue,proto3,oneof" json:"min_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NumberInput) Reset() {
	*x = NumberInput{}
	mi := &file_widget_v1_widget_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NumberInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NumberInput) ProtoMessage() {}

func (x *NumberInput) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NumberInput.ProtoReflect.Descriptor instead.
func (*NumberInput) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{10}
}

func (x *NumberInput) GetValue() float64 {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return 0
}

func (x *NumberInput) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *NumberInput) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *NumberInput) GetDefaultValue() float64 {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return 0
}

func (x *NumberInput) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *NumberInput) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *NumberInput) GetMaxValue() float64 {
	if x != nil && x.MaxValue != nil {
		return *x.MaxValue
	}
	return 0
}

func (x *NumberInput) GetMinValue() float64 {
	if x != nil && x.MinValue != nil {
		return *x.MinValue
	}
	return 0
}

type Radio struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *int32                 `protobuf:"varint,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Options       []string               `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
	DefaultValue  *int32                 `protobuf:"varint,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Radio) Reset() {
	*x = Radio{}
	mi := &file_widget_v1_widget_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Radio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Radio) ProtoMessage() {}

func (x *Radio) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Radio.ProtoReflect.Descriptor instead.
func (*Radio) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{11}
}

func (x *Radio) GetValue() int32 {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return 0
}

func (x *Radio) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *Radio) GetOptions() []string {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *Radio) GetDefaultValue() int32 {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return 0
}

func (x *Radio) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *Radio) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type Selectbox struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *int32                 `protobuf:"varint,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Options       []string               `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
	Placeholder   string                 `protobuf:"bytes,4,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *int32                 `protobuf:"varint,5,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,6,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,7,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Selectbox) Reset() {
	*x = Selectbox{}
	mi := &file_widget_v1_widget_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Selectbox) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Selectbox) ProtoMessage() {}

func (x *Selectbox) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Selectbox.ProtoReflect.Descriptor instead.
func (*Selectbox) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{12}
}

func (x *Selectbox) GetValue() int32 {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return 0
}

func (x *Selectbox) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *Selectbox) GetOptions() []string {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *Selectbox) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *Selectbox) GetDefaultValue() int32 {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return 0
}

func (x *Selectbox) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *Selectbox) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type Table struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Data          []byte                 `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Value         *TableValue            `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Header        string                 `protobuf:"bytes,3,opt,name=header,proto3" json:"header,omitempty"`
	Description   string                 `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Height        *int32                 `protobuf:"varint,5,opt,name=height,proto3,oneof" json:"height,omitempty"`
	ColumnOrder   []string               `protobuf:"bytes,6,rep,name=column_order,json=columnOrder,proto3" json:"column_order,omitempty"`
	OnSelect      string                 `protobuf:"bytes,7,opt,name=on_select,json=onSelect,proto3" json:"on_select,omitempty"`
	RowSelection  string                 `protobuf:"bytes,8,opt,name=row_selection,json=rowSelection,proto3" json:"row_selection,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Table) Reset() {
	*x = Table{}
	mi := &file_widget_v1_widget_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Table) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Table) ProtoMessage() {}

func (x *Table) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Table.ProtoReflect.Descriptor instead.
func (*Table) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{13}
}

func (x *Table) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *Table) GetValue() *TableValue {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *Table) GetHeader() string {
	if x != nil {
		return x.Header
	}
	return ""
}

func (x *Table) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Table) GetHeight() int32 {
	if x != nil && x.Height != nil {
		return *x.Height
	}
	return 0
}

func (x *Table) GetColumnOrder() []string {
	if x != nil {
		return x.ColumnOrder
	}
	return nil
}

func (x *Table) GetOnSelect() string {
	if x != nil {
		return x.OnSelect
	}
	return ""
}

func (x *Table) GetRowSelection() string {
	if x != nil {
		return x.RowSelection
	}
	return ""
}

type TableValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Selection     *TableValueSelection   `protobuf:"bytes,1,opt,name=selection,proto3,oneof" json:"selection,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TableValue) Reset() {
	*x = TableValue{}
	mi := &file_widget_v1_widget_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TableValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TableValue) ProtoMessage() {}

func (x *TableValue) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TableValue.ProtoReflect.Descriptor instead.
func (*TableValue) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{14}
}

func (x *TableValue) GetSelection() *TableValueSelection {
	if x != nil {
		return x.Selection
	}
	return nil
}

type TableValueSelection struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Row           int32                  `protobuf:"varint,1,opt,name=row,proto3" json:"row,omitempty"`
	Rows          []int32                `protobuf:"varint,2,rep,packed,name=rows,proto3" json:"rows,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TableValueSelection) Reset() {
	*x = TableValueSelection{}
	mi := &file_widget_v1_widget_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TableValueSelection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TableValueSelection) ProtoMessage() {}

func (x *TableValueSelection) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TableValueSelection.ProtoReflect.Descriptor instead.
func (*TableValueSelection) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{15}
}

func (x *TableValueSelection) GetRow() int32 {
	if x != nil {
		return x.Row
	}
	return 0
}

func (x *TableValueSelection) GetRows() []int32 {
	if x != nil {
		return x.Rows
	}
	return nil
}

type TextArea struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *string                `protobuf:"bytes,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Placeholder   string                 `protobuf:"bytes,3,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *string                `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	MaxLength     *int32                 `protobuf:"varint,7,opt,name=max_length,json=maxLength,proto3,oneof" json:"max_length,omitempty"`
	MinLength     *int32                 `protobuf:"varint,8,opt,name=min_length,json=minLength,proto3,oneof" json:"min_length,omitempty"`
	MaxLines      *int32                 `protobuf:"varint,9,opt,name=max_lines,json=maxLines,proto3,oneof" json:"max_lines,omitempty"`
	MinLines      *int32                 `protobuf:"varint,10,opt,name=min_lines,json=minLines,proto3,oneof" json:"min_lines,omitempty"`
	AutoResize    bool                   `protobuf:"varint,11,opt,name=auto_resize,json=autoResize,proto3" json:"auto_resize,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TextArea) Reset() {
	*x = TextArea{}
	mi := &file_widget_v1_widget_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TextArea) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TextArea) ProtoMessage() {}

func (x *TextArea) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TextArea.ProtoReflect.Descriptor instead.
func (*TextArea) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{16}
}

func (x *TextArea) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

func (x *TextArea) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *TextArea) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *TextArea) GetDefaultValue() string {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return ""
}

func (x *TextArea) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *TextArea) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *TextArea) GetMaxLength() int32 {
	if x != nil && x.MaxLength != nil {
		return *x.MaxLength
	}
	return 0
}

func (x *TextArea) GetMinLength() int32 {
	if x != nil && x.MinLength != nil {
		return *x.MinLength
	}
	return 0
}

func (x *TextArea) GetMaxLines() int32 {
	if x != nil && x.MaxLines != nil {
		return *x.MaxLines
	}
	return 0
}

func (x *TextArea) GetMinLines() int32 {
	if x != nil && x.MinLines != nil {
		return *x.MinLines
	}
	return 0
}

func (x *TextArea) GetAutoResize() bool {
	if x != nil {
		return x.AutoResize
	}
	return false
}

type TextInput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *string                `protobuf:"bytes,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Placeholder   string                 `protobuf:"bytes,3,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *string                `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	MaxLength     *int32                 `protobuf:"varint,7,opt,name=max_length,json=maxLength,proto3,oneof" json:"max_length,omitempty"`
	MinLength     *int32                 `protobuf:"varint,8,opt,name=min_length,json=minLength,proto3,oneof" json:"min_length,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TextInput) Reset() {
	*x = TextInput{}
	mi := &file_widget_v1_widget_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TextInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TextInput) ProtoMessage() {}

func (x *TextInput) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TextInput.ProtoReflect.Descriptor instead.
func (*TextInput) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{17}
}

func (x *TextInput) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

func (x *TextInput) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *TextInput) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *TextInput) GetDefaultValue() string {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return ""
}

func (x *TextInput) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *TextInput) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *TextInput) GetMaxLength() int32 {
	if x != nil && x.MaxLength != nil {
		return *x.MaxLength
	}
	return 0
}

func (x *TextInput) GetMinLength() int32 {
	if x != nil && x.MinLength != nil {
		return *x.MinLength
	}
	return 0
}

type TimeInput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *string                `protobuf:"bytes,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	Label         string                 `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Placeholder   string                 `protobuf:"bytes,3,opt,name=placeholder,proto3" json:"placeholder,omitempty"`
	DefaultValue  *string                `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3,oneof" json:"default_value,omitempty"`
	Required      bool                   `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	Disabled      bool                   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TimeInput) Reset() {
	*x = TimeInput{}
	mi := &file_widget_v1_widget_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeInput) ProtoMessage() {}

func (x *TimeInput) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimeInput.ProtoReflect.Descriptor instead.
func (*TimeInput) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{18}
}

func (x *TimeInput) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

func (x *TimeInput) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *TimeInput) GetPlaceholder() string {
	if x != nil {
		return x.Placeholder
	}
	return ""
}

func (x *TimeInput) GetDefaultValue() string {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return ""
}

func (x *TimeInput) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *TimeInput) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type Widget struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Id    string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to Type:
	//
	//	*Widget_Button
	//	*Widget_Checkbox
	//	*Widget_CheckboxGroup
	//	*Widget_ColumnItem
	//	*Widget_Columns
	//	*Widget_DateInput
	//	*Widget_DateTimeInput
	//	*Widget_Form
	//	*Widget_Markdown
	//	*Widget_MultiSelect
	//	*Widget_NumberInput
	//	*Widget_Radio
	//	*Widget_Selectbox
	//	*Widget_Table
	//	*Widget_TextArea
	//	*Widget_TextInput
	//	*Widget_TimeInput
	Type          isWidget_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Widget) Reset() {
	*x = Widget{}
	mi := &file_widget_v1_widget_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Widget) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Widget) ProtoMessage() {}

func (x *Widget) ProtoReflect() protoreflect.Message {
	mi := &file_widget_v1_widget_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Widget.ProtoReflect.Descriptor instead.
func (*Widget) Descriptor() ([]byte, []int) {
	return file_widget_v1_widget_proto_rawDescGZIP(), []int{19}
}

func (x *Widget) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Widget) GetType() isWidget_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *Widget) GetButton() *Button {
	if x != nil {
		if x, ok := x.Type.(*Widget_Button); ok {
			return x.Button
		}
	}
	return nil
}

func (x *Widget) GetCheckbox() *Checkbox {
	if x != nil {
		if x, ok := x.Type.(*Widget_Checkbox); ok {
			return x.Checkbox
		}
	}
	return nil
}

func (x *Widget) GetCheckboxGroup() *CheckboxGroup {
	if x != nil {
		if x, ok := x.Type.(*Widget_CheckboxGroup); ok {
			return x.CheckboxGroup
		}
	}
	return nil
}

func (x *Widget) GetColumnItem() *ColumnItem {
	if x != nil {
		if x, ok := x.Type.(*Widget_ColumnItem); ok {
			return x.ColumnItem
		}
	}
	return nil
}

func (x *Widget) GetColumns() *Columns {
	if x != nil {
		if x, ok := x.Type.(*Widget_Columns); ok {
			return x.Columns
		}
	}
	return nil
}

func (x *Widget) GetDateInput() *DateInput {
	if x != nil {
		if x, ok := x.Type.(*Widget_DateInput); ok {
			return x.DateInput
		}
	}
	return nil
}

func (x *Widget) GetDateTimeInput() *DateTimeInput {
	if x != nil {
		if x, ok := x.Type.(*Widget_DateTimeInput); ok {
			return x.DateTimeInput
		}
	}
	return nil
}

func (x *Widget) GetForm() *Form {
	if x != nil {
		if x, ok := x.Type.(*Widget_Form); ok {
			return x.Form
		}
	}
	return nil
}

func (x *Widget) GetMarkdown() *Markdown {
	if x != nil {
		if x, ok := x.Type.(*Widget_Markdown); ok {
			return x.Markdown
		}
	}
	return nil
}

func (x *Widget) GetMultiSelect() *MultiSelect {
	if x != nil {
		if x, ok := x.Type.(*Widget_MultiSelect); ok {
			return x.MultiSelect
		}
	}
	return nil
}

func (x *Widget) GetNumberInput() *NumberInput {
	if x != nil {
		if x, ok := x.Type.(*Widget_NumberInput); ok {
			return x.NumberInput
		}
	}
	return nil
}

func (x *Widget) GetRadio() *Radio {
	if x != nil {
		if x, ok := x.Type.(*Widget_Radio); ok {
			return x.Radio
		}
	}
	return nil
}

func (x *Widget) GetSelectbox() *Selectbox {
	if x != nil {
		if x, ok := x.Type.(*Widget_Selectbox); ok {
			return x.Selectbox
		}
	}
	return nil
}

func (x *Widget) GetTable() *Table {
	if x != nil {
		if x, ok := x.Type.(*Widget_Table); ok {
			return x.Table
		}
	}
	return nil
}

func (x *Widget) GetTextArea() *TextArea {
	if x != nil {
		if x, ok := x.Type.(*Widget_TextArea); ok {
			return x.TextArea
		}
	}
	return nil
}

func (x *Widget) GetTextInput() *TextInput {
	if x != nil {
		if x, ok := x.Type.(*Widget_TextInput); ok {
			return x.TextInput
		}
	}
	return nil
}

func (x *Widget) GetTimeInput() *TimeInput {
	if x != nil {
		if x, ok := x.Type.(*Widget_TimeInput); ok {
			return x.TimeInput
		}
	}
	return nil
}

type isWidget_Type interface {
	isWidget_Type()
}

type Widget_Button struct {
	Button *Button `protobuf:"bytes,2,opt,name=button,proto3,oneof"`
}

type Widget_Checkbox struct {
	Checkbox *Checkbox `protobuf:"bytes,3,opt,name=checkbox,proto3,oneof"`
}

type Widget_CheckboxGroup struct {
	CheckboxGroup *CheckboxGroup `protobuf:"bytes,4,opt,name=checkbox_group,json=checkboxGroup,proto3,oneof"`
}

type Widget_ColumnItem struct {
	ColumnItem *ColumnItem `protobuf:"bytes,5,opt,name=column_item,json=columnItem,proto3,oneof"`
}

type Widget_Columns struct {
	Columns *Columns `protobuf:"bytes,6,opt,name=columns,proto3,oneof"`
}

type Widget_DateInput struct {
	DateInput *DateInput `protobuf:"bytes,7,opt,name=date_input,json=dateInput,proto3,oneof"`
}

type Widget_DateTimeInput struct {
	DateTimeInput *DateTimeInput `protobuf:"bytes,8,opt,name=date_time_input,json=dateTimeInput,proto3,oneof"`
}

type Widget_Form struct {
	Form *Form `protobuf:"bytes,9,opt,name=form,proto3,oneof"`
}

type Widget_Markdown struct {
	Markdown *Markdown `protobuf:"bytes,10,opt,name=markdown,proto3,oneof"`
}

type Widget_MultiSelect struct {
	MultiSelect *MultiSelect `protobuf:"bytes,11,opt,name=multi_select,json=multiSelect,proto3,oneof"`
}

type Widget_NumberInput struct {
	NumberInput *NumberInput `protobuf:"bytes,12,opt,name=number_input,json=numberInput,proto3,oneof"`
}

type Widget_Radio struct {
	Radio *Radio `protobuf:"bytes,13,opt,name=radio,proto3,oneof"`
}

type Widget_Selectbox struct {
	Selectbox *Selectbox `protobuf:"bytes,14,opt,name=selectbox,proto3,oneof"`
}

type Widget_Table struct {
	Table *Table `protobuf:"bytes,15,opt,name=table,proto3,oneof"`
}

type Widget_TextArea struct {
	TextArea *TextArea `protobuf:"bytes,16,opt,name=text_area,json=textArea,proto3,oneof"`
}

type Widget_TextInput struct {
	TextInput *TextInput `protobuf:"bytes,17,opt,name=text_input,json=textInput,proto3,oneof"`
}

type Widget_TimeInput struct {
	TimeInput *TimeInput `protobuf:"bytes,18,opt,name=time_input,json=timeInput,proto3,oneof"`
}

func (*Widget_Button) isWidget_Type() {}

func (*Widget_Checkbox) isWidget_Type() {}

func (*Widget_CheckboxGroup) isWidget_Type() {}

func (*Widget_ColumnItem) isWidget_Type() {}

func (*Widget_Columns) isWidget_Type() {}

func (*Widget_DateInput) isWidget_Type() {}

func (*Widget_DateTimeInput) isWidget_Type() {}

func (*Widget_Form) isWidget_Type() {}

func (*Widget_Markdown) isWidget_Type() {}

func (*Widget_MultiSelect) isWidget_Type() {}

func (*Widget_NumberInput) isWidget_Type() {}

func (*Widget_Radio) isWidget_Type() {}

func (*Widget_Selectbox) isWidget_Type() {}

func (*Widget_Table) isWidget_Type() {}

func (*Widget_TextArea) isWidget_Type() {}

func (*Widget_TextInput) isWidget_Type() {}

func (*Widget_TimeInput) isWidget_Type() {}

var File_widget_v1_widget_proto protoreflect.FileDescriptor

const file_widget_v1_widget_proto_rawDesc = "" +
	"\n" +
	"\x16widget/v1/widget.proto\x12\twidget.v1\"P\n" +
	"\x06Button\x12\x14\n" +
	"\x05value\x18\x01 \x01(\bR\x05value\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12\x1a\n" +
	"\bdisabled\x18\x03 \x01(\bR\bdisabled\"\x93\x01\n" +
	"\bCheckbox\x12\x14\n" +
	"\x05value\x18\x01 \x01(\bR\x05value\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12#\n" +
	"\rdefault_value\x18\x03 \x01(\bR\fdefaultValue\x12\x1a\n" +
	"\brequired\x18\x04 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x05 \x01(\bR\bdisabled\"\xb2\x01\n" +
	"\rCheckboxGroup\x12\x14\n" +
	"\x05value\x18\x01 \x03(\x05R\x05value\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12\x18\n" +
	"\aoptions\x18\x03 \x03(\tR\aoptions\x12#\n" +
	"\rdefault_value\x18\x04 \x03(\x05R\fdefaultValue\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabled\"$\n" +
	"\n" +
	"ColumnItem\x12\x16\n" +
	"\x06weight\x18\x01 \x01(\x01R\x06weight\"#\n" +
	"\aColumns\x12\x18\n" +
	"\acolumns\x18\x01 \x01(\x05R\acolumns\"\xae\x02\n" +
	"\tDateInput\x12\x19\n" +
	"\x05value\x18\x01 \x01(\tH\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12 \n" +
	"\vplaceholder\x18\x03 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\tH\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabled\x12\x16\n" +
	"\x06format\x18\a \x01(\tR\x06format\x12\x1b\n" +
	"\tmax_value\x18\b \x01(\tR\bmaxValue\x12\x1b\n" +
	"\tmin_value\x18\t \x01(\tR\bminValueB\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_value\"\xb2\x02\n" +
	"\rDateTimeInput\x12\x19\n" +
	"\x05value\x18\x01 \x01(\tH\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12 \n" +
	"\vplaceholder\x18\x03 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\tH\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabled\x12\x16\n" +
	"\x06format\x18\a \x01(\tR\x06format\x12\x1b\n" +
	"\tmax_value\x18\b \x01(\tR\bmaxValue\x12\x1b\n" +
	"\tmin_value\x18\t \x01(\tR\bminValueB\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_value\"\x90\x01\n" +
	"\x04Form\x12\x14\n" +
	"\x05value\x18\x01 \x01(\bR\x05value\x12!\n" +
	"\fbutton_label\x18\x02 \x01(\tR\vbuttonLabel\x12'\n" +
	"\x0fbutton_disabled\x18\x03 \x01(\bR\x0ebuttonDisabled\x12&\n" +
	"\x0fclear_on_submit\x18\x04 \x01(\bR\rclearOnSubmit\"\x1e\n" +
	"\bMarkdown\x12\x12\n" +
	"\x04body\x18\x01 \x01(\tR\x04body\"\xd2\x01\n" +
	"\vMultiSelect\x12\x14\n" +
	"\x05value\x18\x01 \x03(\x05R\x05value\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12\x18\n" +
	"\aoptions\x18\x03 \x03(\tR\aoptions\x12 \n" +
	"\vplaceholder\x18\x04 \x01(\tR\vplaceholder\x12#\n" +
	"\rdefault_value\x18\x05 \x03(\x05R\fdefaultValue\x12\x1a\n" +
	"\brequired\x18\x06 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\a \x01(\bR\bdisabled\"\xbe\x02\n" +
	"\vNumberInput\x12\x19\n" +
	"\x05value\x18\x01 \x01(\x01H\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12 \n" +
	"\vplaceholder\x18\x03 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\x01H\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabled\x12 \n" +
	"\tmax_value\x18\a \x01(\x01H\x02R\bmaxValue\x88\x01\x01\x12 \n" +
	"\tmin_value\x18\b \x01(\x01H\x03R\bminValue\x88\x01\x01B\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_valueB\f\n" +
	"\n" +
	"_max_valueB\f\n" +
	"\n" +
	"_min_value\"\xd0\x01\n" +
	"\x05Radio\x12\x19\n" +
	"\x05value\x18\x01 \x01(\x05H\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12\x18\n" +
	"\aoptions\x18\x03 \x03(\tR\aoptions\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\x05H\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabledB\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_value\"\xf6\x01\n" +
	"\tSelectbox\x12\x19\n" +
	"\x05value\x18\x01 \x01(\x05H\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12\x18\n" +
	"\aoptions\x18\x03 \x03(\tR\aoptions\x12 \n" +
	"\vplaceholder\x18\x04 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x05 \x01(\x05H\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x06 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\a \x01(\bR\bdisabledB\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_value\"\x8f\x02\n" +
	"\x05Table\x12\x12\n" +
	"\x04data\x18\x01 \x01(\fR\x04data\x12+\n" +
	"\x05value\x18\x02 \x01(\v2\x15.widget.v1.TableValueR\x05value\x12\x16\n" +
	"\x06header\x18\x03 \x01(\tR\x06header\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription\x12\x1b\n" +
	"\x06height\x18\x05 \x01(\x05H\x00R\x06height\x88\x01\x01\x12!\n" +
	"\fcolumn_order\x18\x06 \x03(\tR\vcolumnOrder\x12\x1b\n" +
	"\ton_select\x18\a \x01(\tR\bonSelect\x12#\n" +
	"\rrow_selection\x18\b \x01(\tR\frowSelectionB\t\n" +
	"\a_height\"]\n" +
	"\n" +
	"TableValue\x12A\n" +
	"\tselection\x18\x01 \x01(\v2\x1e.widget.v1.TableValueSelectionH\x00R\tselection\x88\x01\x01B\f\n" +
	"\n" +
	"_selection\";\n" +
	"\x13TableValueSelection\x12\x10\n" +
	"\x03row\x18\x01 \x01(\x05R\x03row\x12\x12\n" +
	"\x04rows\x18\x02 \x03(\x05R\x04rows\"\xc2\x03\n" +
	"\bTextArea\x12\x19\n" +
	"\x05value\x18\x01 \x01(\tH\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12 \n" +
	"\vplaceholder\x18\x03 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\tH\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabled\x12\"\n" +
	"\n" +
	"max_length\x18\a \x01(\x05H\x02R\tmaxLength\x88\x01\x01\x12\"\n" +
	"\n" +
	"min_length\x18\b \x01(\x05H\x03R\tminLength\x88\x01\x01\x12 \n" +
	"\tmax_lines\x18\t \x01(\x05H\x04R\bmaxLines\x88\x01\x01\x12 \n" +
	"\tmin_lines\x18\n" +
	" \x01(\x05H\x05R\bminLines\x88\x01\x01\x12\x1f\n" +
	"\vauto_resize\x18\v \x01(\bR\n" +
	"autoResizeB\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_valueB\r\n" +
	"\v_max_lengthB\r\n" +
	"\v_min_lengthB\f\n" +
	"\n" +
	"_max_linesB\f\n" +
	"\n" +
	"_min_lines\"\xc2\x02\n" +
	"\tTextInput\x12\x19\n" +
	"\x05value\x18\x01 \x01(\tH\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12 \n" +
	"\vplaceholder\x18\x03 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\tH\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabled\x12\"\n" +
	"\n" +
	"max_length\x18\a \x01(\x05H\x02R\tmaxLength\x88\x01\x01\x12\"\n" +
	"\n" +
	"min_length\x18\b \x01(\x05H\x03R\tminLength\x88\x01\x01B\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_valueB\r\n" +
	"\v_max_lengthB\r\n" +
	"\v_min_length\"\xdc\x01\n" +
	"\tTimeInput\x12\x19\n" +
	"\x05value\x18\x01 \x01(\tH\x00R\x05value\x88\x01\x01\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12 \n" +
	"\vplaceholder\x18\x03 \x01(\tR\vplaceholder\x12(\n" +
	"\rdefault_value\x18\x04 \x01(\tH\x01R\fdefaultValue\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\x05 \x01(\bR\brequired\x12\x1a\n" +
	"\bdisabled\x18\x06 \x01(\bR\bdisabledB\b\n" +
	"\x06_valueB\x10\n" +
	"\x0e_default_value\"\xa8\a\n" +
	"\x06Widget\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12+\n" +
	"\x06button\x18\x02 \x01(\v2\x11.widget.v1.ButtonH\x00R\x06button\x121\n" +
	"\bcheckbox\x18\x03 \x01(\v2\x13.widget.v1.CheckboxH\x00R\bcheckbox\x12A\n" +
	"\x0echeckbox_group\x18\x04 \x01(\v2\x18.widget.v1.CheckboxGroupH\x00R\rcheckboxGroup\x128\n" +
	"\vcolumn_item\x18\x05 \x01(\v2\x15.widget.v1.ColumnItemH\x00R\n" +
	"columnItem\x12.\n" +
	"\acolumns\x18\x06 \x01(\v2\x12.widget.v1.ColumnsH\x00R\acolumns\x125\n" +
	"\n" +
	"date_input\x18\a \x01(\v2\x14.widget.v1.DateInputH\x00R\tdateInput\x12B\n" +
	"\x0fdate_time_input\x18\b \x01(\v2\x18.widget.v1.DateTimeInputH\x00R\rdateTimeInput\x12%\n" +
	"\x04form\x18\t \x01(\v2\x0f.widget.v1.FormH\x00R\x04form\x121\n" +
	"\bmarkdown\x18\n" +
	" \x01(\v2\x13.widget.v1.MarkdownH\x00R\bmarkdown\x12;\n" +
	"\fmulti_select\x18\v \x01(\v2\x16.widget.v1.MultiSelectH\x00R\vmultiSelect\x12;\n" +
	"\fnumber_input\x18\f \x01(\v2\x16.widget.v1.NumberInputH\x00R\vnumberInput\x12(\n" +
	"\x05radio\x18\r \x01(\v2\x10.widget.v1.RadioH\x00R\x05radio\x124\n" +
	"\tselectbox\x18\x0e \x01(\v2\x14.widget.v1.SelectboxH\x00R\tselectbox\x12(\n" +
	"\x05table\x18\x0f \x01(\v2\x10.widget.v1.TableH\x00R\x05table\x122\n" +
	"\ttext_area\x18\x10 \x01(\v2\x13.widget.v1.TextAreaH\x00R\btextArea\x125\n" +
	"\n" +
	"text_input\x18\x11 \x01(\v2\x14.widget.v1.TextInputH\x00R\ttextInput\x125\n" +
	"\n" +
	"time_input\x18\x12 \x01(\v2\x14.widget.v1.TimeInputH\x00R\ttimeInputB\x06\n" +
	"\x04typeB\xb0\x01\n" +
	"\rcom.widget.v1B\vWidgetProtoP\x01ZMgithub.com/trysourcetool/sourcetool/backend/internal/pb/go/widget/v1;widgetv1\xa2\x02\x03WXX\xaa\x02\tWidget.V1\xca\x02\tWidget\\V1\xe2\x02\x15Widget\\V1\\GPBMetadata\xea\x02\n" +
	"Widget::V1b\x06proto3"

var (
	file_widget_v1_widget_proto_rawDescOnce sync.Once
	file_widget_v1_widget_proto_rawDescData []byte
)

func file_widget_v1_widget_proto_rawDescGZIP() []byte {
	file_widget_v1_widget_proto_rawDescOnce.Do(func() {
		file_widget_v1_widget_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_widget_v1_widget_proto_rawDesc), len(file_widget_v1_widget_proto_rawDesc)))
	})
	return file_widget_v1_widget_proto_rawDescData
}

var file_widget_v1_widget_proto_msgTypes = make([]protoimpl.MessageInfo, 20)
var file_widget_v1_widget_proto_goTypes = []any{
	(*Button)(nil),              // 0: widget.v1.Button
	(*Checkbox)(nil),            // 1: widget.v1.Checkbox
	(*CheckboxGroup)(nil),       // 2: widget.v1.CheckboxGroup
	(*ColumnItem)(nil),          // 3: widget.v1.ColumnItem
	(*Columns)(nil),             // 4: widget.v1.Columns
	(*DateInput)(nil),           // 5: widget.v1.DateInput
	(*DateTimeInput)(nil),       // 6: widget.v1.DateTimeInput
	(*Form)(nil),                // 7: widget.v1.Form
	(*Markdown)(nil),            // 8: widget.v1.Markdown
	(*MultiSelect)(nil),         // 9: widget.v1.MultiSelect
	(*NumberInput)(nil),         // 10: widget.v1.NumberInput
	(*Radio)(nil),               // 11: widget.v1.Radio
	(*Selectbox)(nil),           // 12: widget.v1.Selectbox
	(*Table)(nil),               // 13: widget.v1.Table
	(*TableValue)(nil),          // 14: widget.v1.TableValue
	(*TableValueSelection)(nil), // 15: widget.v1.TableValueSelection
	(*TextArea)(nil),            // 16: widget.v1.TextArea
	(*TextInput)(nil),           // 17: widget.v1.TextInput
	(*TimeInput)(nil),           // 18: widget.v1.TimeInput
	(*Widget)(nil),              // 19: widget.v1.Widget
}
var file_widget_v1_widget_proto_depIdxs = []int32{
	14, // 0: widget.v1.Table.value:type_name -> widget.v1.TableValue
	15, // 1: widget.v1.TableValue.selection:type_name -> widget.v1.TableValueSelection
	0,  // 2: widget.v1.Widget.button:type_name -> widget.v1.Button
	1,  // 3: widget.v1.Widget.checkbox:type_name -> widget.v1.Checkbox
	2,  // 4: widget.v1.Widget.checkbox_group:type_name -> widget.v1.CheckboxGroup
	3,  // 5: widget.v1.Widget.column_item:type_name -> widget.v1.ColumnItem
	4,  // 6: widget.v1.Widget.columns:type_name -> widget.v1.Columns
	5,  // 7: widget.v1.Widget.date_input:type_name -> widget.v1.DateInput
	6,  // 8: widget.v1.Widget.date_time_input:type_name -> widget.v1.DateTimeInput
	7,  // 9: widget.v1.Widget.form:type_name -> widget.v1.Form
	8,  // 10: widget.v1.Widget.markdown:type_name -> widget.v1.Markdown
	9,  // 11: widget.v1.Widget.multi_select:type_name -> widget.v1.MultiSelect
	10, // 12: widget.v1.Widget.number_input:type_name -> widget.v1.NumberInput
	11, // 13: widget.v1.Widget.radio:type_name -> widget.v1.Radio
	12, // 14: widget.v1.Widget.selectbox:type_name -> widget.v1.Selectbox
	13, // 15: widget.v1.Widget.table:type_name -> widget.v1.Table
	16, // 16: widget.v1.Widget.text_area:type_name -> widget.v1.TextArea
	17, // 17: widget.v1.Widget.text_input:type_name -> widget.v1.TextInput
	18, // 18: widget.v1.Widget.time_input:type_name -> widget.v1.TimeInput
	19, // [19:19] is the sub-list for method output_type
	19, // [19:19] is the sub-list for method input_type
	19, // [19:19] is the sub-list for extension type_name
	19, // [19:19] is the sub-list for extension extendee
	0,  // [0:19] is the sub-list for field type_name
}

func init() { file_widget_v1_widget_proto_init() }
func file_widget_v1_widget_proto_init() {
	if File_widget_v1_widget_proto != nil {
		return
	}
	file_widget_v1_widget_proto_msgTypes[5].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[6].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[10].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[11].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[12].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[13].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[14].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[16].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[17].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[18].OneofWrappers = []any{}
	file_widget_v1_widget_proto_msgTypes[19].OneofWrappers = []any{
		(*Widget_Button)(nil),
		(*Widget_Checkbox)(nil),
		(*Widget_CheckboxGroup)(nil),
		(*Widget_ColumnItem)(nil),
		(*Widget_Columns)(nil),
		(*Widget_DateInput)(nil),
		(*Widget_DateTimeInput)(nil),
		(*Widget_Form)(nil),
		(*Widget_Markdown)(nil),
		(*Widget_MultiSelect)(nil),
		(*Widget_NumberInput)(nil),
		(*Widget_Radio)(nil),
		(*Widget_Selectbox)(nil),
		(*Widget_Table)(nil),
		(*Widget_TextArea)(nil),
		(*Widget_TextInput)(nil),
		(*Widget_TimeInput)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_widget_v1_widget_proto_rawDesc), len(file_widget_v1_widget_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   20,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_widget_v1_widget_proto_goTypes,
		DependencyIndexes: file_widget_v1_widget_proto_depIdxs,
		MessageInfos:      file_widget_v1_widget_proto_msgTypes,
	}.Build()
	File_widget_v1_widget_proto = out.File
	file_widget_v1_widget_proto_goTypes = nil
	file_widget_v1_widget_proto_depIdxs = nil
}
</file>

<file path="internal/transport/http/v1/handlers/apikey.go">
package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/go-chi/chi/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/app/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/mapper"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type APIKeyHandler struct {
	service apikey.Service
}

func NewAPIKeyHandler(service apikey.Service) *APIKeyHandler {
	return &APIKeyHandler{service}
}

// Get godoc
// @ID get-apikey
// @Accept json
// @Produce json
// @Tags apiKeys
// @Param apiKeyID path string true "API Key ID"
// @Success 200 {object} responses.GetAPIKeyResponse
// @Failure default {object} errdefs.Error
// @Router /apiKeys/{apiKeyID} [get].
func (h *APIKeyHandler) Get(w http.ResponseWriter, r *http.Request) {
	req := requests.GetAPIKeyRequest{
		APIKeyID: chi.URLParam(r, "apiKeyID"),
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Get(r.Context(), mapper.GetAPIKeyRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.GetAPIKeyOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// List godoc
// @ID list-apikeys
// @Accept json
// @Produce json
// @Tags apiKeys
// @Success 200 {object} responses.ListAPIKeysResponse
// @Failure default {object} errdefs.Error
// @Router /apiKeys [get].
func (h *APIKeyHandler) List(w http.ResponseWriter, r *http.Request) {
	out, err := h.service.List(r.Context())
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.ListAPIKeysOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// Create godoc
// @ID create-apikey
// @Accept json
// @Produce json
// @Tags apiKeys
// @Param Body body requests.CreateAPIKeyRequest true "API key creation data including name and expiration"
// @Success 200 {object} responses.CreateAPIKeyResponse
// @Failure 400 {object} errdefs.Error "Invalid request parameters"
// @Failure 403 {object} errdefs.Error "Insufficient permissions"
// @Failure 500 {object} errdefs.Error "Internal server error"
// @Router /apiKeys [post].
func (h *APIKeyHandler) Create(w http.ResponseWriter, r *http.Request) {
	var req requests.CreateAPIKeyRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Create(r.Context(), mapper.CreateAPIKeyRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.CreateAPIKeyOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// Update godoc
// @ID update-apikey
// @Accept json
// @Produce json
// @Tags apiKeys
// @Param Body body requests.UpdateAPIKeyRequest true "API key update data including name and status"
// @Param apiKeyID path string true "API Key ID to update"
// @Success 200 {object} responses.UpdateAPIKeyResponse
// @Failure 400 {object} errdefs.Error "Invalid request parameters"
// @Failure 403 {object} errdefs.Error "Insufficient permissions"
// @Failure 404 {object} errdefs.Error "API key not found"
// @Failure 500 {object} errdefs.Error "Internal server error"
// @Router /apiKeys/{apiKeyID} [put].
func (h *APIKeyHandler) Update(w http.ResponseWriter, r *http.Request) {
	req := requests.UpdateAPIKeyRequest{
		APIKeyID: chi.URLParam(r, "apiKeyID"),
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Update(r.Context(), mapper.UpdateAPIKeyRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.UpdateAPIKeyOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// Delete godoc
// @ID delete-apikey
// @Accept json
// @Produce json
// @Tags apiKeys
// @Param apiKeyID path string true "API Key ID"
// @Success 200 {object} responses.DeleteAPIKeyResponse
// @Failure default {object} errdefs.Error
// @Router /apiKeys/{apiKeyID} [delete].
func (h *APIKeyHandler) Delete(w http.ResponseWriter, r *http.Request) {
	req := requests.DeleteAPIKeyRequest{
		APIKeyID: chi.URLParam(r, "apiKeyID"),
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Delete(r.Context(), mapper.DeleteAPIKeyRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.DeleteAPIKeyOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}
</file>

<file path="internal/transport/http/v1/handlers/auth.go">
package handlers

import (
	"encoding/json"
	"errors"
	"net/http"

	"github.com/trysourcetool/sourcetool/backend/config"
	authSvc "github.com/trysourcetool/sourcetool/backend/internal/app/auth"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/auth"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/mapper"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/responses"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type AuthHandler struct {
	service      authSvc.Service
	cookieConfig *CookieConfig
}

func NewAuthHandler(service authSvc.Service) *AuthHandler {
	return &AuthHandler{
		service:      service,
		cookieConfig: NewCookieConfig(),
	}
}

// RequestMagicLink godoc
// @ID request-magic-link
// @Accept json
// @Produce json
// @Tags auth
// @Param Body body requests.RequestMagicLinkRequest true "Email address for magic link"
// @Success 200 {object} responses.RequestMagicLinkResponse
// @Failure 400 {object} errdefs.Error "Invalid email format"
// @Failure 404 {object} errdefs.Error "User not found"
// @Failure 500 {object} errdefs.Error "Internal server error"
// @Router /auth/magic/request [post].
func (h *AuthHandler) RequestMagicLink(w http.ResponseWriter, r *http.Request) {
	var req requests.RequestMagicLinkRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, errdefs.ErrInvalidArgument(err))
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	res, err := h.service.RequestMagicLink(r.Context(), mapper.RequestMagicLinkRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.RequestMagicLinkOutputToResponse(res)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// AuthenticateWithMagicLink godoc
// @ID authenticate-with-magic-link
// @Accept json
// @Produce json
// @Tags auth
// @Param Body body requests.AuthenticateWithMagicLinkRequest true " "
// @Success 200 {object} responses.AuthenticateWithMagicLinkResponse
// @Failure default {object} errdefs.Error
// @Router /auth/magic/authenticate [post].
func (h *AuthHandler) AuthenticateWithMagicLink(w http.ResponseWriter, r *http.Request) {
	var req requests.AuthenticateWithMagicLinkRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.AuthenticateWithMagicLink(r.Context(), mapper.AuthenticateWithMagicLinkRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if !out.HasOrganization {
		h.cookieConfig.SetTmpAuthCookie(w, out.Token, out.XSRFToken, config.Config.AuthDomain())
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.AuthenticateWithMagicLinkOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// RegisterWithMagicLink godoc
// @ID register-with-magic-link
// @Accept json
// @Produce json
// @Tags auth
// @Param Body body requests.RegisterWithMagicLinkRequest true "Registration data with magic link token"
// @Success 200 {object} responses.RegisterWithMagicLinkResponse
// @Failure 400 {object} errdefs.Error "Invalid request parameters"
// @Failure 401 {object} errdefs.Error "Invalid or expired magic link token"
// @Failure 500 {object} errdefs.Error "Internal server error"
// @Router /auth/magic/register [post].
func (h *AuthHandler) RegisterWithMagicLink(w http.ResponseWriter, r *http.Request) {
	var req requests.RegisterWithMagicLinkRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, errdefs.ErrInvalidArgument(err))
		return
	}

	out, err := h.service.RegisterWithMagicLink(r.Context(), mapper.RegisterWithMagicLinkRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if config.Config.IsCloudEdition {
		h.cookieConfig.SetTmpAuthCookie(w, out.Token, out.XSRFToken, config.Config.AuthDomain())
	} else {
		h.cookieConfig.SetAuthCookie(w, out.Token, out.RefreshToken, out.XSRFToken,
			int(auth.TokenExpiration().Seconds()),
			int(auth.RefreshTokenExpiration.Seconds()),
			int(auth.XSRFTokenExpiration.Seconds()),
			config.Config.BaseDomain)
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.RegisterWithMagicLinkOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// RequestInvitationMagicLink godoc
// @ID request-invitation-magic-link
// @Accept json
// @Produce json
// @Tags auth
// @Success 200 {object} responses.RequestInvitationMagicLinkResponse
// @Failure default {object} errdefs.Error
// @Router /auth/invitations/magic/request [post].
func (h *AuthHandler) RequestInvitationMagicLink(w http.ResponseWriter, r *http.Request) {
	var req requests.RequestInvitationMagicLinkRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.RequestInvitationMagicLink(r.Context(), mapper.RequestInvitationMagicLinkRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.RequestInvitationMagicLinkOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// AuthenticateWithInvitationMagicLink godoc
// @ID authenticate-with-invitation-magic-link
// @Accept json
// @Produce json
// @Tags auth
// @Param Body body requests.AuthenticateWithInvitationMagicLinkRequest true " "
// @Success 200 {object} responses.AuthenticateWithInvitationMagicLinkResponse
// @Failure default {object} errdefs.Error
// @Router /auth/invitations/magic/authenticate [post].
func (h *AuthHandler) AuthenticateWithInvitationMagicLink(w http.ResponseWriter, r *http.Request) {
	var req requests.AuthenticateWithInvitationMagicLinkRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.AuthenticateWithInvitationMagicLink(r.Context(), mapper.AuthenticateWithInvitationMagicLinkRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.AuthenticateWithInvitationMagicLinkOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// RegisterWithInvitationMagicLink godoc
// @ID register-with-invitation-magic-link
// @Accept json
// @Produce json
// @Tags auth
// @Param Body body requests.RegisterWithInvitationMagicLinkRequest true " "
// @Success 200 {object} responses.RegisterWithInvitationMagicLinkResponse
// @Failure default {object} errdefs.Error
// @Router /auth/invitations/magic/register [post].
func (h *AuthHandler) RegisterWithInvitationMagicLink(w http.ResponseWriter, r *http.Request) {
	var req requests.RegisterWithInvitationMagicLinkRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.RegisterWithInvitationMagicLink(r.Context(), mapper.RegisterWithInvitationMagicLinkRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	h.cookieConfig.SetAuthCookie(w, out.Token, out.RefreshToken, out.XSRFToken,
		int(auth.TokenExpiration().Seconds()),
		int(auth.RefreshTokenExpiration.Seconds()),
		int(auth.XSRFTokenExpiration.Seconds()),
		out.Domain)

	if err := internal.WriteJSON(w, http.StatusOK, mapper.RegisterWithInvitationMagicLinkOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// RequestGoogleAuthLink godoc
// @ID request-google-auth-link
// @Accept json
// @Produce json
// @Tags auth
// @Success 200 {object} responses.RequestGoogleAuthLinkResponse
// @Failure default {object} errdefs.Error
// @Router /auth/google/request [post].
func (h *AuthHandler) RequestGoogleAuthLink(w http.ResponseWriter, r *http.Request) {
	out, err := h.service.RequestGoogleAuthLink(r.Context())
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.RequestGoogleAuthLinkOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// AuthenticateWithGoogle godoc
// @ID authenticate-with-google
// @Accept json
// @Produce json
// @Tags auth
// @Success 200 {object} responses.AuthenticateWithGoogleResponse
// @Failure default {object} errdefs.Error
// @Router /auth/google/authenticate [post].
func (h *AuthHandler) AuthenticateWithGoogle(w http.ResponseWriter, r *http.Request) {
	var req requests.AuthenticateWithGoogleRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, errdefs.ErrInvalidArgument(err))
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.AuthenticateWithGoogle(r.Context(), mapper.AuthenticateWithGoogleRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if !out.HasOrganization && out.Flow != "invitation" {
		h.cookieConfig.SetTmpAuthCookie(w, out.Token, out.XSRFToken, config.Config.AuthDomain())
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.AuthenticateWithGoogleOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// RegisterWithGoogle godoc
// @ID register-with-google
// @Accept json
// @Produce json
// @Tags auth
// @Success 200 {object} responses.RegisterWithGoogleResponse
// @Failure default {object} errdefs.Error
// @Router /auth/google/register [post].
func (h *AuthHandler) RegisterWithGoogle(w http.ResponseWriter, r *http.Request) {
	var req requests.RegisterWithGoogleRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, errdefs.ErrInvalidArgument(err))
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.RegisterWithGoogle(r.Context(), mapper.RegisterWithGoogleRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	h.cookieConfig.SetTmpAuthCookie(w, out.Token, out.XSRFToken, config.Config.AuthDomain())

	if err := internal.WriteJSON(w, http.StatusOK, mapper.RegisterWithGoogleOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// RequestInvitationGoogleAuthLink godoc
// @ID request-invitation-google-auth-link
// @Accept json
// @Produce json
// @Tags auth
// @Success 200 {object} responses.RequestInvitationGoogleAuthLinkResponse
// @Failure default {object} errdefs.Error
// @Router /auth/invitations/google/request [post].
func (h *AuthHandler) RequestInvitationGoogleAuthLink(w http.ResponseWriter, r *http.Request) {
	var req requests.RequestInvitationGoogleAuthLinkRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, errdefs.ErrInvalidArgument(err))
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.RequestInvitationGoogleAuthLink(r.Context(), mapper.RequestInvitationGoogleAuthLinkRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.RequestInvitationGoogleAuthLinkOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// RefreshToken godoc
// @ID refresh-token
// @Accept json
// @Produce json
// @Tags auth
// @Success 200 {object} responses.RefreshTokenResponse
// @Failure default {object} errdefs.Error
// @Router /auth/refresh [post].
func (h *AuthHandler) RefreshToken(w http.ResponseWriter, r *http.Request) {
	xsrfTokenHeader := r.Header.Get("X-XSRF-TOKEN")
	if xsrfTokenHeader == "" {
		internal.WriteErrJSON(r.Context(), w, errdefs.ErrUnauthenticated(errors.New("failed to get XSRF token")))
		return
	}

	xsrfTokenCookie, err := r.Cookie("xsrf_token_same_site")
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, errdefs.ErrUnauthenticated(err))
		return
	}

	refreshTokenCookie, err := r.Cookie("refresh_token")
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, errdefs.ErrUnauthenticated(err))
		return
	}

	req := requests.RefreshTokenRequest{
		RefreshToken:    refreshTokenCookie.Value,
		XSRFTokenHeader: xsrfTokenHeader,
		XSRFTokenCookie: xsrfTokenCookie.Value,
	}
	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.RefreshToken(r.Context(), mapper.RefreshTokenRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	h.cookieConfig.SetAuthCookie(w, out.Token, out.RefreshToken, out.XSRFToken,
		int(auth.TokenExpiration().Seconds()),
		int(auth.RefreshTokenExpiration.Seconds()),
		int(auth.XSRFTokenExpiration.Seconds()),
		out.Domain)

	if err := internal.WriteJSON(w, http.StatusOK, mapper.RefreshTokenOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// SaveAuth godoc
// @ID save-auth
// @Accept json
// @Produce json
// @Tags auth
// @Param Body body requests.SaveAuthRequest true " "
// @Success 200 {object} responses.SaveAuthResponse
// @Failure default {object} errdefs.Error
// @Router /auth/save [post].
func (h *AuthHandler) Save(w http.ResponseWriter, r *http.Request) {
	var req requests.SaveAuthRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Save(r.Context(), mapper.SaveAuthRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	h.cookieConfig.SetAuthCookie(w, out.Token, out.RefreshToken, out.XSRFToken,
		int(auth.TokenExpiration().Seconds()),
		int(auth.RefreshTokenExpiration.Seconds()),
		int(auth.XSRFTokenExpiration.Seconds()),
		out.Domain)

	if err := internal.WriteJSON(w, http.StatusOK, mapper.SaveAuthOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// ObtainAuthToken godoc
// @ID obtain-auth-token
// @Accept json
// @Produce json
// @Tags auth
// @Success 200 {object} responses.ObtainAuthTokenResponse
// @Failure default {object} errdefs.Error
// @Router /auth/token/obtain [post].
func (h *AuthHandler) ObtainAuthToken(w http.ResponseWriter, r *http.Request) {
	out, err := h.service.ObtainAuthToken(r.Context())
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	h.cookieConfig.DeleteTmpAuthCookie(w, r)

	if err := internal.WriteJSON(w, http.StatusOK, mapper.ObtainAuthTokenOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// Logout godoc
// @ID logout
// @Accept json
// @Produce json
// @Tags auth
// @Success 200 {object} responses.StatusResponse
// @Failure default {object} errdefs.Error
// @Router /auth/logout [post].
func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {
	out, err := h.service.Logout(r.Context())
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	h.cookieConfig.DeleteAuthCookie(w, r, out.Domain)

	if err := internal.WriteJSON(w, http.StatusOK, &responses.StatusResponse{
		Code:    http.StatusOK,
		Message: "Successfully logged out",
	}); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}
</file>

<file path="internal/transport/http/v1/handlers/cookie.go">
package handlers

import (
	"net/http"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/auth"
)

type CookieConfig struct {
	tmpAuthDomain string
	isLocalEnv    bool
}

func NewCookieConfig() *CookieConfig {
	return &CookieConfig{
		tmpAuthDomain: config.Config.AuthDomain(),
		isLocalEnv:    config.Config.Env == config.EnvLocal,
	}
}

func (c *CookieConfig) getXSRFTokenSameSite() http.SameSite {
	if c.isLocalEnv {
		return http.SameSiteLaxMode
	}
	return http.SameSiteNoneMode
}

func (c *CookieConfig) isSecure() bool {
	return !c.isLocalEnv
}

func (c *CookieConfig) setCookie(w http.ResponseWriter, name, value string, maxAge int, httpOnly bool, sameSite http.SameSite, domain string) {
	http.SetCookie(w, &http.Cookie{
		Name:     name,
		Value:    value,
		MaxAge:   maxAge,
		Path:     "/",
		Domain:   domain,
		HttpOnly: httpOnly,
		Secure:   c.isSecure(),
		SameSite: sameSite,
	})
}

func (c *CookieConfig) deleteCookie(w http.ResponseWriter, r *http.Request, name string, httpOnly bool, sameSite http.SameSite, domain string) {
	if cookie, _ := r.Cookie(name); cookie != nil {
		cookie.MaxAge = -1
		cookie.Domain = domain
		cookie.Path = "/"
		cookie.HttpOnly = httpOnly
		cookie.Secure = c.isSecure()
		cookie.SameSite = sameSite
		http.SetCookie(w, cookie)
	}
}

func (c *CookieConfig) SetTmpAuthCookie(w http.ResponseWriter, token, xsrfToken, domain string) {
	maxAge := int(auth.TmpTokenExpiration.Seconds())
	xsrfTokenSameSite := c.getXSRFTokenSameSite()

	c.setCookie(w, "access_token", token, maxAge, true, http.SameSiteStrictMode, domain)
	c.setCookie(w, "xsrf_token", xsrfToken, maxAge, false, xsrfTokenSameSite, domain)
	c.setCookie(w, "xsrf_token_same_site", xsrfToken, maxAge, true, http.SameSiteStrictMode, domain)
}

func (c *CookieConfig) DeleteTmpAuthCookie(w http.ResponseWriter, r *http.Request) {
	xsrfTokenSameSite := c.getXSRFTokenSameSite()

	c.deleteCookie(w, r, "access_token", true, http.SameSiteStrictMode, c.tmpAuthDomain)
	c.deleteCookie(w, r, "xsrf_token", false, xsrfTokenSameSite, c.tmpAuthDomain)
	c.deleteCookie(w, r, "xsrf_token_same_site", true, http.SameSiteStrictMode, c.tmpAuthDomain)
}

func (c *CookieConfig) SetAuthCookie(w http.ResponseWriter, token, refreshToken, xsrfToken string, tokenMaxAge, refreshTokenMaxAge, xsrfTokenMaxAge int, domain string) {
	xsrfTokenSameSite := c.getXSRFTokenSameSite()

	c.setCookie(w, "access_token", token, tokenMaxAge, true, http.SameSiteStrictMode, domain)
	c.setCookie(w, "refresh_token", refreshToken, refreshTokenMaxAge, true, http.SameSiteStrictMode, domain)
	c.setCookie(w, "xsrf_token", xsrfToken, xsrfTokenMaxAge, false, xsrfTokenSameSite, domain)
	c.setCookie(w, "xsrf_token_same_site", xsrfToken, xsrfTokenMaxAge, true, http.SameSiteStrictMode, domain)
}

func (c *CookieConfig) DeleteAuthCookie(w http.ResponseWriter, r *http.Request, domain string) {
	xsrfTokenSameSite := c.getXSRFTokenSameSite()

	c.deleteCookie(w, r, "access_token", true, http.SameSiteStrictMode, domain)
	c.deleteCookie(w, r, "refresh_token", true, http.SameSiteStrictMode, domain)
	c.deleteCookie(w, r, "xsrf_token", false, xsrfTokenSameSite, domain)
	c.deleteCookie(w, r, "xsrf_token_same_site", true, http.SameSiteStrictMode, domain)
}
</file>

<file path="internal/transport/http/v1/handlers/environment.go">
package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/go-chi/chi/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/app/environment"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/mapper"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type EnvironmentHandler struct {
	service environment.Service
}

func NewEnvironmentHandler(service environment.Service) *EnvironmentHandler {
	return &EnvironmentHandler{service}
}

// Get godoc
// @ID get-environment
// @Accept json
// @Produce json
// @Tags environments
// @Param environmentID path string true "Environment ID"
// @Success 200 {object} responses.GetEnvironmentResponse
// @Failure default {object} errdefs.Error
// @Router /environments/{environmentID} [get].
func (h *EnvironmentHandler) Get(w http.ResponseWriter, r *http.Request) {
	req := requests.GetEnvironmentRequest{
		EnvironmentID: chi.URLParam(r, "environmentID"),
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Get(r.Context(), mapper.GetEnvironmentRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.GetEnvironmentOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// List godoc
// @ID list-environments
// @Accept json
// @Produce json
// @Tags environments
// @Success 200 {object} responses.ListEnvironmentsResponse
// @Failure default {object} errdefs.Error
// @Router /environments [get].
func (h *EnvironmentHandler) List(w http.ResponseWriter, r *http.Request) {
	out, err := h.service.List(r.Context())
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.ListEnvironmentsOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// Create godoc
// @ID create-environment
// @Accept json
// @Produce json
// @Tags environments
// @Param Body body requests.CreateEnvironmentRequest true "Environment creation data including name and configuration"
// @Success 200 {object} responses.CreateEnvironmentResponse
// @Failure 400 {object} errdefs.Error "Invalid request parameters"
// @Failure 403 {object} errdefs.Error "Insufficient permissions"
// @Failure 500 {object} errdefs.Error "Internal server error"
// @Router /environments [post].
func (h *EnvironmentHandler) Create(w http.ResponseWriter, r *http.Request) {
	var req requests.CreateEnvironmentRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Create(r.Context(), mapper.CreateEnvironmentRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.CreateEnvironmentOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// Update godoc
// @ID update-environment
// @Accept json
// @Produce json
// @Tags environments
// @Param Body body requests.UpdateEnvironmentRequest true "Environment update data including name and configuration"
// @Param environmentID path string true "Environment ID to update"
// @Success 200 {object} responses.UpdateEnvironmentResponse
// @Failure 400 {object} errdefs.Error "Invalid request parameters"
// @Failure 403 {object} errdefs.Error "Insufficient permissions"
// @Failure 404 {object} errdefs.Error "Environment not found"
// @Failure 500 {object} errdefs.Error "Internal server error"
// @Router /environments/{environmentID} [put].
func (h *EnvironmentHandler) Update(w http.ResponseWriter, r *http.Request) {
	req := requests.UpdateEnvironmentRequest{
		EnvironmentID: chi.URLParam(r, "environmentID"),
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Update(r.Context(), mapper.UpdateEnvironmentRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.UpdateEnvironmentOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// Delete godoc
// @ID delete-environment
// @Accept json
// @Produce json
// @Tags environments
// @Param environmentID path string true "Environment ID"
// @Success 200 {object} responses.DeleteEnvironmentResponse
// @Failure default {object} errdefs.Error
// @Router /environments/{environmentID} [delete].
func (h *EnvironmentHandler) Delete(w http.ResponseWriter, r *http.Request) {
	req := requests.DeleteEnvironmentRequest{
		EnvironmentID: chi.URLParam(r, "environmentID"),
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Delete(r.Context(), mapper.DeleteEnvironmentRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.DeleteEnvironmentOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}
</file>

<file path="internal/transport/http/v1/handlers/group.go">
package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/go-chi/chi/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/app/group"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/mapper"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type GroupHandler struct {
	service group.Service
}

func NewGroupHandler(service group.Service) *GroupHandler {
	return &GroupHandler{service}
}

// Get godoc
// @ID get-group
// @Accept json
// @Produce json
// @Tags groups
// @Param groupID path string true "Group ID"
// @Success 200 {object} responses.GetGroupResponse
// @Failure default {object} errdefs.Error
// @Router /groups/{groupID} [get].
func (h *GroupHandler) Get(w http.ResponseWriter, r *http.Request) {
	req := requests.GetGroupRequest{
		GroupID: chi.URLParam(r, "groupID"),
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Get(r.Context(), mapper.GetGroupRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.GetGroupOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// List godoc
// @ID list-groups
// @Accept json
// @Produce json
// @Tags groups
// @Success 200 {object} responses.ListGroupsResponse
// @Failure default {object} errdefs.Error
// @Router /groups [get].
func (h *GroupHandler) List(w http.ResponseWriter, r *http.Request) {
	out, err := h.service.List(r.Context())
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.ListGroupsOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// Create godoc
// @ID create-group
// @Accept json
// @Produce json
// @Tags groups
// @Param Body body requests.CreateGroupRequest true "Group creation data including name and members"
// @Success 200 {object} responses.CreateGroupResponse
// @Failure 400 {object} errdefs.Error "Invalid request parameters"
// @Failure 403 {object} errdefs.Error "Insufficient permissions"
// @Failure 500 {object} errdefs.Error "Internal server error"
// @Router /groups [post].
func (h *GroupHandler) Create(w http.ResponseWriter, r *http.Request) {
	var req requests.CreateGroupRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Create(r.Context(), mapper.CreateGroupRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.CreateGroupOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// Update godoc
// @ID update-group
// @Accept json
// @Produce json
// @Tags groups
// @Param Body body requests.UpdateGroupRequest true "Group update data including name and members"
// @Param groupID path string true "Group ID to update"
// @Success 200 {object} responses.UpdateGroupResponse
// @Failure 400 {object} errdefs.Error "Invalid request parameters"
// @Failure 403 {object} errdefs.Error "Insufficient permissions"
// @Failure 404 {object} errdefs.Error "Group not found"
// @Failure 500 {object} errdefs.Error "Internal server error"
// @Router /groups/{groupID} [put].
func (h *GroupHandler) Update(w http.ResponseWriter, r *http.Request) {
	req := requests.UpdateGroupRequest{
		GroupID: chi.URLParam(r, "groupID"),
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Update(r.Context(), mapper.UpdateGroupRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.UpdateGroupOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// Delete godoc
// @ID delete-group
// @Accept json
// @Produce json
// @Tags groups
// @Param groupID path string true "Group ID"
// @Success 200 {object} responses.DeleteGroupResponse
// @Failure default {object} errdefs.Error
// @Router /groups/{groupID} [delete].
func (h *GroupHandler) Delete(w http.ResponseWriter, r *http.Request) {
	req := requests.DeleteGroupRequest{
		GroupID: chi.URLParam(r, "groupID"),
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Delete(r.Context(), mapper.DeleteGroupRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.DeleteGroupOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}
</file>

<file path="internal/transport/http/v1/handlers/hostinstance.go">
package handlers

import (
	"net/http"

	"github.com/trysourcetool/sourcetool/backend/internal/app/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/mapper"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type HostInstanceHandler struct {
	service hostinstance.Service
}

func NewHostInstanceHandler(service hostinstance.Service) *HostInstanceHandler {
	return &HostInstanceHandler{service}
}

// Ping godoc
// @ID ping-host-instance
// @Accept json
// @Produce json
// @Tags hostInstances
// @Param pageId query string true "Page ID"
// @Success 200 {object} responses.PingHostInstanceResponse
// @Failure default {object} errdefs.Error
// @Router /hostInstances/ping [get].
func (h *HostInstanceHandler) Ping(w http.ResponseWriter, r *http.Request) {
	req := requests.PingHostInstanceRequest{
		PageID: internal.NilValue(r.URL.Query().Get("pageId")),
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Ping(r.Context(), mapper.PingHostInstanceRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.PingHostInstanceOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}
</file>

<file path="internal/transport/http/v1/handlers/organization.go">
package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/trysourcetool/sourcetool/backend/internal/app/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/mapper"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/responses"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type OrganizationHandler struct {
	service organization.Service
}

func NewOrganizationHandler(service organization.Service) *OrganizationHandler {
	return &OrganizationHandler{service}
}

// Create godoc
// @ID create-organization
// @Accept json
// @Produce json
// @Tags organizations
// @Param Body body requests.CreateOrganizationRequest true " "
// @Success 200 {object} responses.CreateOrganizationResponse
// @Failure default {object} errdefs.Error
// @Router /organizations [post].
func (h *OrganizationHandler) Create(w http.ResponseWriter, r *http.Request) {
	var req requests.CreateOrganizationRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Create(r.Context(), mapper.CreateOrganizationRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.CreateOrganizationOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// CheckSubdomainAvailability godoc
// @ID check-organization-subdomain-availability
// @Accept json
// @Produce json
// @Tags organizations
// @Param subdomain query string true "Subdomain to check for availability"
// @Success 200 {object} responses.StatusResponse
// @Failure 400 {object} errdefs.Error "Invalid subdomain format"
// @Failure 409 {object} errdefs.Error "Subdomain already exists"
// @Failure 500 {object} errdefs.Error "Internal server error"
// @Router /organizations/checkSubdomainAvailability [get].
func (h *OrganizationHandler) CheckSubdomainAvailability(w http.ResponseWriter, r *http.Request) {
	req := requests.CheckSubdomainAvailablityRequest{
		Subdomain: r.URL.Query().Get("subdomain"),
	}
	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	err := h.service.CheckSubdomainAvailability(r.Context(), mapper.CheckSubdomainAvailabilityRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	response := &responses.StatusResponse{
		Code:    http.StatusOK,
		Message: "Subdomain is available",
	}

	if err := internal.WriteJSON(w, http.StatusOK, response); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}
</file>

<file path="internal/transport/http/v1/handlers/page.go">
package handlers

import (
	"net/http"

	"github.com/trysourcetool/sourcetool/backend/internal/app/page"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/mapper"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type PageHandler struct {
	service page.Service
}

func NewPageHandler(service page.Service) *PageHandler {
	return &PageHandler{service}
}

// List godoc
// @ID list-pages
// @Accept json
// @Produce json
// @Tags pages
// @Param environmentId query string true "Environment ID"
// @Success 200 {object} responses.ListPagesResponse
// @Failure default {object} errdefs.Error
// @Router /pages [get].
func (h *PageHandler) List(w http.ResponseWriter, r *http.Request) {
	in := requests.ListPagesRequest{
		EnvironmentID: r.URL.Query().Get("environmentId"),
	}
	if err := internal.ValidateRequest(in); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.List(r.Context(), mapper.ListPagesRequestToInput(in))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.ListPagesOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}
</file>

<file path="internal/transport/http/v1/handlers/user.go">
package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/go-chi/chi/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/app/user"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/mapper"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/responses"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type UserHandler struct {
	service user.Service
}

func NewUserHandler(service user.Service) *UserHandler {
	return &UserHandler{
		service: service,
	}
}

// GetMe godoc
// @ID get-me
// @Accept json
// @Produce json
// @Tags users
// @Success 200 {object} responses.GetMeResponse
// @Failure default {object} errdefs.Error
// @Router /users/me [get].
func (h *UserHandler) GetMe(w http.ResponseWriter, r *http.Request) {
	out, err := h.service.GetMe(r.Context())
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.GetMeOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// UpdateMe godoc
// @ID update-me
// @Accept json
// @Produce json
// @Tags users
// @Param Body body requests.UpdateMeRequest true " "
// @Success 200 {object} responses.UpdateMeResponse
// @Failure default {object} errdefs.Error
// @Router /users/me [put].
func (h *UserHandler) UpdateMe(w http.ResponseWriter, r *http.Request) {
	var req requests.UpdateMeRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.UpdateMe(r.Context(), mapper.UpdateMeRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.UpdateMeOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// SendUpdateMeEmailInstructions godoc
// @ID send-update-me-email-instructions
// @Accept json
// @Produce json
// @Tags users
// @Param Body body requests.SendUpdateMeEmailInstructionsRequest true " "
// @Success 200 {object} responses.StatusResponse
// @Failure default {object} errdefs.Error
// @Router /users/me/email/instructions [post].
func (h *UserHandler) SendUpdateMeEmailInstructions(w http.ResponseWriter, r *http.Request) {
	var req requests.SendUpdateMeEmailInstructionsRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := h.service.SendUpdateMeEmailInstructions(r.Context(), mapper.SendUpdateMeEmailInstructionsRequestToInput(req)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, &responses.StatusResponse{
		Code:    http.StatusOK,
		Message: "Successfully sent update email instructions",
	}); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// UpdateMeEmail godoc
// @ID update-me-email
// @Accept json
// @Produce json
// @Tags users
// @Param Body body requests.UpdateMeEmailRequest true " "
// @Success 200 {object} responses.UpdateMeEmailResponse
// @Failure default {object} errdefs.Error
// @Router /users/me/email [put].
func (h *UserHandler) UpdateMeEmail(w http.ResponseWriter, r *http.Request) {
	var req requests.UpdateMeEmailRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.UpdateMeEmail(r.Context(), mapper.UpdateMeEmailRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.UpdateMeEmailOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// List godoc
// @ID list-users
// @Accept json
// @Produce json
// @Tags users
// @Success 200 {object} responses.ListUsersResponse
// @Failure default {object} errdefs.Error
// @Router /users [get].
func (h *UserHandler) List(w http.ResponseWriter, r *http.Request) {
	out, err := h.service.List(r.Context())
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.ListUsersOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// UpdateUser godoc
// @ID update-user
// @Accept json
// @Produce json
// @Tags users
// @Param userID path string true " "
// @Param Body body requests.UpdateUserRequest true " "
// @Success 200 {object} responses.UpdateUserResponse
// @Failure default {object} errdefs.Error
// @Router /users/{userID} [put].
func (h *UserHandler) Update(w http.ResponseWriter, r *http.Request) {
	req := requests.UpdateUserRequest{
		UserID: chi.URLParam(r, "userID"),
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.Update(r.Context(), mapper.UpdateUserRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.UpdateUserOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// DeleteUser godoc
// @ID delete-user
// @Accept json
// @Produce json
// @Tags users
// @Param userID path string true " "
// @Success 200 {object} responses.StatusResponse
// @Failure default {object} errdefs.Error
// @Router /users/{userID} [delete].
func (h *UserHandler) Delete(w http.ResponseWriter, r *http.Request) {
	req := requests.DeleteUserRequest{
		UserID: chi.URLParam(r, "userID"),
	}
	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := h.service.Delete(r.Context(), mapper.DeleteUserRequestToInput(req)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	response := &responses.StatusResponse{
		Code:    http.StatusOK,
		Message: "Successfully deleted user",
	}

	if err := internal.WriteJSON(w, http.StatusOK, response); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// ResendUserInvitation godoc
// @ID resend-user-invitation
// @Accept json
// @Produce json
// @Tags users
// @Param invitationID path string true " "
// @Success 200 {object} responses.ResendUserInvitationResponse
// @Failure default {object} errdefs.Error
// @Router /users/invitations/{invitationID}/resend [post].
func (h *UserHandler) ResendUserInvitation(w http.ResponseWriter, r *http.Request) {
	req := requests.ResendUserInvitationRequest{
		InvitationID: chi.URLParam(r, "invitationID"),
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.ResendUserInvitation(r.Context(), mapper.ResendUserInvitationRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.ResendUserInvitationOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}

// CreateUserInvitations godoc
// @ID create-user-invitations
// @Accept json
// @Produce json
// @Tags users
// @Param Body body requests.CreateUserInvitationsRequest true " "
// @Success 200 {object} responses.CreateUserInvitationsResponse
// @Failure default {object} errdefs.Error
// @Router /users/invitations [post].
func (h *UserHandler) CreateUserInvitations(w http.ResponseWriter, r *http.Request) {
	var req requests.CreateUserInvitationsRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.ValidateRequest(req); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	out, err := h.service.CreateUserInvitations(r.Context(), mapper.CreateUserInvitationsRequestToInput(req))
	if err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}

	if err := internal.WriteJSON(w, http.StatusOK, mapper.CreateUserInvitationsOutputToResponse(out)); err != nil {
		internal.WriteErrJSON(r.Context(), w, err)
		return
	}
}
</file>

<file path="internal/transport/http/v1/mapper/apikey.go">
package mapper

import (
	"strconv"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/responses"
)

func APIKeyOutputToResponse(apiKey *dto.APIKey) *responses.APIKeyResponse {
	if apiKey == nil {
		return nil
	}

	result := &responses.APIKeyResponse{
		ID:        apiKey.ID,
		Name:      apiKey.Name,
		Key:       apiKey.Key,
		CreatedAt: strconv.FormatInt(apiKey.CreatedAt, 10),
		UpdatedAt: strconv.FormatInt(apiKey.UpdatedAt, 10),
	}

	if apiKey.Environment != nil {
		result.Environment = EnvironmentOutputToResponse(apiKey.Environment)
	}

	return result
}

func GetAPIKeyRequestToInput(in requests.GetAPIKeyRequest) dto.GetAPIKeyInput {
	return dto.GetAPIKeyInput{
		APIKeyID: in.APIKeyID,
	}
}

func GetAPIKeyOutputToResponse(out *dto.GetAPIKeyOutput) *responses.GetAPIKeyResponse {
	return &responses.GetAPIKeyResponse{
		APIKey: APIKeyOutputToResponse(out.APIKey),
	}
}

func ListAPIKeysOutputToResponse(out *dto.ListAPIKeysOutput) *responses.ListAPIKeysResponse {
	liveKeys := make([]*responses.APIKeyResponse, 0, len(out.LiveKeys))
	for _, key := range out.LiveKeys {
		liveKeys = append(liveKeys, APIKeyOutputToResponse(key))
	}

	return &responses.ListAPIKeysResponse{
		DevKey:   APIKeyOutputToResponse(out.DevKey),
		LiveKeys: liveKeys,
	}
}

func CreateAPIKeyRequestToInput(in requests.CreateAPIKeyRequest) dto.CreateAPIKeyInput {
	return dto.CreateAPIKeyInput{
		EnvironmentID: in.EnvironmentID,
		Name:          in.Name,
	}
}

func CreateAPIKeyOutputToResponse(out *dto.CreateAPIKeyOutput) *responses.CreateAPIKeyResponse {
	return &responses.CreateAPIKeyResponse{
		APIKey: APIKeyOutputToResponse(out.APIKey),
	}
}

func UpdateAPIKeyRequestToInput(in requests.UpdateAPIKeyRequest) dto.UpdateAPIKeyInput {
	return dto.UpdateAPIKeyInput{
		APIKeyID: in.APIKeyID,
		Name:     in.Name,
	}
}

func UpdateAPIKeyOutputToResponse(out *dto.UpdateAPIKeyOutput) *responses.UpdateAPIKeyResponse {
	return &responses.UpdateAPIKeyResponse{
		APIKey: APIKeyOutputToResponse(out.APIKey),
	}
}

func DeleteAPIKeyRequestToInput(in requests.DeleteAPIKeyRequest) dto.DeleteAPIKeyInput {
	return dto.DeleteAPIKeyInput{
		APIKeyID: in.APIKeyID,
	}
}

func DeleteAPIKeyOutputToResponse(out *dto.DeleteAPIKeyOutput) *responses.DeleteAPIKeyResponse {
	return &responses.DeleteAPIKeyResponse{
		APIKey: APIKeyOutputToResponse(out.APIKey),
	}
}
</file>

<file path="internal/transport/http/v1/mapper/auth.go">
package mapper

import (
	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/responses"
)

func RequestMagicLinkRequestToInput(in requests.RequestMagicLinkRequest) dto.RequestMagicLinkInput {
	return dto.RequestMagicLinkInput{
		Email: in.Email,
	}
}

func AuthenticateWithMagicLinkRequestToInput(in requests.AuthenticateWithMagicLinkRequest) dto.AuthenticateWithMagicLinkInput {
	return dto.AuthenticateWithMagicLinkInput{
		Token:     in.Token,
		FirstName: in.FirstName,
		LastName:  in.LastName,
	}
}

func AuthenticateWithMagicLinkOutputToResponse(out *dto.AuthenticateWithMagicLinkOutput) *responses.AuthenticateWithMagicLinkResponse {
	return &responses.AuthenticateWithMagicLinkResponse{
		AuthURL:         out.AuthURL,
		Token:           out.Token,
		HasOrganization: out.HasOrganization,
		IsNewUser:       out.IsNewUser,
	}
}

func RequestMagicLinkOutputToResponse(out *dto.RequestMagicLinkOutput) responses.RequestMagicLinkResponse {
	return responses.RequestMagicLinkResponse{
		Email: out.Email,
		IsNew: out.IsNew,
	}
}

func RegisterWithMagicLinkRequestToInput(in requests.RegisterWithMagicLinkRequest) dto.RegisterWithMagicLinkInput {
	return dto.RegisterWithMagicLinkInput{
		Token:     in.Token,
		FirstName: in.FirstName,
		LastName:  in.LastName,
	}
}

func RegisterWithMagicLinkOutputToResponse(out *dto.RegisterWithMagicLinkOutput) *responses.RegisterWithMagicLinkResponse {
	return &responses.RegisterWithMagicLinkResponse{
		ExpiresAt:       out.ExpiresAt,
		HasOrganization: out.HasOrganization,
	}
}

func RequestInvitationMagicLinkRequestToInput(in requests.RequestInvitationMagicLinkRequest) dto.RequestInvitationMagicLinkInput {
	return dto.RequestInvitationMagicLinkInput{
		InvitationToken: in.InvitationToken,
	}
}

func RequestInvitationMagicLinkOutputToResponse(out *dto.RequestInvitationMagicLinkOutput) *responses.RequestInvitationMagicLinkResponse {
	return &responses.RequestInvitationMagicLinkResponse{
		Email: out.Email,
	}
}

func AuthenticateWithInvitationMagicLinkRequestToInput(in requests.AuthenticateWithInvitationMagicLinkRequest) dto.AuthenticateWithInvitationMagicLinkInput {
	return dto.AuthenticateWithInvitationMagicLinkInput{
		Token: in.Token,
	}
}

func AuthenticateWithInvitationMagicLinkOutputToResponse(out *dto.AuthenticateWithInvitationMagicLinkOutput) *responses.AuthenticateWithInvitationMagicLinkResponse {
	return &responses.AuthenticateWithInvitationMagicLinkResponse{
		AuthURL:   out.AuthURL,
		Token:     out.Token,
		IsNewUser: out.IsNewUser,
	}
}

func RegisterWithInvitationMagicLinkRequestToInput(in requests.RegisterWithInvitationMagicLinkRequest) dto.RegisterWithInvitationMagicLinkInput {
	return dto.RegisterWithInvitationMagicLinkInput{
		Token:     in.Token,
		FirstName: in.FirstName,
		LastName:  in.LastName,
	}
}

func RegisterWithInvitationMagicLinkOutputToResponse(out *dto.RegisterWithInvitationMagicLinkOutput) *responses.RegisterWithInvitationMagicLinkResponse {
	return &responses.RegisterWithInvitationMagicLinkResponse{
		ExpiresAt: out.ExpiresAt,
	}
}

func RequestGoogleAuthLinkOutputToResponse(out *dto.RequestGoogleAuthLinkOutput) *responses.RequestGoogleAuthLinkResponse {
	return &responses.RequestGoogleAuthLinkResponse{
		AuthURL: out.AuthURL,
	}
}

func AuthenticateWithGoogleRequestToInput(req requests.AuthenticateWithGoogleRequest) dto.AuthenticateWithGoogleInput {
	return dto.AuthenticateWithGoogleInput{
		Code:  req.Code,
		State: req.State,
	}
}

func AuthenticateWithGoogleOutputToResponse(out *dto.AuthenticateWithGoogleOutput) *responses.AuthenticateWithGoogleResponse {
	return &responses.AuthenticateWithGoogleResponse{
		FirstName:                out.FirstName,
		LastName:                 out.LastName,
		AuthURL:                  out.AuthURL,
		Token:                    out.Token,
		HasOrganization:          out.HasOrganization,
		HasMultipleOrganizations: out.HasMultipleOrganizations,
		IsNewUser:                out.IsNewUser,
	}
}

func RegisterWithGoogleRequestToInput(in requests.RegisterWithGoogleRequest) dto.RegisterWithGoogleInput {
	return dto.RegisterWithGoogleInput{
		Token: in.Token,
	}
}

func RegisterWithGoogleOutputToResponse(out *dto.RegisterWithGoogleOutput) *responses.RegisterWithGoogleResponse {
	return &responses.RegisterWithGoogleResponse{
		AuthURL:         out.AuthURL,
		Token:           out.Token,
		HasOrganization: out.HasOrganization,
	}
}

func RequestInvitationGoogleAuthLinkRequestToInput(in requests.RequestInvitationGoogleAuthLinkRequest) dto.RequestInvitationGoogleAuthLinkInput {
	return dto.RequestInvitationGoogleAuthLinkInput{
		InvitationToken: in.InvitationToken,
	}
}

func RequestInvitationGoogleAuthLinkOutputToResponse(out *dto.RequestInvitationGoogleAuthLinkOutput) *responses.RequestInvitationGoogleAuthLinkResponse {
	return &responses.RequestInvitationGoogleAuthLinkResponse{
		AuthURL: out.AuthURL,
	}
}

func RefreshTokenRequestToInput(in requests.RefreshTokenRequest) dto.RefreshTokenInput {
	return dto.RefreshTokenInput{
		RefreshToken:    in.RefreshToken,
		XSRFTokenHeader: in.XSRFTokenHeader,
		XSRFTokenCookie: in.XSRFTokenCookie,
	}
}

func RefreshTokenOutputToResponse(out *dto.RefreshTokenOutput) *responses.RefreshTokenResponse {
	return &responses.RefreshTokenResponse{
		ExpiresAt: out.ExpiresAt,
	}
}

func SaveAuthRequestToInput(in requests.SaveAuthRequest) dto.SaveAuthInput {
	return dto.SaveAuthInput{
		Token: in.Token,
	}
}

func SaveAuthOutputToResponse(out *dto.SaveAuthOutput) *responses.SaveAuthResponse {
	return &responses.SaveAuthResponse{
		ExpiresAt:   out.ExpiresAt,
		RedirectURL: out.RedirectURL,
	}
}

func ObtainAuthTokenOutputToResponse(out *dto.ObtainAuthTokenOutput) *responses.ObtainAuthTokenResponse {
	return &responses.ObtainAuthTokenResponse{
		AuthURL: out.AuthURL,
		Token:   out.Token,
	}
}

func LogoutOutputToResponse(out *dto.LogoutOutput) *responses.LogoutResponse {
	return &responses.LogoutResponse{
		Domain: out.Domain,
	}
}
</file>

<file path="internal/transport/http/v1/mapper/environment.go">
package mapper

import (
	"strconv"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/responses"
)

func EnvironmentOutputToResponse(env *dto.Environment) *responses.EnvironmentResponse {
	if env == nil {
		return nil
	}

	return &responses.EnvironmentResponse{
		ID:        env.ID,
		Name:      env.Name,
		Slug:      env.Slug,
		Color:     env.Color,
		CreatedAt: strconv.FormatInt(env.CreatedAt, 10),
		UpdatedAt: strconv.FormatInt(env.UpdatedAt, 10),
	}
}

func GetEnvironmentRequestToInput(in requests.GetEnvironmentRequest) dto.GetEnvironmentInput {
	return dto.GetEnvironmentInput{
		EnvironmentID: in.EnvironmentID,
	}
}

func GetEnvironmentOutputToResponse(out *dto.GetEnvironmentOutput) *responses.GetEnvironmentResponse {
	return &responses.GetEnvironmentResponse{
		Environment: EnvironmentOutputToResponse(out.Environment),
	}
}

func ListEnvironmentsOutputToResponse(out *dto.ListEnvironmentsOutput) *responses.ListEnvironmentsResponse {
	envs := make([]*responses.EnvironmentResponse, 0, len(out.Environments))
	for _, env := range out.Environments {
		envs = append(envs, EnvironmentOutputToResponse(env))
	}

	return &responses.ListEnvironmentsResponse{
		Environments: envs,
	}
}

func CreateEnvironmentRequestToInput(in requests.CreateEnvironmentRequest) dto.CreateEnvironmentInput {
	return dto.CreateEnvironmentInput{
		Name:  in.Name,
		Slug:  in.Slug,
		Color: in.Color,
	}
}

func CreateEnvironmentOutputToResponse(out *dto.CreateEnvironmentOutput) *responses.CreateEnvironmentResponse {
	return &responses.CreateEnvironmentResponse{
		Environment: EnvironmentOutputToResponse(out.Environment),
	}
}

func UpdateEnvironmentRequestToInput(in requests.UpdateEnvironmentRequest) dto.UpdateEnvironmentInput {
	return dto.UpdateEnvironmentInput{
		EnvironmentID: in.EnvironmentID,
		Name:          in.Name,
		Color:         in.Color,
	}
}

func UpdateEnvironmentOutputToResponse(out *dto.UpdateEnvironmentOutput) *responses.UpdateEnvironmentResponse {
	return &responses.UpdateEnvironmentResponse{
		Environment: EnvironmentOutputToResponse(out.Environment),
	}
}

func DeleteEnvironmentRequestToInput(in requests.DeleteEnvironmentRequest) dto.DeleteEnvironmentInput {
	return dto.DeleteEnvironmentInput{
		EnvironmentID: in.EnvironmentID,
	}
}

func DeleteEnvironmentOutputToResponse(out *dto.DeleteEnvironmentOutput) *responses.DeleteEnvironmentResponse {
	return &responses.DeleteEnvironmentResponse{
		Environment: EnvironmentOutputToResponse(out.Environment),
	}
}
</file>

<file path="internal/transport/http/v1/mapper/group.go">
package mapper

import (
	"strconv"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/responses"
)

func GroupOutputToResponse(group *dto.Group) *responses.GroupResponse {
	if group == nil {
		return nil
	}

	return &responses.GroupResponse{
		ID:        group.ID,
		Name:      group.Name,
		Slug:      group.Slug,
		CreatedAt: strconv.FormatInt(group.CreatedAt, 10),
		UpdatedAt: strconv.FormatInt(group.UpdatedAt, 10),
	}
}

func GroupPageOutputToResponse(groupPage *dto.GroupPage) *responses.GroupPageResponse {
	if groupPage == nil {
		return nil
	}

	return &responses.GroupPageResponse{
		ID:        groupPage.ID,
		GroupID:   groupPage.GroupID,
		PageID:    groupPage.PageID,
		CreatedAt: strconv.FormatInt(groupPage.CreatedAt, 10),
		UpdatedAt: strconv.FormatInt(groupPage.UpdatedAt, 10),
	}
}

func GetGroupRequestToInput(in requests.GetGroupRequest) dto.GetGroupInput {
	return dto.GetGroupInput{
		GroupID: in.GroupID,
	}
}

func GetGroupOutputToResponse(out *dto.GetGroupOutput) *responses.GetGroupResponse {
	return &responses.GetGroupResponse{
		Group: GroupOutputToResponse(out.Group),
	}
}

func ListGroupsOutputToResponse(out *dto.ListGroupsOutput) *responses.ListGroupsResponse {
	groups := make([]*responses.GroupResponse, 0, len(out.Groups))
	for _, group := range out.Groups {
		groups = append(groups, GroupOutputToResponse(group))
	}

	users := make([]*responses.UserResponse, 0, len(out.Users))
	for _, user := range out.Users {
		users = append(users, UserOutputToResponse(user))
	}

	userGroups := make([]*responses.UserGroupResponse, 0, len(out.UserGroups))
	for _, userGroup := range out.UserGroups {
		userGroups = append(userGroups, UserGroupOutputToResponse(userGroup))
	}

	return &responses.ListGroupsResponse{
		Groups:     groups,
		Users:      users,
		UserGroups: userGroups,
	}
}

func CreateGroupRequestToInput(in requests.CreateGroupRequest) dto.CreateGroupInput {
	return dto.CreateGroupInput{
		Name:    in.Name,
		Slug:    in.Slug,
		UserIDs: in.UserIDs,
	}
}

func CreateGroupOutputToResponse(out *dto.CreateGroupOutput) *responses.CreateGroupResponse {
	return &responses.CreateGroupResponse{
		Group: GroupOutputToResponse(out.Group),
	}
}

func UpdateGroupRequestToInput(in requests.UpdateGroupRequest) dto.UpdateGroupInput {
	return dto.UpdateGroupInput{
		GroupID: in.GroupID,
		Name:    in.Name,
		UserIDs: in.UserIDs,
	}
}

func UpdateGroupOutputToResponse(out *dto.UpdateGroupOutput) *responses.UpdateGroupResponse {
	return &responses.UpdateGroupResponse{
		Group: GroupOutputToResponse(out.Group),
	}
}

func DeleteGroupRequestToInput(in requests.DeleteGroupRequest) dto.DeleteGroupInput {
	return dto.DeleteGroupInput{
		GroupID: in.GroupID,
	}
}

func DeleteGroupOutputToResponse(out *dto.DeleteGroupOutput) *responses.DeleteGroupResponse {
	return &responses.DeleteGroupResponse{
		Group: GroupOutputToResponse(out.Group),
	}
}
</file>

<file path="internal/transport/http/v1/mapper/hostinstance.go">
package mapper

import (
	"strconv"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/responses"
)

func HostInstanceOutputToResponse(instance *dto.HostInstance) *responses.HostInstanceResponse {
	if instance == nil {
		return nil
	}

	return &responses.HostInstanceResponse{
		ID:         instance.ID,
		SDKName:    instance.SDKName,
		SDKVersion: instance.SDKVersion,
		Status:     instance.Status,
		CreatedAt:  strconv.FormatInt(instance.CreatedAt, 10),
		UpdatedAt:  strconv.FormatInt(instance.UpdatedAt, 10),
	}
}

func PingHostInstanceRequestToInput(in requests.PingHostInstanceRequest) dto.PingHostInstanceInput {
	return dto.PingHostInstanceInput{
		PageID: in.PageID,
	}
}

func PingHostInstanceOutputToResponse(out *dto.PingHostInstanceOutput) *responses.PingHostInstanceResponse {
	return &responses.PingHostInstanceResponse{
		HostInstance: HostInstanceOutputToResponse(out.HostInstance),
	}
}
</file>

<file path="internal/transport/http/v1/mapper/organization.go">
package mapper

import (
	"strconv"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/responses"
)

func OrganizationOutputToResponse(org *dto.Organization) *responses.OrganizationResponse {
	if org == nil {
		return nil
	}

	return &responses.OrganizationResponse{
		ID:                org.ID,
		Subdomain:         org.Subdomain,
		WebSocketEndpoint: config.Config.WebSocketOrgBaseURL(org.Subdomain),
		CreatedAt:         strconv.FormatInt(org.CreatedAt, 10),
		UpdatedAt:         strconv.FormatInt(org.UpdatedAt, 10),
	}
}

func CreateOrganizationRequestToInput(in requests.CreateOrganizationRequest) dto.CreateOrganizationInput {
	return dto.CreateOrganizationInput{
		Subdomain: in.Subdomain,
	}
}

func CreateOrganizationOutputToResponse(out *dto.CreateOrganizationOutput) *responses.CreateOrganizationResponse {
	return &responses.CreateOrganizationResponse{
		Organization: OrganizationOutputToResponse(out.Organization),
	}
}

func CheckSubdomainAvailabilityRequestToInput(in requests.CheckSubdomainAvailablityRequest) dto.CheckSubdomainAvailabilityInput {
	return dto.CheckSubdomainAvailabilityInput{
		Subdomain: in.Subdomain,
	}
}
</file>

<file path="internal/transport/http/v1/mapper/page.go">
package mapper

import (
	"strconv"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/responses"
)

func PageOutputToResponse(page *dto.Page) *responses.PageResponse {
	if page == nil {
		return nil
	}

	return &responses.PageResponse{
		ID:        page.ID,
		Name:      page.Name,
		Route:     page.Route,
		CreatedAt: strconv.FormatInt(page.CreatedAt, 10),
		UpdatedAt: strconv.FormatInt(page.UpdatedAt, 10),
	}
}

func ListPagesRequestToInput(in requests.ListPagesRequest) dto.ListPagesInput {
	return dto.ListPagesInput{
		EnvironmentID: in.EnvironmentID,
	}
}

func ListPagesOutputToResponse(out *dto.ListPagesOutput) *responses.ListPagesResponse {
	pages := make([]*responses.PageResponse, 0, len(out.Pages))
	for _, page := range out.Pages {
		pages = append(pages, PageOutputToResponse(page))
	}

	groups := make([]*responses.GroupResponse, 0, len(out.Groups))
	for _, group := range out.Groups {
		groups = append(groups, GroupOutputToResponse(group))
	}

	groupPages := make([]*responses.GroupPageResponse, 0, len(out.GroupPages))
	for _, groupPage := range out.GroupPages {
		groupPages = append(groupPages, GroupPageOutputToResponse(groupPage))
	}

	users := make([]*responses.UserResponse, 0, len(out.Users))
	for _, user := range out.Users {
		users = append(users, UserOutputToResponse(user))
	}

	userGroups := make([]*responses.UserGroupResponse, 0, len(out.UserGroups))
	for _, userGroup := range out.UserGroups {
		userGroups = append(userGroups, UserGroupOutputToResponse(userGroup))
	}

	return &responses.ListPagesResponse{
		Pages:      pages,
		Groups:     groups,
		GroupPages: groupPages,
		Users:      users,
		UserGroups: userGroups,
	}
}
</file>

<file path="internal/transport/http/v1/mapper/user.go">
package mapper

import (
	"strconv"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/requests"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/responses"
)

func UserOutputToResponse(user *dto.User) *responses.UserResponse {
	if user == nil {
		return nil
	}

	result := &responses.UserResponse{
		ID:        user.ID,
		Email:     user.Email,
		FirstName: user.FirstName,
		LastName:  user.LastName,
		Role:      user.Role,
		CreatedAt: strconv.FormatInt(user.CreatedAt, 10),
		UpdatedAt: strconv.FormatInt(user.UpdatedAt, 10),
	}

	if user.Organization != nil {
		result.Organization = OrganizationOutputToResponse(user.Organization)
	}

	return result
}

func UserInvitationOutputToResponse(invitation *dto.UserInvitation) *responses.UserInvitationResponse {
	if invitation == nil {
		return nil
	}

	return &responses.UserInvitationResponse{
		ID:        invitation.ID,
		Email:     invitation.Email,
		CreatedAt: strconv.FormatInt(invitation.CreatedAt, 10),
	}
}

func UserGroupOutputToResponse(group *dto.UserGroup) *responses.UserGroupResponse {
	if group == nil {
		return nil
	}

	return &responses.UserGroupResponse{
		ID:        group.ID,
		UserID:    group.UserID,
		GroupID:   group.GroupID,
		CreatedAt: strconv.FormatInt(group.CreatedAt, 10),
		UpdatedAt: strconv.FormatInt(group.UpdatedAt, 10),
	}
}

func GetMeOutputToResponse(out *dto.GetMeOutput) *responses.GetMeResponse {
	return &responses.GetMeResponse{
		User: UserOutputToResponse(out.User),
	}
}

func ListUsersOutputToResponse(out *dto.ListUsersOutput) *responses.ListUsersResponse {
	users := make([]*responses.UserResponse, 0, len(out.Users))
	for _, user := range out.Users {
		users = append(users, UserOutputToResponse(user))
	}

	invitations := make([]*responses.UserInvitationResponse, 0, len(out.UserInvitations))
	for _, invitation := range out.UserInvitations {
		invitations = append(invitations, UserInvitationOutputToResponse(invitation))
	}

	return &responses.ListUsersResponse{
		Users:           users,
		UserInvitations: invitations,
	}
}

func UpdateMeRequestToInput(in requests.UpdateMeRequest) dto.UpdateMeInput {
	return dto.UpdateMeInput{
		FirstName: in.FirstName,
		LastName:  in.LastName,
	}
}

func UpdateMeOutputToResponse(out *dto.UpdateMeOutput) *responses.UpdateMeResponse {
	return &responses.UpdateMeResponse{
		User: UserOutputToResponse(out.User),
	}
}

func SendUpdateMeEmailInstructionsRequestToInput(in requests.SendUpdateMeEmailInstructionsRequest) dto.SendUpdateMeEmailInstructionsInput {
	return dto.SendUpdateMeEmailInstructionsInput{
		Email:             in.Email,
		EmailConfirmation: in.EmailConfirmation,
	}
}

func UpdateMeEmailRequestToInput(in requests.UpdateMeEmailRequest) dto.UpdateMeEmailInput {
	return dto.UpdateMeEmailInput{
		Token: in.Token,
	}
}

func UpdateMeEmailOutputToResponse(out *dto.UpdateMeEmailOutput) *responses.UpdateMeEmailResponse {
	return &responses.UpdateMeEmailResponse{
		User: UserOutputToResponse(out.User),
	}
}

func UpdateUserRequestToInput(in requests.UpdateUserRequest) dto.UpdateUserInput {
	return dto.UpdateUserInput{
		UserID:   in.UserID,
		Role:     in.Role,
		GroupIDs: in.GroupIDs,
	}
}

func UpdateUserOutputToResponse(out *dto.UpdateUserOutput) *responses.UpdateUserResponse {
	return &responses.UpdateUserResponse{
		User: UserOutputToResponse(out.User),
	}
}

func DeleteUserRequestToInput(in requests.DeleteUserRequest) dto.DeleteUserInput {
	return dto.DeleteUserInput{
		UserID: in.UserID,
	}
}

func CreateUserInvitationsRequestToInput(in requests.CreateUserInvitationsRequest) dto.CreateUserInvitationsInput {
	return dto.CreateUserInvitationsInput{
		Emails: in.Emails,
		Role:   in.Role,
	}
}

func CreateUserInvitationsOutputToResponse(out *dto.CreateUserInvitationsOutput) *responses.CreateUserInvitationsResponse {
	invitations := make([]*responses.UserInvitationResponse, 0, len(out.UserInvitations))
	for _, invitation := range out.UserInvitations {
		invitations = append(invitations, UserInvitationOutputToResponse(invitation))
	}

	return &responses.CreateUserInvitationsResponse{
		UserInvitations: invitations,
	}
}

func ResendUserInvitationRequestToInput(in requests.ResendUserInvitationRequest) dto.ResendUserInvitationInput {
	return dto.ResendUserInvitationInput{
		InvitationID: in.InvitationID,
	}
}

func ResendUserInvitationOutputToResponse(out *dto.ResendUserInvitationOutput) *responses.ResendUserInvitationResponse {
	return &responses.ResendUserInvitationResponse{
		UserInvitation: UserInvitationOutputToResponse(out.UserInvitation),
	}
}
</file>

<file path="internal/transport/http/v1/requests/apikey.go">
package requests

type GetAPIKeyRequest struct {
	APIKeyID string `json:"-" validate:"required"`
}

type CreateAPIKeyRequest struct {
	EnvironmentID string `json:"environmentId" validate:"required"`
	Name          string `json:"name" validate:"required"`
}

type UpdateAPIKeyRequest struct {
	APIKeyID string  `json:"-" validate:"required"`
	Name     *string `json:"name" validate:"-"`
}

type DeleteAPIKeyRequest struct {
	APIKeyID string `json:"-" validate:"required"`
}
</file>

<file path="internal/transport/http/v1/requests/auth.go">
package requests

type RequestMagicLinkRequest struct {
	Email string `json:"email" validate:"required,email"`
}

type AuthenticateWithMagicLinkRequest struct {
	Token     string `json:"token" validate:"required"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
}

type RegisterWithMagicLinkRequest struct {
	Token     string `json:"token"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
}

type RequestInvitationMagicLinkRequest struct {
	InvitationToken string `json:"invitationToken" validate:"required"`
}

type AuthenticateWithInvitationMagicLinkRequest struct {
	Token string `json:"token" validate:"required"`
}

type RegisterWithInvitationMagicLinkRequest struct {
	Token     string `json:"token" validate:"required"`
	FirstName string `json:"firstName" validate:"required"`
	LastName  string `json:"lastName" validate:"required"`
}

type AuthenticateWithGoogleRequest struct {
	Code  string `json:"code" validate:"required"`
	State string `json:"state" validate:"required"`
}

type RegisterWithGoogleRequest struct {
	Token string `json:"token" validate:"required"`
}

type RequestInvitationGoogleAuthLinkRequest struct {
	InvitationToken string `json:"invitationToken" validate:"required"`
}

type AuthenticateWithInvitationGoogleAuthLinkRequest struct {
	Code  string `json:"code" validate:"required"`
	State string `json:"state" validate:"required"`
}

type RegisterWithInvitationGoogleAuthLinkRequest struct {
	Token     string `json:"token" validate:"required"`
	FirstName string `json:"firstName" validate:"required"`
	LastName  string `json:"lastName" validate:"required"`
}

type RefreshTokenRequest struct {
	RefreshToken    string `validate:"required"`
	XSRFTokenHeader string `validate:"required"`
	XSRFTokenCookie string `validate:"required"`
}

type SaveAuthRequest struct {
	Token string `json:"token" validate:"required"`
}
</file>

<file path="internal/transport/http/v1/requests/environment.go">
package requests

type GetEnvironmentRequest struct {
	EnvironmentID string `json:"-" validate:"required"`
}

type CreateEnvironmentRequest struct {
	Name  string `json:"name" validate:"required"`
	Slug  string `json:"slug" validate:"required"`
	Color string `json:"color" validate:"required"`
}

type UpdateEnvironmentRequest struct {
	EnvironmentID string  `json:"-" validate:"required"`
	Name          *string `json:"name" validate:"required"`
	Color         *string `json:"color" validate:"required"`
}

type DeleteEnvironmentRequest struct {
	EnvironmentID string `json:"environmentId" validate:"required"`
}
</file>

<file path="internal/transport/http/v1/requests/group.go">
package requests

type GetGroupRequest struct {
	GroupID string `json:"-" validate:"required"`
}

type CreateGroupRequest struct {
	Name    string   `json:"name" validate:"required"`
	Slug    string   `json:"slug" validate:"required"`
	UserIDs []string `json:"userIds" validate:"required"`
}

type UpdateGroupRequest struct {
	GroupID string   `json:"-" validate:"required"`
	Name    *string  `json:"name" validate:"required"`
	UserIDs []string `json:"userIds" validate:"required"`
}

type DeleteGroupRequest struct {
	GroupID string `json:"groupId" validate:"required"`
}
</file>

<file path="internal/transport/http/v1/requests/hostinstance.go">
package requests

type PingHostInstanceRequest struct {
	PageID *string `validate:"-"`
}
</file>

<file path="internal/transport/http/v1/requests/organization.go">
package requests

type CreateOrganizationRequest struct {
	Subdomain string `json:"subdomain" validate:"required"`
}

type CheckSubdomainAvailablityRequest struct {
	Subdomain string `validate:"required"`
}
</file>

<file path="internal/transport/http/v1/requests/page.go">
package requests

type ListPagesRequest struct {
	EnvironmentID string `json:"environment_id" validate:"required"`
}
</file>

<file path="internal/transport/http/v1/requests/user.go">
package requests

type CreateUserInvitationsRequest struct {
	Emails []string `json:"emails" validate:"required"`
	Role   string   `json:"role" validate:"required,oneof=admin developer member"`
}

type UpdateMeRequest struct {
	FirstName *string `json:"firstName"`
	LastName  *string `json:"lastName"`
}

type SendUpdateMeEmailInstructionsRequest struct {
	Email             string `json:"email" validate:"required,email"`
	EmailConfirmation string `json:"emailConfirmation" validate:"required,email"`
}

type UpdateMeEmailRequest struct {
	Token string `json:"token" validate:"required"`
}

type UpdateUserRequest struct {
	UserID   string   `json:"-" validate:"required,uuid4"`
	Role     *string  `json:"role" validate:"oneof=admin developer member"`
	GroupIDs []string `json:"groupIds"`
}

type DeleteUserRequest struct {
	UserID string `param:"userID" validate:"required,uuid4"`
}

type ResendUserInvitationRequest struct {
	InvitationID string `json:"invitationId" validate:"required,uuid"`
}
</file>

<file path="internal/transport/http/v1/responses/apikey.go">
package responses

type APIKeyResponse struct {
	ID          string               `json:"id"`
	Name        string               `json:"name"`
	Key         string               `json:"key"`
	CreatedAt   string               `json:"createdAt"`
	UpdatedAt   string               `json:"updatedAt"`
	Environment *EnvironmentResponse `json:"environment,omitempty"`
}

type GetAPIKeyResponse struct {
	APIKey *APIKeyResponse `json:"apiKey"`
}

type ListAPIKeysResponse struct {
	DevKey   *APIKeyResponse   `json:"devKey"`
	LiveKeys []*APIKeyResponse `json:"liveKeys"`
}

type CreateAPIKeyResponse struct {
	APIKey *APIKeyResponse `json:"apiKey"`
}

type UpdateAPIKeyResponse struct {
	APIKey *APIKeyResponse `json:"apiKey"`
}

type DeleteAPIKeyResponse struct {
	APIKey *APIKeyResponse `json:"apiKey"`
}
</file>

<file path="internal/transport/http/v1/responses/auth.go">
package responses

type RequestMagicLinkResponse struct {
	Email string `json:"email"`
	IsNew bool   `json:"isNew"`
}

type AuthenticateWithMagicLinkResponse struct {
	AuthURL         string `json:"authUrl"`
	Token           string `json:"token"`
	HasOrganization bool   `json:"hasOrganization"`
	IsNewUser       bool   `json:"isNewUser"`
}

type RegisterWithMagicLinkResponse struct {
	HasOrganization bool   `json:"hasOrganization"`
	ExpiresAt       string `json:"expiresAt"`
}

type RequestInvitationMagicLinkResponse struct {
	Email string `json:"email"`
}

type AuthenticateWithInvitationMagicLinkResponse struct {
	AuthURL   string `json:"authUrl"`
	Token     string `json:"token"`
	IsNewUser bool   `json:"isNewUser"`
}

type RegisterWithInvitationMagicLinkResponse struct {
	ExpiresAt string `json:"expiresAt"`
}

type RequestGoogleAuthLinkResponse struct {
	AuthURL string `json:"authUrl"`
}

type AuthenticateWithGoogleResponse struct {
	FirstName                string `json:"firstName,omitempty"`
	LastName                 string `json:"lastName,omitempty"`
	AuthURL                  string `json:"authUrl"`
	Token                    string `json:"token"`
	HasOrganization          bool   `json:"hasOrganization"`
	HasMultipleOrganizations bool   `json:"hasMultipleOrganizations"`
	IsNewUser                bool   `json:"isNewUser"`
}

type RegisterWithGoogleResponse struct {
	AuthURL         string `json:"authUrl"`
	Token           string `json:"token"`
	HasOrganization bool   `json:"hasOrganization"`
}

type RequestInvitationGoogleAuthLinkResponse struct {
	AuthURL string `json:"authUrl"`
}

type RefreshTokenResponse struct {
	ExpiresAt string `json:"expiresAt"`
}

type SaveAuthResponse struct {
	ExpiresAt   string `json:"expiresAt"`
	RedirectURL string `json:"redirectUrl"`
}

type ObtainAuthTokenResponse struct {
	AuthURL string `json:"authUrl"`
	Token   string `json:"token"`
}

type LogoutResponse struct {
	Domain string
}
</file>

<file path="internal/transport/http/v1/responses/environment.go">
package responses

type EnvironmentResponse struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Slug      string `json:"slug"`
	Color     string `json:"color"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type ListEnvironmentsResponse struct {
	Environments []*EnvironmentResponse `json:"environments"`
}

type GetEnvironmentResponse struct {
	Environment *EnvironmentResponse `json:"environment"`
}

type CreateEnvironmentResponse struct {
	Environment *EnvironmentResponse `json:"environment"`
}

type UpdateEnvironmentResponse struct {
	Environment *EnvironmentResponse `json:"environment"`
}

type DeleteEnvironmentResponse struct {
	Environment *EnvironmentResponse `json:"environment"`
}
</file>

<file path="internal/transport/http/v1/responses/group.go">
package responses

type GroupResponse struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Slug      string `json:"slug"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type GroupPageResponse struct {
	ID        string `json:"id"`
	GroupID   string `json:"groupId"`
	PageID    string `json:"pageId"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type ListGroupsResponse struct {
	Groups     []*GroupResponse     `json:"groups"`
	Users      []*UserResponse      `json:"users"`
	UserGroups []*UserGroupResponse `json:"userGroups"`
}

type GetGroupResponse struct {
	Group *GroupResponse `json:"group"`
}

type CreateGroupResponse struct {
	Group *GroupResponse `json:"group"`
}

type UpdateGroupResponse struct {
	Group *GroupResponse `json:"group"`
}

type DeleteGroupResponse struct {
	Group *GroupResponse `json:"group"`
}
</file>

<file path="internal/transport/http/v1/responses/hostinstance.go">
package responses

type HostInstanceResponse struct {
	ID         string `json:"id"`
	SDKName    string `json:"sdkName"`
	SDKVersion string `json:"sdkVersion"`
	Status     string `json:"status"`
	CreatedAt  string `json:"createdAt"`
	UpdatedAt  string `json:"updatedAt"`
}

type PingHostInstanceResponse struct {
	HostInstance *HostInstanceResponse `json:"hostInstance"`
}
</file>

<file path="internal/transport/http/v1/responses/organization.go">
package responses

type OrganizationResponse struct {
	ID                string `json:"id"`
	Subdomain         string `json:"subdomain"`
	WebSocketEndpoint string `json:"webSocketEndpoint"`
	CreatedAt         string `json:"createdAt"`
	UpdatedAt         string `json:"updatedAt"`
}

type CreateOrganizationResponse struct {
	Organization *OrganizationResponse `json:"organization"`
}
</file>

<file path="internal/transport/http/v1/responses/page.go">
package responses

type PageResponse struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Route     string `json:"route"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type ListPagesResponse struct {
	Pages      []*PageResponse      `json:"pages"`
	Groups     []*GroupResponse     `json:"groups"`
	GroupPages []*GroupPageResponse `json:"groupPages"`
	Users      []*UserResponse      `json:"users"`
	UserGroups []*UserGroupResponse `json:"userGroups"`
}
</file>

<file path="internal/transport/http/v1/responses/status.go">
package responses

type StatusResponse struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}
</file>

<file path="internal/transport/http/v1/responses/user.go">
package responses

type CreateUserInvitationsResponse struct {
	UserInvitations []*UserInvitationResponse `json:"userInvitations"`
}

type UserResponse struct {
	ID           string                `json:"id"`
	Email        string                `json:"email"`
	FirstName    string                `json:"firstName"`
	LastName     string                `json:"lastName"`
	Role         string                `json:"role"`
	CreatedAt    string                `json:"createdAt"`
	UpdatedAt    string                `json:"updatedAt"`
	Organization *OrganizationResponse `json:"organization"`
}

type UserInvitationResponse struct {
	ID        string `json:"id"`
	Email     string `json:"email"`
	CreatedAt string `json:"createdAt"`
}

type ListUsersResponse struct {
	Users           []*UserResponse           `json:"users"`
	UserInvitations []*UserInvitationResponse `json:"userInvitations"`
}

type GetMeResponse struct {
	User *UserResponse `json:"user"`
}

type UpdateMeResponse struct {
	User *UserResponse `json:"user"`
}

type UpdateMeEmailResponse struct {
	User *UserResponse `json:"user"`
}

type UpdateUserResponse struct {
	User *UserResponse `json:"user"`
}

type ResendUserInvitationResponse struct {
	UserInvitation *UserInvitationResponse `json:"userInvitation"`
}

type UserGroupResponse struct {
	ID        string `json:"id"`
	UserID    string `json:"userId"`
	GroupID   string `json:"groupId"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}
</file>

<file path="internal/transport/http/v1/middleware.go">
package v1

import (
	"context"
	"errors"
	"net/http"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
	"github.com/trysourcetool/sourcetool/backend/internal/jwt"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type Middleware interface {
	AuthUser(next http.Handler) http.Handler
	AuthUserWithOrganization(next http.Handler) http.Handler
	AuthUserWithOrganizationIfSubdomainExists(next http.Handler) http.Handler
	AuthOrganizationIfSubdomainExists(next http.Handler) http.Handler
	SetSubdomain(next http.Handler) http.Handler
}

type MiddlewareCE struct {
	port.Repository
}

func NewMiddlewareCE(r port.Repository) *MiddlewareCE {
	return &MiddlewareCE{r}
}

// authenticateUser handles common user authentication logic and returns the authenticated user.
func (m *MiddlewareCE) authenticateUser(w http.ResponseWriter, r *http.Request) (*user.User, error) {
	ctx := r.Context()

	xsrfTokenHeader := r.Header.Get("X-XSRF-TOKEN")
	if xsrfTokenHeader == "" {
		return nil, errdefs.ErrUnauthenticated(errors.New("failed to get XSRF token"))
	}

	xsrfTokenCookie, err := r.Cookie("xsrf_token_same_site")
	if err != nil {
		return nil, errdefs.ErrUnauthenticated(err)
	}

	token, err := r.Cookie("access_token")
	if err != nil {
		return nil, errdefs.ErrUnauthenticated(err)
	}

	c, err := m.validateUserToken(token.Value)
	if err != nil {
		return nil, errdefs.ErrUnauthenticated(err)
	}

	if err := validateXSRFToken(xsrfTokenHeader, xsrfTokenCookie.Value, c.XSRFToken); err != nil {
		return nil, errdefs.ErrUnauthenticated(err)
	}

	userID, err := uuid.FromString(c.UserID)
	if err != nil {
		return nil, errdefs.ErrUnauthenticated(err)
	}

	u, err := m.User().Get(ctx, user.ByID(userID))
	if err != nil {
		return nil, errdefs.ErrUnauthenticated(err)
	}

	return u, nil
}

func (m *MiddlewareCE) getSubdomainIfCloudEdition(r *http.Request) (string, error) {
	if !config.Config.IsCloudEdition {
		return "", nil
	}
	return internal.GetSubdomainFromHost(r.Host)
}

func (m *MiddlewareCE) validateOrganizationAccess(ctx context.Context, userID uuid.UUID, subdomain string) error {
	orgAccessOpts := []user.OrganizationAccessQuery{
		user.OrganizationAccessByUserID(userID),
	}
	if config.Config.IsCloudEdition {
		orgAccessOpts = append(orgAccessOpts, user.OrganizationAccessByOrganizationSubdomain(subdomain))
	}
	_, err := m.User().GetOrganizationAccess(ctx, orgAccessOpts...)
	return err
}

func (m *MiddlewareCE) getCurrentOrganization(ctx context.Context, subdomain string) (*organization.Organization, error) {
	opts := []organization.Query{}
	if subdomain != "" && subdomain != "auth" {
		opts = append(opts, organization.BySubdomain(subdomain))
	}

	return m.Organization().Get(ctx, opts...)
}

func (m *MiddlewareCE) validateUserToken(token string) (*jwt.UserAuthClaims, error) {
	if token == "" {
		return nil, errdefs.ErrUnauthenticated(errors.New("failed to get token"))
	}

	claims, err := jwt.ParseToken[*jwt.UserAuthClaims](token)
	if err != nil {
		return nil, errdefs.ErrUnauthenticated(err)
	}

	return claims, nil
}

func validateXSRFToken(header, cookie, claimToken string) error {
	if header == "" || cookie == "" || claimToken == "" {
		return errors.New("failed to get XSRF token")
	}
	if header != cookie && header != claimToken {
		return errors.New("invalid XSRF token")
	}
	return nil
}

func (m *MiddlewareCE) AuthUser(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		u, err := m.authenticateUser(w, r)
		if err != nil {
			internal.WriteErrJSON(ctx, w, err)
			return
		}

		ctx = context.WithValue(ctx, internal.CurrentUserCtxKey, u)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func (m *MiddlewareCE) AuthUserWithOrganization(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		u, err := m.authenticateUser(w, r)
		if err != nil {
			internal.WriteErrJSON(ctx, w, err)
			return
		}

		ctx = context.WithValue(ctx, internal.CurrentUserCtxKey, u)

		subdomain, err := m.getSubdomainIfCloudEdition(r)
		if err != nil {
			internal.WriteErrJSON(ctx, w, errdefs.ErrUnauthenticated(err))
			return
		}

		o, err := m.getCurrentOrganization(ctx, subdomain)
		if err != nil {
			internal.WriteErrJSON(ctx, w, errdefs.ErrUnauthenticated(err))
			return
		}

		if err := m.validateOrganizationAccess(ctx, u.ID, subdomain); err != nil {
			internal.WriteErrJSON(ctx, w, errdefs.ErrUnauthenticated(err))
			return
		}

		ctx = context.WithValue(ctx, internal.CurrentOrganizationCtxKey, o)

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func (m *MiddlewareCE) AuthUserWithOrganizationIfSubdomainExists(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		u, err := m.authenticateUser(w, r)
		if err != nil {
			internal.WriteErrJSON(ctx, w, err)
			return
		}

		ctx = context.WithValue(ctx, internal.CurrentUserCtxKey, u)

		subdomain, err := m.getSubdomainIfCloudEdition(r)
		if err != nil {
			internal.WriteErrJSON(ctx, w, errdefs.ErrUnauthenticated(err))
			return
		}

		if subdomain != "" && subdomain != "auth" {
			o, err := m.getCurrentOrganization(ctx, subdomain)
			if err != nil {
				internal.WriteErrJSON(ctx, w, errdefs.ErrUnauthenticated(err))
				return
			}

			if err := m.validateOrganizationAccess(ctx, u.ID, subdomain); err != nil {
				internal.WriteErrJSON(ctx, w, errdefs.ErrUnauthenticated(err))
				return
			}

			ctx = context.WithValue(ctx, internal.CurrentOrganizationCtxKey, o)
		}

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func (m *MiddlewareCE) AuthOrganizationIfSubdomainExists(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		subdomain, err := m.getSubdomainIfCloudEdition(r)
		if err != nil {
			internal.WriteErrJSON(ctx, w, errdefs.ErrUnauthenticated(err))
			return
		}

		if subdomain != "" && subdomain != "auth" {
			o, err := m.getCurrentOrganization(ctx, subdomain)
			if err != nil {
				internal.WriteErrJSON(ctx, w, errdefs.ErrUnauthenticated(err))
				return
			}

			ctx = context.WithValue(ctx, internal.CurrentOrganizationCtxKey, o)
		}

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func (m *MiddlewareCE) SetSubdomain(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		subdomain, _ := internal.GetSubdomainFromHost(r.Host)
		ctx := context.WithValue(r.Context(), internal.SubdomainCtxKey, subdomain)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}
</file>

<file path="internal/transport/http/v1/router.go">
package v1

import (
	"net/http"

	"github.com/go-chi/chi/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/handlers"
)

type Router struct {
	middleware   Middleware
	apikey       *handlers.APIKeyHandler
	auth         *handlers.AuthHandler
	environment  *handlers.EnvironmentHandler
	group        *handlers.GroupHandler
	hostInstance *handlers.HostInstanceHandler
	organization *handlers.OrganizationHandler
	page         *handlers.PageHandler
	user         *handlers.UserHandler
}

func NewRouter(
	middleware Middleware,
	apiKeyHandler *handlers.APIKeyHandler,
	authHandler *handlers.AuthHandler,
	environmentHandler *handlers.EnvironmentHandler,
	groupHandler *handlers.GroupHandler,
	hostInstanceHandler *handlers.HostInstanceHandler,
	organizationHandler *handlers.OrganizationHandler,
	pageHandler *handlers.PageHandler,
	userHandler *handlers.UserHandler,
) *Router {
	return &Router{
		middleware:   middleware,
		apikey:       apiKeyHandler,
		auth:         authHandler,
		environment:  environmentHandler,
		group:        groupHandler,
		hostInstance: hostInstanceHandler,
		organization: organizationHandler,
		page:         pageHandler,
		user:         userHandler,
	}
}

func (router *Router) Build() chi.Router {
	r := chi.NewRouter()
	r.Use(router.middleware.SetSubdomain)

	r.Get("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"status": "ok"}`))
	})

	r.Route("/v1", func(r chi.Router) {
		r.Route("/auth", func(r chi.Router) {
			r.Group(func(r chi.Router) {
				r.Use(router.middleware.AuthOrganizationIfSubdomainExists)

				r.Post("/magic/request", router.auth.RequestMagicLink)
				r.Post("/magic/authenticate", router.auth.AuthenticateWithMagicLink)
				r.Post("/magic/register", router.auth.RegisterWithMagicLink)
				r.Post("/invitations/magic/request", router.auth.RequestInvitationMagicLink)
				r.Post("/invitations/magic/authenticate", router.auth.AuthenticateWithInvitationMagicLink)
				r.Post("/invitations/magic/register", router.auth.RegisterWithInvitationMagicLink)

				r.Post("/google/request", router.auth.RequestGoogleAuthLink)
				r.Post("/google/authenticate", router.auth.AuthenticateWithGoogle)
				r.Post("/google/register", router.auth.RegisterWithGoogle)
				r.Post("/invitations/google/request", router.auth.RequestInvitationGoogleAuthLink)

				r.Post("/save", router.auth.Save)
				r.Post("/refresh", router.auth.RefreshToken)
			})

			r.Group(func(r chi.Router) {
				r.Use(router.middleware.AuthUserWithOrganizationIfSubdomainExists)
				r.Post("/token/obtain", router.auth.ObtainAuthToken)
			})

			r.Group(func(r chi.Router) {
				r.Use(router.middleware.AuthUserWithOrganization)
				r.Post("/logout", router.auth.Logout)
			})
		})

		r.Route("/users", func(r chi.Router) {
			r.Use(router.middleware.AuthUserWithOrganization)

			// Authenticated User
			r.Get("/me", router.user.GetMe)
			r.Put("/me", router.user.UpdateMe)
			r.Post("/me/email/instructions", router.user.SendUpdateMeEmailInstructions)
			r.Put("/me/email", router.user.UpdateMeEmail)

			// Organization Users
			r.Get("/", router.user.List)
			r.Put("/{userID}", router.user.Update)
			r.Delete("/{userID}", router.user.Delete)

			// Organization Invitations
			r.Post("/invitations", router.user.CreateUserInvitations)
			r.Post("/invitations/{invitationID}/resend", router.user.ResendUserInvitation)
		})

		r.Route("/organizations", func(r chi.Router) {
			r.Use(router.middleware.AuthUser)
			r.Post("/", router.organization.Create)
			r.Get("/checkSubdomainAvailability", router.organization.CheckSubdomainAvailability)
		})

		r.Route("/environments", func(r chi.Router) {
			r.Use(router.middleware.AuthUserWithOrganization)
			r.Get("/{environmentID}", router.environment.Get)
			r.Get("/", router.environment.List)
			r.Post("/", router.environment.Create)
			r.Put("/{environmentID}", router.environment.Update)
			r.Delete("/{environmentID}", router.environment.Delete)
		})

		r.Route("/groups", func(r chi.Router) {
			r.Use(router.middleware.AuthUserWithOrganization)
			r.Get("/{groupID}", router.group.Get)
			r.Get("/", router.group.List)
			r.Post("/", router.group.Create)
			r.Put("/{groupID}", router.group.Update)
			r.Delete("/{groupID}", router.group.Delete)
		})

		r.Route("/apiKeys", func(r chi.Router) {
			r.Use(router.middleware.AuthUserWithOrganization)
			r.Get("/{apiKeyID}", router.apikey.Get)
			r.Get("/", router.apikey.List)
			r.Post("/", router.apikey.Create)
			r.Put("/{apiKeyID}", router.apikey.Update)
			r.Delete("/{apiKeyID}", router.apikey.Delete)
		})

		r.Route("/pages", func(r chi.Router) {
			r.Use(router.middleware.AuthUserWithOrganization)
			r.Get("/", router.page.List)
		})

		r.Route("/hostInstances", func(r chi.Router) {
			r.Use(router.middleware.AuthUserWithOrganization)
			r.Get("/ping", router.hostInstance.Ping)
		})
	})

	return r
}
</file>

<file path="internal/transport/ws/handlers/handlers.go">
package handlers

import (
	"context"
	"net/http"
	"time"

	"github.com/gofrs/uuid/v5"
	"github.com/gorilla/websocket"
	"google.golang.org/protobuf/proto"

	"github.com/trysourcetool/sourcetool/backend/internal/app/dto"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	wsSvc "github.com/trysourcetool/sourcetool/backend/internal/app/ws"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/hostinstance"
	websocketv1 "github.com/trysourcetool/sourcetool/backend/internal/pb/go/websocket/v1"
	"github.com/trysourcetool/sourcetool/backend/internal/transport/ws/message"
	"github.com/trysourcetool/sourcetool/backend/logger"
)

const (
	// Time allowed to write a message to the peer.
	writeWait = 10 * time.Second

	// Send pings to peer with this period. Must be less than pongWait.
	pingPeriod = 30 * time.Second

	// Time allowed to read the next pong message from the peer.
	pongWait = pingPeriod * 2

	// Maximum message size allowed from peer.
	maxMessageSize = 512 * 1024 // 512KB

	// Maximum time to wait for connection recovery.
	maxRecoveryWait = 6 * time.Hour
)

type WebSocketHandler struct {
	upgrader  websocket.Upgrader
	wsManager port.WSManager
	service   wsSvc.Service
}

func NewWebSocketHandler(upgrader websocket.Upgrader, wsManager port.WSManager, service wsSvc.Service) *WebSocketHandler {
	return &WebSocketHandler{
		upgrader:  upgrader,
		wsManager: wsManager,
		service:   service,
	}
}

func (h *WebSocketHandler) Handle(w http.ResponseWriter, r *http.Request) {
	conn, err := h.upgrader.Upgrade(w, r, nil)
	if err != nil {
		logger.Logger.Sugar().Errorf("Failed to upgrade connection: %v", err)
		return
	}

	conn.SetReadLimit(maxMessageSize)
	conn.SetPongHandler(func(string) error {
		return conn.SetReadDeadline(time.Now().Add(pongWait))
	})

	ctx := internal.NewBackgroundContext(r.Context())

	done := make(chan struct{})
	defer func() {
		logger.Logger.Info("Closing connection")
		close(done)
		conn.Close()
	}()

	for {
		_, data, err := conn.ReadMessage()
		if err != nil {
			logger.Logger.Sugar().Debugf("Connection closed: %v", err)
			break
		}

		var msg websocketv1.Message
		if err := proto.Unmarshal(data, &msg); err != nil {
			logger.Logger.Sugar().Errorf("Failed to unmarshal message: %v", err)
			break
		}

		switch msg.Type.(type) {
		case *websocketv1.Message_InitializeHost:
			instanceID := r.Header.Get("X-Instance-Id")
			hostInstance, err := h.service.InitializeHost(ctx, conn, instanceID, &msg)
			if err != nil {
				message.SendErrResponse(ctx, conn, msg.Id, err)
				continue
			}

			defer func() {
				if err := h.updateHostInstanceStatus(ctx, hostInstance.ID, hostinstance.HostInstanceStatusOffline); err != nil {
					logger.Logger.Sugar().Errorf("Failed to update host instance status offline: %v", err)
				}
				h.wsManager.DisconnectHost(hostInstance.ID)
			}()

			go h.pingPongHostInstanceLoop(ctx, conn, done, hostInstance)
		case *websocketv1.Message_InitializeClient:
			if err := h.service.InitializeClient(ctx, conn, &msg); err != nil {
				message.SendErrResponse(ctx, conn, msg.Id, err)
				continue
			}
		case *websocketv1.Message_RenderWidget:
			if err := h.service.RenderWidget(ctx, conn, &msg); err != nil {
				message.SendErrResponse(ctx, conn, msg.Id, err)
				continue
			}
		case *websocketv1.Message_RerunPage:
			if err := h.service.RerunPage(ctx, conn, &msg); err != nil {
				message.SendErrResponse(ctx, conn, msg.Id, err)
				continue
			}
		case *websocketv1.Message_CloseSession:
			if err := h.service.CloseSession(ctx, conn, &msg); err != nil {
				message.SendErrResponse(ctx, conn, msg.Id, err)
				continue
			}
		case *websocketv1.Message_ScriptFinished:
			if err := h.service.ScriptFinished(ctx, conn, &msg); err != nil {
				message.SendErrResponse(ctx, conn, msg.Id, err)
				continue
			}
		case *websocketv1.Message_Exception:
			if err := h.service.Exception(ctx, conn, &msg); err != nil {
				message.SendErrResponse(ctx, conn, msg.Id, err)
				continue
			}
		default:
			logger.Logger.Sugar().Errorf("Unknown method: %s", msg.Type)
			continue
		}
	}
}

func (h *WebSocketHandler) updateHostInstanceStatus(ctx context.Context, hostInstanceID uuid.UUID, status hostinstance.HostInstanceStatus) error {
	if _, err := h.service.UpdateStatus(ctx, dto.UpdateHostInstanceStatusInput{
		ID:     hostInstanceID.String(),
		Status: status,
	}); err != nil {
		return err
	}

	return nil
}

func (h *WebSocketHandler) pingPongHostInstanceLoop(ctx context.Context, conn *websocket.Conn, done chan struct{}, hostInstance *hostinstance.HostInstance) {
	ticker := time.NewTicker(pingPeriod)
	defer func() {
		logger.Logger.Info("Stopped ping ticker")
		ticker.Stop()
	}()

	var firstFailureTime *time.Time
	for {
		select {
		case <-done:
			return
		case <-ticker.C:
			if err := conn.WriteControl(websocket.PingMessage, nil, time.Now().Add(writeWait)); err != nil {
				logger.Logger.Sugar().Errorf("Failed to write ping message: %v", err)
				// Record the first failure time if not already set
				if firstFailureTime == nil {
					now := time.Now()
					firstFailureTime = &now
					logger.Logger.Sugar().Infof("Recording first ping failure time: %v", now)
				}

				// Check if we've exceeded the maximum recovery wait time
				if time.Since(*firstFailureTime) > maxRecoveryWait {
					logger.Logger.Sugar().Infof("Connection unrecoverable after %v", maxRecoveryWait)
					return
				}
				if hostInstance.Status != hostinstance.HostInstanceStatusUnreachable {
					if err := h.updateHostInstanceStatus(ctx, hostInstance.ID, hostinstance.HostInstanceStatusUnreachable); err != nil {
						logger.Logger.Sugar().Errorf("Failed to update host instance status unreachable: %v", err)
					}
				}
				continue
			}
			// Reset failure time if ping succeeds
			if firstFailureTime != nil {
				logger.Logger.Info("Connection recovered, resetting failure time")
				firstFailureTime = nil
			}
			if hostInstance.Status != hostinstance.HostInstanceStatusOnline {
				if err := h.updateHostInstanceStatus(ctx, hostInstance.ID, hostinstance.HostInstanceStatusOnline); err != nil {
					logger.Logger.Sugar().Errorf("Failed to update host instance status online: %v", err)
				}
			}
		}
	}
}
</file>

<file path="internal/transport/ws/message/message.go">
package message

import (
	"context"
	"strings"

	"github.com/gorilla/websocket"
	"go.uber.org/zap"
	"google.golang.org/protobuf/proto"

	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	exceptionv1 "github.com/trysourcetool/sourcetool/backend/internal/pb/go/exception/v1"
	websocketv1 "github.com/trysourcetool/sourcetool/backend/internal/pb/go/websocket/v1"
	"github.com/trysourcetool/sourcetool/backend/logger"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

func SendResponse(conn *websocket.Conn, msg *websocketv1.Message) error {
	data, err := proto.Marshal(msg)
	if err != nil {
		return err
	}

	if err := conn.WriteMessage(websocket.BinaryMessage, data); err != nil {
		return err
	}

	return nil
}

func SendErrResponse(ctx context.Context, conn *websocket.Conn, id string, err error) {
	currentUser := internal.CurrentUser(ctx)
	var email string
	if currentUser != nil {
		email = currentUser.Email
	}

	e, ok := err.(*errdefs.Error)
	if !ok {
		logger.Logger.Error(
			err.Error(),
			zap.Stack("stack_trace"),
			zap.String("email", email),
			zap.String("cause", "application"),
		)

		v := errdefs.ErrInternal(err)
		e, _ = v.(*errdefs.Error)
	} else {
		fields := []zap.Field{
			zap.String("email", email),
			zap.String("error_stacktrace", strings.Join(e.StackTrace(), "\n")),
		}

		switch {
		case e.Status >= 500:
			fields = append(fields, zap.String("cause", "application"))
			logger.Logger.Error(err.Error(), fields...)
		case e.Status >= 402, e.Status == 400:
			fields = append(fields, zap.String("cause", "user"))
			logger.Logger.Error(err.Error(), fields...)
		default:
			fields = append(fields, zap.String("cause", "internal_info"))
			logger.Logger.Warn(err.Error(), fields...)
		}
	}

	msg := &websocketv1.Message{
		Id: id,
		Type: &websocketv1.Message_Exception{
			Exception: &exceptionv1.Exception{
				Title:      e.Title,
				Message:    e.Detail,
				StackTrace: e.StackTrace(),
			},
		},
	}

	data, err := proto.Marshal(msg)
	if err != nil {
		logger.Logger.Error("Failed to marshal WS error message", zap.Error(err))
		return
	}

	if err := conn.WriteMessage(websocket.BinaryMessage, data); err != nil {
		logger.Logger.Error("Failed to write WS error message", zap.Error(err))
		return
	}
}
</file>

<file path="internal/transport/ws/middleware.go">
package ws

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"strings"

	"github.com/gofrs/uuid/v5"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/domain/user"
	"github.com/trysourcetool/sourcetool/backend/internal/jwt"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
	"github.com/trysourcetool/sourcetool/backend/internal"
)

type Middleware interface {
	Auth(next http.Handler) http.Handler
}

type MiddlewareCE struct {
	port.Repository
}

func NewMiddlewareCE(r port.Repository) *MiddlewareCE {
	return &MiddlewareCE{r}
}

type ClientHeader struct {
	Token string `json:"Authorization"`
}

func (m *MiddlewareCE) Auth(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		subdomain, err := m.getSubdomainIfCloudEdition(r)
		if err != nil {
			internal.WriteErrJSON(ctx, w, errdefs.ErrUnauthenticated(err))
			return
		}

		o, err := m.getCurrentOrganization(ctx, subdomain)
		if err != nil {
			internal.WriteErrJSON(ctx, w, errdefs.ErrUnauthenticated(err))
			return
		}

		ctx = context.WithValue(ctx, internal.CurrentOrganizationCtxKey, o)

		if token, err := r.Cookie("access_token"); err == nil {
			u, err := m.getCurrentUser(ctx, r, token.Value)
			if err != nil {
				http.Error(w, err.Error(), http.StatusUnauthorized)
				return
			}

			ctx = context.WithValue(ctx, internal.CurrentUserCtxKey, u)
		} else if apiKeyHeader := r.Header.Get("Authorization"); apiKeyHeader != "" {
			apikeyVal, err := m.extractIncomingToken(apiKeyHeader)
			if err != nil {
				http.Error(w, err.Error(), http.StatusUnauthorized)
				return
			}

			apikey, err := m.Repository.APIKey().Get(ctx, apikey.ByKey(apikeyVal))
			if err != nil {
				http.Error(w, err.Error(), http.StatusUnauthorized)
				return
			}

			if o.ID != apikey.OrganizationID {
				http.Error(w, "organization not found", http.StatusUnauthorized)
				return
			}
		} else {
			http.Error(w, "failed to get token", http.StatusUnauthorized)
			return
		}

		r = r.WithContext(ctx)
		next.ServeHTTP(w, r)
	})
}

func (m *MiddlewareCE) getCurrentUser(ctx context.Context, r *http.Request, token string) (*user.User, error) {
	c, err := m.validateUserToken(token)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.FromString(c.UserID)
	if err != nil {
		return nil, errdefs.ErrUnauthenticated(err)
	}

	u, err := m.Repository.User().Get(ctx, user.ByID(userID))
	if err != nil {
		return nil, err
	}

	return u, nil
}

func (m *MiddlewareCE) getCurrentOrganization(ctx context.Context, subdomain string) (*organization.Organization, error) {
	opts := []organization.Query{}
	if subdomain != "" && subdomain != "auth" {
		opts = append(opts, organization.BySubdomain(subdomain))
	}

	return m.Repository.Organization().Get(ctx, opts...)
}

func (m *MiddlewareCE) validateUserToken(token string) (*jwt.UserAuthClaims, error) {
	if token == "" {
		return nil, errdefs.ErrUnauthenticated(errors.New("failed to get token"))
	}

	claims, err := jwt.ParseToken[*jwt.UserAuthClaims](token)
	if err != nil {
		return nil, errdefs.ErrUnauthenticated(err)
	}

	return claims, nil
}

func (m *MiddlewareCE) extractIncomingToken(headerValue string) (string, error) {
	if !strings.HasPrefix(strings.ToLower(headerValue), "bearer ") {
		return "", fmt.Errorf("invalid or malformed %q header, expected 'Bearer JWT-token...'", headerValue)
	}
	return strings.Split(headerValue, " ")[1], nil
}

func (m *MiddlewareCE) getSubdomainIfCloudEdition(r *http.Request) (string, error) {
	if !config.Config.IsCloudEdition {
		return "", nil
	}
	return internal.GetSubdomainFromHost(r.Host)
}
</file>

<file path="internal/transport/ws/router.go">
package ws

import (
	"github.com/go-chi/chi/v5"

	"github.com/trysourcetool/sourcetool/backend/internal/transport/ws/handlers"
)

type Router struct {
	middleware Middleware
	wsHandler  *handlers.WebSocketHandler
}

func NewRouter(middleware Middleware, wsHandler *handlers.WebSocketHandler) *Router {
	return &Router{
		middleware: middleware,
		wsHandler:  wsHandler,
	}
}

func (router *Router) Build() chi.Router {
	r := chi.NewRouter()
	r.With(router.middleware.Auth).HandleFunc("/", router.wsHandler.Handle)
	return r
}
</file>

<file path="internal/transport/router.go">
package transport

import (
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/cors"
	"github.com/gorilla/websocket"
	httpSwagger "github.com/swaggo/http-swagger"

	"github.com/trysourcetool/sourcetool/backend/config"
	"github.com/trysourcetool/sourcetool/backend/internal/app/apikey"
	"github.com/trysourcetool/sourcetool/backend/internal/app/auth"
	"github.com/trysourcetool/sourcetool/backend/internal/app/environment"
	"github.com/trysourcetool/sourcetool/backend/internal/app/group"
	"github.com/trysourcetool/sourcetool/backend/internal/app/hostinstance"
	"github.com/trysourcetool/sourcetool/backend/internal/app/organization"
	"github.com/trysourcetool/sourcetool/backend/internal/app/page"
	"github.com/trysourcetool/sourcetool/backend/internal/app/port"
	"github.com/trysourcetool/sourcetool/backend/internal/app/user"
	wsSvc "github.com/trysourcetool/sourcetool/backend/internal/app/ws"
	v1 "github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1"
	v1handlers "github.com/trysourcetool/sourcetool/backend/internal/transport/http/v1/handlers"
	wstransport "github.com/trysourcetool/sourcetool/backend/internal/transport/ws"
	wshandlers "github.com/trysourcetool/sourcetool/backend/internal/transport/ws/handlers"
)

type Router struct {
	wsRouter   *wstransport.Router
	httpRouter *v1.Router
}

func NewRouter(d *port.Dependencies) *Router {
	httpMiddle := v1.NewMiddlewareCE(d.Repository)
	apiKeyHandler := v1handlers.NewAPIKeyHandler(apikey.NewServiceCE(d))
	authHandler := v1handlers.NewAuthHandler(auth.NewServiceCE(d))
	environmentHandler := v1handlers.NewEnvironmentHandler(environment.NewServiceCE(d))
	groupHandler := v1handlers.NewGroupHandler(group.NewServiceCE(d))
	hostInstanceHandler := v1handlers.NewHostInstanceHandler(hostinstance.NewServiceCE(d))
	organizationHandler := v1handlers.NewOrganizationHandler(organization.NewServiceCE(d))
	pageHandler := v1handlers.NewPageHandler(page.NewServiceCE(d))
	userHandler := v1handlers.NewUserHandler(user.NewServiceCE(d))

	wsMiddle := wstransport.NewMiddlewareCE(d.Repository)
	wsHandler := wshandlers.NewWebSocketHandler(
		websocket.Upgrader{
			CheckOrigin: func(r *http.Request) bool {
				return true
			},
			ReadBufferSize:  1024,
			WriteBufferSize: 1024,
		},
		d.WSManager,
		wsSvc.NewServiceCE(d),
	)
	return &Router{
		wsRouter: wstransport.NewRouter(wsMiddle, wsHandler),
		httpRouter: v1.NewRouter(
			httpMiddle,
			apiKeyHandler,
			authHandler,
			environmentHandler,
			groupHandler,
			hostInstanceHandler,
			organizationHandler,
			pageHandler,
			userHandler,
		),
	}
}

func (r *Router) Build() chi.Router {
	router := chi.NewRouter()
	router.Use(middleware.RequestID)
	router.Use(middleware.Logger)
	router.Use(middleware.Recoverer)
	router.Use(middleware.Timeout(time.Duration(600) * time.Second))
	router.Use(cors.New(cors.Options{
		AllowOriginFunc: func(r *http.Request, origin string) bool {
			// For self-hosted environments, we only need to check against the configured base URL
			normalizedOrigin := strings.TrimRight(origin, "/")
			normalizedBaseURL := strings.TrimRight(config.Config.BaseURL, "/")
			return normalizedOrigin == normalizedBaseURL
		},
		AllowedMethods: []string{
			http.MethodGet,
			http.MethodPost,
			http.MethodPut,
			http.MethodDelete,
			http.MethodOptions,
		},
		AllowedHeaders:   []string{"*"},
		ExposedHeaders:   []string{},
		AllowCredentials: true,
		MaxAge:           0,
		Debug:            !(config.Config.Env == config.EnvProd),
	}).Handler)

	if config.Config.Env == config.EnvLocal {
		router.Get("/swagger/*", httpSwagger.Handler(
			httpSwagger.URL(fmt.Sprintf("%s/swagger/doc.json", "http://localhost:8080")),
		))
	}

	router.Mount("/ws", r.wsRouter.Build())
	router.Mount("/api", r.httpRouter.Build())

	staticDir := os.Getenv("STATIC_FILES_DIR")
	ServeStaticFiles(router, staticDir)

	return router
}
</file>

<file path="internal/transport/static.go">
package transport

import (
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/go-chi/chi/v5"

	"github.com/trysourcetool/sourcetool/backend/config"
)

// ServeStaticFiles configures the router to serve static files from the specified directory.
func ServeStaticFiles(r chi.Router, staticDir string) {
	staticDir = getStaticDir(staticDir)
	if staticDir == "" {
		fmt.Println("Static file serving is disabled (local environment)")
		return
	}
	fileServer := http.FileServer(http.Dir(staticDir))
	indexPath := findIndexFile(staticDir)

	r.Get("/*", func(w http.ResponseWriter, r *http.Request) {
		path := r.URL.Path
		filePath := filepath.Join(staticDir, path)

		if shouldServeFile(path, filePath) {
			serveFile(w, r, fileServer, path)
			return
		}

		serveIndexFile(w, r, indexPath)
	})
}

func getStaticDir(staticDir string) string {
	if staticDir == "" {
		staticDir = os.Getenv("STATIC_FILES_DIR")
		if staticDir == "" {
			// In local environment, return empty string to disable static serving
			return ""
		}
	}
	return staticDir
}

func findIndexFile(staticDir string) string {
	indexPath := filepath.Join(staticDir, "index.html")
	if _, err := os.Stat(indexPath); os.IsNotExist(err) {
		if staticDir == "/app/static" {
			alternativePath := "/app/static-full/client/index.html"
			if _, err := os.Stat(alternativePath); !os.IsNotExist(err) {
				fmt.Printf("Found index.html at alternative location: %s\n", alternativePath)
				return alternativePath
			}
		}
		fmt.Printf("WARNING: index.html not found at %s\n", indexPath)
	} else {
		fmt.Printf("Found index.html at: %s\n", indexPath)
	}
	return indexPath
}

func shouldServeFile(path, filePath string) bool {
	// Check if the file exists
	_, err := os.Stat(filePath)
	fileExists := !os.IsNotExist(err)

	// Always handle API, WebSocket, and Swagger paths with the file server
	// or if the file actually exists on disk and is not index.html
	return strings.HasPrefix(path, "/api/") ||
		strings.HasPrefix(path, "/ws") ||
		strings.HasPrefix(path, "/swagger") ||
		(fileExists && !strings.HasSuffix(filePath, "index.html"))
}

func setSecurityHeaders(w http.ResponseWriter) {
	w.Header().Set("X-Content-Type-Options", "nosniff")
	w.Header().Set("X-Frame-Options", "DENY")
	w.Header().Set("X-XSS-Protection", "1; mode=block")
	w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")
	w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")

	if config.Config.Env == config.EnvLocal {
		return
	}

	if config.Config.IsCloudEdition {
		w.Header().Set("Content-Security-Policy",
			"default-src 'self' *.trysourcetool.com; "+
				"script-src 'self' 'unsafe-inline' 'unsafe-eval' *.trysourcetool.com; "+
				"style-src 'self' 'unsafe-inline'; "+
				"img-src * data: blob:; "+
				"font-src * data:; "+
				"media-src *; "+
				"connect-src 'self' wss: *.trysourcetool.com https:;")
	} else {
		w.Header().Set("Content-Security-Policy",
			"default-src * 'unsafe-inline' 'unsafe-eval'; "+
				"img-src * data: blob:; "+
				"font-src * data:; "+
				"connect-src * ws: wss:;")
	}
}

func serveFile(w http.ResponseWriter, r *http.Request, fileServer http.Handler, path string) {
	setSecurityHeaders(w)
	if strings.HasPrefix(path, "/assets/") {
		w.Header().Set("Cache-Control", "public, max-age=31536000, immutable")
	} else {
		w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
		w.Header().Set("Pragma", "no-cache")
		w.Header().Set("Expires", "0")
	}
	fileServer.ServeHTTP(w, r)
}

func serveIndexFile(w http.ResponseWriter, r *http.Request, indexPath string) {
	// Set headers for SPA routing support
	w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
	w.Header().Set("Pragma", "no-cache")
	w.Header().Set("Expires", "0")
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	setSecurityHeaders(w)

	fmt.Printf("Serving index.html for client-side route: %s\n", r.URL.Path)
	http.ServeFile(w, r, indexPath)
}
</file>

<file path="logger/logger.go">
package logger

import (
	"log"

	"go.uber.org/zap"

	"github.com/trysourcetool/sourcetool/backend/config"
)

var Logger *zap.Logger

func Init() {
	var err error
	switch config.Config.Env {
	case config.EnvProd:
		Logger, err = zap.NewProduction()
	case config.EnvStaging:
		Logger, err = zap.NewProduction()
	default:
		Logger, err = zap.NewDevelopment()
	}
	if err != nil {
		log.Fatal(err)
	}
}
</file>

<file path="migrations/000001_initial_schema.down.sql">
BEGIN;

-- First drop all tables
DROP TABLE IF EXISTS "group_page";
DROP TABLE IF EXISTS "user_group";
DROP TABLE IF EXISTS "group";
DROP TABLE IF EXISTS "session";
DROP TABLE IF EXISTS "page";
DROP TABLE IF EXISTS "host_instance";
DROP TABLE IF EXISTS "host_instance_status";
DROP TABLE IF EXISTS "api_key";
DROP TABLE IF EXISTS "environment";
DROP TABLE IF EXISTS "user_invitation";
DROP TABLE IF EXISTS "user_organization_access";
DROP TABLE IF EXISTS "user_organization_role";
DROP TABLE IF EXISTS "organization";
DROP TABLE IF EXISTS "user";

-- Then drop all validation triggers
DROP TRIGGER IF EXISTS validate_group_page_trigger ON "group_page";
DROP TRIGGER IF EXISTS validate_user_group_trigger ON "user_group";
DROP TRIGGER IF EXISTS validate_session_trigger ON "session";
DROP TRIGGER IF EXISTS validate_page_trigger ON "page";
DROP TRIGGER IF EXISTS validate_host_instance_trigger ON "host_instance";
DROP TRIGGER IF EXISTS validate_api_key_trigger ON "api_key";

-- Drop all update_at triggers
DROP TRIGGER IF EXISTS update_group_page_updated_at ON "group_page";
DROP TRIGGER IF EXISTS update_user_group_updated_at ON "user_group";
DROP TRIGGER IF EXISTS update_group_updated_at ON "group";
DROP TRIGGER IF EXISTS update_session_updated_at ON "session";
DROP TRIGGER IF EXISTS update_page_updated_at ON "page";
DROP TRIGGER IF EXISTS update_host_instance_updated_at ON "host_instance";
DROP TRIGGER IF EXISTS update_host_instance_status_updated_at ON "host_instance_status";
DROP TRIGGER IF EXISTS update_api_key_updated_at ON "api_key";
DROP TRIGGER IF EXISTS update_environment_updated_at ON "environment";
DROP TRIGGER IF EXISTS update_user_invitation_updated_at ON "user_invitation";
DROP TRIGGER IF EXISTS update_user_organization_access_updated_at ON "user_organization_access";
DROP TRIGGER IF EXISTS update_user_organization_role_updated_at ON "user_organization_role";
DROP TRIGGER IF EXISTS update_organization_updated_at ON "organization";
DROP TRIGGER IF EXISTS update_user_updated_at ON "user";

-- Finally drop all functions
DROP FUNCTION IF EXISTS validate_group_page();
DROP FUNCTION IF EXISTS validate_user_group();
DROP FUNCTION IF EXISTS validate_session();
DROP FUNCTION IF EXISTS validate_page();
DROP FUNCTION IF EXISTS validate_host_instance();
DROP FUNCTION IF EXISTS validate_api_key();
DROP FUNCTION IF EXISTS update_updated_at_column();

END;
</file>

<file path="migrations/000001_initial_schema.up.sql">
BEGIN;

-- Function to automatically update updated_at columns
CREATE OR REPLACE FUNCTION update_updated_at_column() 
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- user table
CREATE TABLE "user" (
  "id"                 UUID          NOT NULL,
  "email"              VARCHAR(255)  NOT NULL,
  "first_name"         VARCHAR(255)  NOT NULL,
  "last_name"          VARCHAR(255)  NOT NULL,
  "refresh_token_hash" VARCHAR(255)  NOT NULL,
  "google_id"          VARCHAR(255)  NOT NULL,
  "created_at"         TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at"         TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY ("id")
);

CREATE UNIQUE INDEX idx_user_email ON "user" ("email");
CREATE UNIQUE INDEX idx_user_refresh_token_hash ON "user" ("refresh_token_hash");

CREATE TRIGGER update_user_updated_at
    BEFORE UPDATE ON "user"
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- organization table
CREATE TABLE "organization" (
  "id"         UUID          NOT NULL,
  "subdomain"  VARCHAR(255)  DEFAULT NULL,
  "created_at" TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY ("id")
);

CREATE UNIQUE INDEX idx_organization_subdomain ON organization (subdomain) WHERE subdomain IS NOT NULL;

CREATE TRIGGER update_organization_updated_at
    BEFORE UPDATE ON "organization"
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- user_organization_role table
CREATE TABLE "user_organization_role" (
  "code" INTEGER      NOT NULL,
  "name" VARCHAR(255) NOT NULL,
  PRIMARY KEY ("code")
);

CREATE UNIQUE INDEX idx_user_organization_role_code ON "user_organization_role" ("code");
CREATE UNIQUE INDEX idx_user_organization_role_name ON "user_organization_role" ("name");

INSERT INTO "user_organization_role" ("code", "name") VALUES
  (0, 'unknown'),
  (1, 'admin'),
  (2, 'developer'),
  (3, 'member');

-- user_organization_access table
CREATE TABLE "user_organization_access" (
  "id"              UUID        NOT NULL,
  "user_id"         UUID        NOT NULL,
  "organization_id" UUID        NOT NULL,
  "role"            INTEGER     NOT NULL,
  "created_at"      TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at"      TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY ("user_id") REFERENCES "user"("id") ON DELETE CASCADE,
  FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON DELETE CASCADE,
  FOREIGN KEY ("role") REFERENCES "user_organization_role"("code") ON DELETE RESTRICT,
  PRIMARY KEY ("id")
);

CREATE UNIQUE INDEX idx_user_organization_access_user_organization ON "user_organization_access" ("user_id", "organization_id");

CREATE TRIGGER update_user_organization_access_updated_at
    BEFORE UPDATE ON "user_organization_access"
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- user_invitation table
CREATE TABLE "user_invitation" (
  "id"              UUID          NOT NULL,
  "organization_id" UUID          NOT NULL,
  "email"           VARCHAR(255)  NOT NULL,
  "role"            INTEGER       NOT NULL,
  "created_at"      TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at"      TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON DELETE CASCADE,
  FOREIGN KEY ("role") REFERENCES "user_organization_role"("code") ON DELETE RESTRICT,
  PRIMARY KEY ("id")
);

CREATE UNIQUE INDEX idx_user_invitation_organization_email ON "user_invitation" ("organization_id", "email");

CREATE TRIGGER update_user_invitation_updated_at
    BEFORE UPDATE ON "user_invitation"
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- environment table
CREATE TABLE "environment" (
  "id"              UUID          NOT NULL,
  "organization_id" UUID          NOT NULL,
  "name"            VARCHAR(255)  NOT NULL,
  "slug"            VARCHAR(255)  NOT NULL,
  "color"           VARCHAR(255)  NOT NULL,
  "created_at"      TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at"      TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON DELETE CASCADE,
  PRIMARY KEY ("id")
);

CREATE UNIQUE INDEX idx_environment_organization_slug ON "environment" ("organization_id", "slug");

CREATE TRIGGER update_environment_updated_at
    BEFORE UPDATE ON "environment"
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- api_key table
CREATE OR REPLACE FUNCTION validate_api_key()
RETURNS TRIGGER AS $$
DECLARE
    environment_org_id UUID;
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM "user_organization_access" ua
        WHERE ua.user_id = NEW.user_id
        AND ua.organization_id = NEW.organization_id
    ) THEN
        RAISE EXCEPTION 'User % must belong to organization % to create an API key', NEW.user_id, NEW.organization_id;
    END IF;

    SELECT organization_id INTO environment_org_id
    FROM "environment"
    WHERE id = NEW.environment_id;

    IF environment_org_id != NEW.organization_id THEN
        RAISE EXCEPTION 'Environment % must belong to organization % to create an API key', NEW.environment_id, NEW.organization_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE "api_key" (
  "id"              UUID          NOT NULL,
  "organization_id" UUID          NOT NULL,
  "environment_id"  UUID          NOT NULL,
  "user_id"         UUID          NOT NULL,
  "name"            VARCHAR(255)  NOT NULL,
  "key"             TEXT          NOT NULL,
  "created_at"      TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at"      TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON DELETE CASCADE,
  FOREIGN KEY ("environment_id") REFERENCES "environment"("id") ON DELETE RESTRICT,
  FOREIGN KEY ("user_id") REFERENCES "user"("id") ON DELETE RESTRICT,
  PRIMARY KEY ("id")
);

CREATE UNIQUE INDEX idx_api_key_key ON "api_key" ("key");

CREATE TRIGGER update_api_key_updated_at
    BEFORE UPDATE ON "api_key"
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER validate_api_key
    BEFORE INSERT OR UPDATE ON "api_key"
    FOR EACH ROW
    EXECUTE FUNCTION validate_api_key();

-- host_instance table
CREATE OR REPLACE FUNCTION validate_host_instance()
RETURNS TRIGGER AS $$
DECLARE
    api_key_org_id UUID;
BEGIN
    SELECT organization_id INTO api_key_org_id
    FROM "api_key"
    WHERE id = NEW.api_key_id;

    IF api_key_org_id != NEW.organization_id THEN
        RAISE EXCEPTION 'API key % must belong to organization % to create a host instance', NEW.api_key_id, NEW.organization_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE "host_instance_status" (
  "code" INTEGER      NOT NULL,
  "name" VARCHAR(255) NOT NULL,
  PRIMARY KEY ("code")
);

CREATE UNIQUE INDEX idx_host_instance_status_code ON "host_instance_status" ("code");
CREATE UNIQUE INDEX idx_host_instance_status_name ON "host_instance_status" ("name");

INSERT INTO "host_instance_status" ("code", "name") VALUES
  (0, 'unknown'),
  (1, 'online'),
  (2, 'unreachable'),
  (3, 'offline'),
  (4, 'shuttingDown');

CREATE TABLE "host_instance" (
  "id"              UUID          NOT NULL,
  "organization_id" UUID          NOT NULL,
  "api_key_id"      UUID          NOT NULL,
  "sdk_name"        VARCHAR(255)  NOT NULL,
  "sdk_version"     VARCHAR(255)  NOT NULL,
  "status"          INTEGER       NOT NULL,
  "created_at"      TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at"      TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON DELETE CASCADE,
  FOREIGN KEY ("api_key_id") REFERENCES "api_key"("id") ON DELETE CASCADE,
  FOREIGN KEY ("status") REFERENCES "host_instance_status"("code") ON DELETE RESTRICT,
  PRIMARY KEY ("id")
);

CREATE TRIGGER update_host_instance_updated_at
    BEFORE UPDATE ON "host_instance"
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER validate_host_instance
    BEFORE INSERT OR UPDATE ON "host_instance"
    FOR EACH ROW
    EXECUTE FUNCTION validate_host_instance();

-- page table
CREATE OR REPLACE FUNCTION validate_page()
RETURNS TRIGGER AS $$
DECLARE
    environment_org_id UUID;
    api_key_org_id UUID;
BEGIN
    SELECT organization_id INTO environment_org_id
    FROM "environment"
    WHERE id = NEW.environment_id;

    IF environment_org_id != NEW.organization_id THEN
        RAISE EXCEPTION 'Environment % must belong to organization % to create a page', NEW.environment_id, NEW.organization_id;
    END IF;

    SELECT organization_id INTO api_key_org_id
    FROM "api_key"
    WHERE id = NEW.api_key_id;

    IF api_key_org_id != NEW.organization_id THEN
        RAISE EXCEPTION 'API key % must belong to organization % to create a page', NEW.api_key_id, NEW.organization_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE "page" (
  "id"               UUID          NOT NULL,
  "organization_id"  UUID          NOT NULL,
  "environment_id"   UUID          NOT NULL,
  "api_key_id"       UUID          NOT NULL,
  "name"             VARCHAR(255)  NOT NULL,
  "route"            VARCHAR(255)  NOT NULL,
  "path"             INTEGER[]     NOT NULL,
  "created_at"       TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at"       TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON DELETE CASCADE,
  FOREIGN KEY ("environment_id") REFERENCES "environment"("id") ON DELETE CASCADE,
  FOREIGN KEY ("api_key_id") REFERENCES "api_key"("id") ON DELETE CASCADE,
  PRIMARY KEY ("id")
);

CREATE UNIQUE INDEX idx_page_organization_api_key_route ON "page" ("organization_id", "api_key_id", "route");
CREATE UNIQUE INDEX idx_page_organization_api_key_path ON "page" ("organization_id", "api_key_id", "path");

CREATE TRIGGER update_page_updated_at
    BEFORE UPDATE ON "page"
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER validate_page
    BEFORE INSERT OR UPDATE ON "page"
    FOR EACH ROW
    EXECUTE FUNCTION validate_page();

-- session table
CREATE OR REPLACE FUNCTION validate_session()
RETURNS TRIGGER AS $$
DECLARE
    api_key_org_id UUID;
    host_instance_org_id UUID;
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM "user_organization_access" ua
        WHERE ua.user_id = NEW.user_id
        AND ua.organization_id = NEW.organization_id
    ) THEN
        RAISE EXCEPTION 'User % must belong to organization % to create a session', NEW.user_id, NEW.organization_id;
    END IF;

    SELECT organization_id INTO api_key_org_id
    FROM "api_key"
    WHERE id = NEW.api_key_id;

    IF api_key_org_id != NEW.organization_id THEN
        RAISE EXCEPTION 'API key % must belong to organization % to create a session', NEW.api_key_id, NEW.organization_id;
    END IF;

    SELECT organization_id INTO host_instance_org_id
    FROM "host_instance"
    WHERE id = NEW.host_instance_id;

    IF host_instance_org_id != NEW.organization_id THEN
        RAISE EXCEPTION 'Host instance % must belong to organization % to create a session', NEW.host_instance_id, NEW.organization_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE "session" (
  "id"               UUID        NOT NULL,
  "organization_id"  UUID        NOT NULL,
  "user_id"          UUID        NOT NULL,
  "api_key_id"       UUID        NOT NULL,
  "host_instance_id" UUID        NOT NULL,
  "created_at"       TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at"       TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON DELETE CASCADE,
  FOREIGN KEY ("user_id") REFERENCES "user"("id") ON DELETE CASCADE,
  FOREIGN KEY ("api_key_id") REFERENCES "api_key"("id") ON DELETE CASCADE,
  FOREIGN KEY ("host_instance_id") REFERENCES "host_instance"("id") ON DELETE CASCADE,
  PRIMARY KEY ("id")
);

CREATE TRIGGER update_session_updated_at
    BEFORE UPDATE ON "session"
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


CREATE TRIGGER validate_session
    BEFORE INSERT OR UPDATE ON "session"
    FOR EACH ROW
    EXECUTE FUNCTION validate_session();

-- group table
CREATE TABLE "group" (
  "id"               UUID          NOT NULL,
  "organization_id"  UUID          NOT NULL,
  "name"             VARCHAR(255)  NOT NULL,
  "slug"             VARCHAR(255)  NOT NULL,
  "created_at"       TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at"       TIMESTAMPTZ   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON DELETE CASCADE,
  UNIQUE("organization_id", "slug"),
  PRIMARY KEY ("id")
);

CREATE TRIGGER update_group_updated_at
    BEFORE UPDATE ON "group"
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- user_group table
CREATE OR REPLACE FUNCTION validate_user_group()
RETURNS TRIGGER AS $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM "user_organization_access" ua
    JOIN "group" g ON g.organization_id = ua.organization_id
    WHERE ua.user_id = NEW.user_id
    AND g.id = NEW.group_id
  ) THEN
    RAISE EXCEPTION 'User % and Group % must belong to the same organization', NEW.user_id, NEW.group_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE "user_group" (
  "id"         UUID        NOT NULL,
  "user_id"    UUID        NOT NULL,
  "group_id"   UUID        NOT NULL,
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY ("user_id") REFERENCES "user"("id") ON DELETE CASCADE,
  FOREIGN KEY ("group_id") REFERENCES "group"("id") ON DELETE CASCADE,
  UNIQUE("user_id", "group_id"),
  PRIMARY KEY ("id")
);

CREATE TRIGGER update_user_group_updated_at
    BEFORE UPDATE ON "user_group"
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER validate_user_group
    BEFORE INSERT OR UPDATE ON "user_group"
    FOR EACH ROW
    EXECUTE FUNCTION validate_user_group();

-- group_page table
CREATE OR REPLACE FUNCTION validate_group_page()
RETURNS TRIGGER AS $$
DECLARE
    group_org_id UUID;
    page_org_id UUID;
BEGIN
    SELECT organization_id INTO group_org_id
    FROM "group"
    WHERE id = NEW.group_id;

    SELECT organization_id INTO page_org_id
    FROM "page"
    WHERE id = NEW.page_id;

    IF group_org_id != page_org_id THEN
        RAISE EXCEPTION 'Group % and Page % must belong to the same organization', NEW.group_id, NEW.page_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE "group_page" (
  "id"         UUID        NOT NULL,
  "group_id"   UUID        NOT NULL,
  "page_id"    UUID        NOT NULL,
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY ("group_id") REFERENCES "group"("id") ON DELETE CASCADE,
  FOREIGN KEY ("page_id") REFERENCES "page"("id") ON DELETE CASCADE,
  UNIQUE("group_id", "page_id"),
  PRIMARY KEY ("id")
);

CREATE TRIGGER update_group_page_updated_at
    BEFORE UPDATE ON "group_page"
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER validate_group_page
    BEFORE INSERT OR UPDATE ON "group_page"
    FOR EACH ROW
    EXECUTE FUNCTION validate_group_page();

END;
</file>

<file path="internal/errdefs/errdefs.go">
package errdefs

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"runtime"
	"strings"
)

var (
	ErrInternal                           = Status("internal_server_error", 500)
	ErrDatabase                           = Status("database_error", 500)
	ErrPermissionDenied                   = Status("permission_denied", 403)
	ErrInvalidArgument                    = Status("invalid_argument", 400)
	ErrAlreadyExists                      = Status("already_exists", 409)
	ErrUnauthenticated                    = Status("unauthenticated", 401)
	ErrAPIKeyNotFound                     = Status("api_key_not_found", 404)
	ErrEnvironmentNotFound                = Status("environment_not_found", 404)
	ErrEnvironmentSlugAlreadyExists       = Status("environment_slug_already_exists", 409)
	ErrEnvironmentDeletionNotAllowed      = Status("environment_deletion_not_allowed", 409)
	ErrGroupNotFound                      = Status("group_not_found", 404)
	ErrGroupSlugAlreadyExists             = Status("group_slug_already_exists", 409)
	ErrHostInstanceNotFound               = Status("host_instance_not_found", 404)
	ErrHostInstanceStatusNotOnline        = Status("host_instance_status_not_online", 404)
	ErrHostConnectionNotFound             = Status("host_connection_not_found", 404)
	ErrHostConnectionClosed               = Status("host_connection_closed", 502)
	ErrOrganizationNotFound               = Status("organization_not_found", 404)
	ErrOrganizationSubdomainAlreadyExists = Status("organization_subdomain_already_exists", 409)
	ErrPageNotFound                       = Status("page_not_found", 404)
	ErrSessionNotFound                    = Status("session_not_found", 404)
	ErrUserNotFound                       = Status("user_not_found", 404)
	ErrUserEmailAlreadyExists             = Status("user_email_already_exists", 409)
	ErrUserRegistrationRequestNotFound    = Status("user_registration_request_not_found", 404)
	ErrUserInvitationNotFound             = Status("user_invitation_not_found", 404)
	ErrUserGoogleAuthRequestNotFound      = Status("user_google_auth_request_not_found", 404)
	ErrUserOrganizationAccessNotFound     = Status("user_organization_access_not_found", 404)
	ErrUserGroupNotFound                  = Status("user_group_not_found", 404)
	ErrUserMultipleOrganizations          = Status("user_multiple_organizations", 422)
)

type Meta []any

type Error struct {
	ID     string         `json:"id"`
	Status int            `json:"status"`
	Title  string         `json:"title"`
	Detail string         `json:"detail"`
	Meta   map[string]any `json:"meta"`
	Frames stackTrace     `json:"-"`
}

type StatusFunc func(error, ...any) error

func Status(title string, status int) StatusFunc {
	return func(err error, vals ...any) error {
		e := &Error{
			ID:     errID(),
			Status: status,
			Title:  title,
			Detail: err.Error(),
			Meta:   make(map[string]any),
			Frames: newFrame(callers()),
		}

		for _, any := range vals {
			switch any := any.(type) {
			case Meta:
				e.Meta = appendMeta(e.Meta, any...)
			}
		}

		return e
	}
}

func (e *Error) Error() string {
	if e.Detail == "" {
		return e.Title
	}

	return e.Detail
}

func (e *Error) StackTrace() []string {
	if len(e.Frames) == 0 {
		return nil
	}
	var stack []string
	for _, frame := range e.Frames {
		stack = append(stack, frame.String())
	}
	return stack
}

func appendMeta(meta map[string]any, keyvals ...any) map[string]any {
	if meta == nil {
		meta = make(map[string]any)
	}
	var k string
	for n, v := range keyvals {
		if n%2 == 0 {
			k = fmt.Sprint(v)
		} else {
			meta[k] = v
		}
	}
	return meta
}

type frame struct {
	file           string
	lineNumber     int
	name           string
	programCounter uintptr
}

type stackTrace []*frame

func newFrame(pcs []uintptr) stackTrace {
	frames := []*frame{}

	for _, pc := range pcs {
		frame := &frame{programCounter: pc}
		fn := runtime.FuncForPC(pc)
		if fn == nil {
			return frames
		}
		frame.name = trimPkgName(fn)

		frame.file, frame.lineNumber = fn.FileLine(pc - 1)
		frames = append(frames, frame)
	}

	return frames
}

func (f *frame) String() string {
	return fmt.Sprintf("%s:%d %s", f.file, f.lineNumber, f.name)
}

func trimPkgName(fn *runtime.Func) string {
	name := fn.Name()
	if ld := strings.LastIndex(name, "."); ld >= 0 {
		name = name[ld+1:]
	}

	return name
}

func callers() []uintptr {
	const depth = 32
	var pcs [depth]uintptr
	n := runtime.Callers(3, pcs[:])

	return pcs[0:n]
}

func errID() string {
	b := make([]byte, 6)
	io.ReadFull(rand.Reader, b)

	return base64.StdEncoding.EncodeToString(b)
}

func IsEnvironmentNotFound(err error) bool {
	val, ok := err.(*Error)
	if !ok {
		return false
	}
	return val.Title == "environment_not_found"
}

func IsGroupNotFound(err error) bool {
	val, ok := err.(*Error)
	if !ok {
		return false
	}
	return val.Title == "group_not_found"
}

func IsOrganizationNotFound(err error) bool {
	val, ok := err.(*Error)
	if !ok {
		return false
	}
	return val.Title == "organization_not_found"
}

func IsPageNotFound(err error) bool {
	val, ok := err.(*Error)
	if !ok {
		return false
	}
	return val.Title == "page_not_found"
}

func IsSessionNotFound(err error) bool {
	val, ok := err.(*Error)
	if !ok {
		return false
	}
	return val.Title == "session_not_found"
}

func IsHostInstanceNotFound(err error) bool {
	val, ok := err.(*Error)
	if !ok {
		return false
	}
	return val.Title == "host_instance_not_found"
}

func IsUserNotFound(err error) bool {
	val, ok := err.(*Error)
	if !ok {
		return false
	}
	return val.Title == "user_not_found"
}

func IsUserRegistrationRequestNotFound(err error) bool {
	val, ok := err.(*Error)
	if !ok {
		return false
	}
	return val.Title == "user_registration_request_not_found"
}

func IsUserInvitationNotFound(err error) bool {
	val, ok := err.(*Error)
	if !ok {
		return false
	}
	return val.Title == "user_invitation_not_found"
}

func IsUserOrganizationAccessNotFound(err error) bool {
	val, ok := err.(*Error)
	if !ok {
		return false
	}
	return val.Title == "user_organization_access_not_found"
}

func IsUserGoogleAuthRequestNotFound(err error) bool {
	val, ok := err.(*Error)
	if !ok {
		return false
	}
	return val.Title == "user_google_auth_request_not_found"
}
</file>

<file path="internal/httpx_test.go">
package httpx

import (
	"testing"

	"github.com/go-playground/validator/v10"
)

type testPasswordStruct struct {
	Password string `validate:"required,password"`
}

func TestValidatePassword(t *testing.T) {
	tests := []struct {
		name     string
		password string
		wantErr  bool
	}{
		{
			name:     "valid password with minimum requirements",
			password: "Password1",
			wantErr:  false,
		},
		{
			name:     "valid password with special characters",
			password: "Password1!@#$",
			wantErr:  false,
		},
		{
			name:     "valid password with all allowed special characters",
			password: "Pass1!?_+*'\"` $%&-^@;:,./=~|[](){}<>",
			wantErr:  true,
		},
		{
			name:     "valid password with some allowed special characters",
			password: "Pass1!?_+*'\"@;:,./=~|[](){}<>",
			wantErr:  false,
		},
		{
			name:     "too short password",
			password: "Pass1",
			wantErr:  true,
		},
		{
			name:     "password without letters",
			password: "12345678",
			wantErr:  true,
		},
		{
			name:     "password without numbers",
			password: "Password",
			wantErr:  true,
		},
		{
			name:     "password with invalid special characters",
			password: "Password1",
			wantErr:  true,
		},
		{
			name:     "empty password",
			password: "",
			wantErr:  true,
		},
		{
			name:     "password with spaces",
			password: "Password 1",
			wantErr:  true,
		},
		{
			name:     "password with japanese characters",
			password: "Password1",
			wantErr:  true,
		},
	}

	v := validator.New()
	v.RegisterValidation("password", validatePassword)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			test := &testPasswordStruct{
				Password: tt.password,
			}
			err := v.Struct(test)
			if (err != nil) != tt.wantErr {
				t.Errorf("validatePassword() error = %v, wantErr %v", err, tt.wantErr)
				if err != nil {
					t.Logf("validation error details: %v", err)
				}
			}
		})
	}
}
</file>

<file path="internal/internal.go">
package httpx

import (
	"context"
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"net"
	"net/http"
	"regexp"
	"strings"

	"github.com/go-playground/validator/v10"
	"go.uber.org/zap"
	"golang.org/x/net/html"

	"github.com/trysourcetool/sourcetool/backend/internal/ctxdata"
	"github.com/trysourcetool/sourcetool/backend/logger"
	"github.com/trysourcetool/sourcetool/backend/internal/errdefs"
)

func WriteJSON(w http.ResponseWriter, status int, v any) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	if _, err := w.Write(b); err != nil {
		return err
	}

	return nil
}

func WriteBytes(w http.ResponseWriter, status int, b []byte) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)

	if _, err := w.Write(b); err != nil {
		return err
	}

	return nil
}

func WriteErrJSON(ctx context.Context, w http.ResponseWriter, err error) {
	currentUser := internal.CurrentUser(ctx)
	var email string
	if currentUser != nil {
		email = currentUser.Email
	}

	v, ok := err.(*errdefs.Error)
	if !ok {
		logger.Logger.Error(
			err.Error(),
			zap.Stack("stack_trace"),
			zap.String("email", email),
			zap.String("cause", "application"),
		)

		WriteJSON(
			w,
			http.StatusInternalServerError,
			errdefs.ErrInternal(err),
		)
		return
	}

	fields := []zap.Field{
		zap.String("email", email),
		zap.String("error_stacktrace", strings.Join(v.StackTrace(), "\n")),
	}

	switch {
	case v.Status >= 500:
		fields = append(fields, zap.String("cause", "application"))
		logger.Logger.Error(err.Error(), fields...)
	case v.Status >= 402, v.Status == 400:
		fields = append(fields, zap.String("cause", "user"))
		logger.Logger.Error(err.Error(), fields...)
	default:
		fields = append(fields, zap.String("cause", "internal_info"))
		logger.Logger.Warn(err.Error(), fields...)
	}

	WriteJSON(w, v.Status, v)
}

func ValidateRequest(p any) error {
	v := validator.New()
	v.RegisterValidation("password", validatePassword)

	if err := v.Struct(p); err != nil {
		return errdefs.ErrInvalidArgument(err)
	}

	return nil
}

func validatePassword(fl validator.FieldLevel) bool {
	password := fl.Field().String()

	// Check minimum length
	if len(password) < 8 {
		return false
	}

	// Check for at least one letter
	hasLetter := false
	for _, c := range password {
		if (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') {
			hasLetter = true
			break
		}
	}
	if !hasLetter {
		return false
	}

	// Check for at least one digit
	hasDigit := false
	for _, c := range password {
		if c >= '0' && c <= '9' {
			hasDigit = true
			break
		}
	}
	if !hasDigit {
		return false
	}

	// Check for valid characters only
	validChars := regexp.MustCompile(`^[a-zA-Z0-9!?_+*'"\` + "`" + `#$%&\-^\\@;:,./=~|[\](){}<>]+$`)
	return validChars.MatchString(password)
}

func ValidateJSONString(s string) error {
	var in any
	return json.Unmarshal([]byte(s), &in)
}

func ValidateHTMLString(s string) error {
	if _, err := html.Parse(strings.NewReader(s)); err != nil {
		return err
	}
	return nil
}

func ValidateXMLString(s string) error {
	var in any
	return xml.Unmarshal([]byte(s), &in)
}

func GetIP(r *http.Request) (string, error) {
	addr := r.Header.Get("X-Forwarded-For")
	if addr == "" {
		addr = r.RemoteAddr
	}

	ip, _, err := net.SplitHostPort(addr)
	if err != nil {
		return "", fmt.Errorf("userip: %q is not IP:port", addr)
	}

	userIP := net.ParseIP(ip)
	if userIP == nil {
		return "", fmt.Errorf("userip: %q is not IP:port", addr)
	}

	return userIP.String(), nil
}

func GetSubdomainFromHost(host string) (string, error) {
	if host == "" {
		return "", errors.New("empty host")
	}
	parts := strings.Split(host, ".")
	if len(parts) < 2 {
		return "", errors.New("invalid host format")
	}
	return parts[0], nil
}
</file>

<file path="internal/internal.go">
package internal

import "github.com/samber/lo"

func SafeValue[T comparable](in *T) T {
	if in == nil {
		return lo.Empty[T]()
	}
	return *in
}

func NilValue[T comparable](in T) *T {
	if lo.IsEmpty(in) {
		return nil
	}
	return &in
}
</file>

<file path="internal/urlx.go">
package urlx

import (
	"net/url"
)

func BuildURL(baseURL, path string, params map[string]string) (string, error) {
	u, err := url.Parse(baseURL)
	if err != nil {
		return "", err
	}

	u.Path = path

	if len(params) > 0 {
		q := u.Query()
		for k, v := range params {
			q.Add(k, v)
		}
		u.RawQuery = q.Encode()
	}

	return u.String(), nil
}
</file>

<file path=".dockerignore">
# Version control
.git
.gitignore
.dockerignore

# Build artifacts
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
*.out

# Go specific
/vendor/
/bin/
/pkg/

# IDE specific
.idea/
.vscode/
*.swp
*.swo
*~

# OS specific
.DS_Store
Thumbs.db

# Local development
*.env
*.env.local
*.log
/tmp/
</file>

<file path=".golangci.yml">
run:
  timeout: 5m
  issues:
    exclude-dirs:
      - testdata
    exclude-files:
      - config/config.go

linters:
  enable:
    - asciicheck
    - copyloopvar
    - gci
    - godot
    - gofmt
    - gofumpt
    - goimports
    - gomodguard
    - goprintffuncname
    - gosimple
    - gosec
    - govet
    - ineffassign
    - misspell
    - nakedret
    - nolintlint
    - sqlclosecheck
    - staticcheck
    - typecheck
    - unconvert
    - unused
    - whitespace
  disable:
    - depguard
    - errcheck
    - funlen
    - err113
    - gochecknoglobals
    - gocognit
    - goconst
    - gocyclo
    - godox
    - lll
    - nestif
    - nlreturn
    - noctx
    - testpackage
    - wsl

linters-settings:
  gofumpt:
    extra-rules: true
  misspell:
    locale: US
  gci:
    sections:
      - standard
      - default
      - prefix(github.com/trysourcetool/sourcetool/backend)
</file>

<file path="go.mod">
module github.com/trysourcetool/sourcetool/backend

go 1.22.0

require (
	github.com/Masterminds/squirrel v1.5.4
	github.com/caarlos0/env/v11 v11.3.1
	github.com/go-chi/chi/v5 v5.1.0
	github.com/go-chi/cors v1.2.1
	github.com/go-playground/validator/v10 v10.23.0
	github.com/gofrs/uuid/v5 v5.3.0
	github.com/golang-jwt/jwt/v5 v5.2.1
	github.com/golang-migrate/migrate/v4 v4.18.2
	github.com/gorilla/websocket v1.5.3
	github.com/jmoiron/sqlx v1.4.0
	github.com/lib/pq v1.10.9
	github.com/redis/go-redis/v9 v9.7.0
	github.com/samber/lo v1.47.0
	github.com/stretchr/testify v1.9.0
	github.com/swaggo/http-swagger v1.3.4
	github.com/swaggo/swag v1.16.4
	go.uber.org/zap v1.27.0
	golang.org/x/exp v0.0.0-20230315142452-642cacee5cc0
	golang.org/x/net v0.33.0
	golang.org/x/oauth2 v0.24.0
	golang.org/x/sync v0.10.0
	google.golang.org/api v0.210.0
	google.golang.org/protobuf v1.35.2
)

require (
	cloud.google.com/go/auth v0.11.0 // indirect
	cloud.google.com/go/auth/oauth2adapt v0.2.6 // indirect
	cloud.google.com/go/compute/metadata v0.5.2 // indirect
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/gabriel-vasile/mimetype v1.4.3 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-openapi/jsonpointer v0.21.0 // indirect
	github.com/go-openapi/jsonreference v0.21.0 // indirect
	github.com/go-openapi/spec v0.21.0 // indirect
	github.com/go-openapi/swag v0.23.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
	github.com/google/s2a-go v0.1.8 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/googleapis/enterprise-certificate-proxy v0.3.4 // indirect
	github.com/googleapis/gax-go/v2 v2.14.0 // indirect
	github.com/hashicorp/errwrap v1.1.0 // indirect
	github.com/hashicorp/go-multierror v1.1.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/lann/builder v0.0.0-20180802200727-47ae307949d0 // indirect
	github.com/lann/ps v0.0.0-20150810152359-62de8c46ede0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/swaggo/files v0.0.0-20220610200504-28940afbdbfe // indirect
	go.opencensus.io v0.24.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0 // indirect
	go.opentelemetry.io/otel v1.29.0 // indirect
	go.opentelemetry.io/otel/metric v1.29.0 // indirect
	go.opentelemetry.io/otel/trace v1.29.0 // indirect
	go.uber.org/atomic v1.7.0 // indirect
	go.uber.org/multierr v1.10.0 // indirect
	golang.org/x/crypto v0.31.0 // indirect
	golang.org/x/sys v0.28.0 // indirect
	golang.org/x/text v0.21.0 // indirect
	golang.org/x/tools v0.28.0 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20241118233622-e639e219e697 // indirect
	google.golang.org/grpc v1.67.1 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
</file>

<file path=".gitignore">
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
vendor/

# Go workspace file
go.work

# IDE specific files
.idea/
.vscode/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Environment files
.env
.env.local
*.env

# Debug files
debug
*.log

# Binary directory
bin/
dist/

# Local development
tmp/

# Debug
cookies.txt
</file>

<file path="README.md">
# Sourcetool Backend API

A Go-based backend service for the Sourcetool project.

> **Note:** This project now uses a consolidated setup with Docker Compose and a root Makefile.
> See the [root README.md](../README.md) for instructions on how to start the entire application.

## Overview

The backend provides the API for the Sourcetool application, handling:
- User authentication and authorization
- Organization management
- Group management
- Page management
- Environment management
- API key management
- WebSocket connections

## Technology

- Go 1.22
- PostgreSQL 15
- Redis 7
- Docker

## Directory Structure

- `/cmd` - Application entry points
- `/config` - Configuration handling
- `/devtools` - Development tools
- `/docs` - API documentation (Swagger)
- `/ee` - Enterprise features (if applicable)
- `/fixtures` - Test fixtures and data
- `/internal` - Internal application logic and packages
  - `/app` - Application layer services
  - `/domain` - Core domain models and business logic
  - `/infra` - Infrastructure components (database, external services)
    - `/postgres` - PostgreSQL specific implementations
    - `/smtp` - SMTP based email service
    - `/redis` - Redis based pub/sub service
    - `/wsmanager` - WebSocket connection management
  - `/pb` - Protocol Buffer definitions and generated code
  - `/transport` - API transport layer (HTTP and WebSocket handlers)
    - `/http` - HTTP API handlers and routing
      - `/v1` - Version 1 of the HTTP API
        - `/handlers` - HTTP request handlers
        - `/requests` - Request models and validation
        - `/responses` - Response models
        - `/mapper` - Data mapping utilities
        - `/middleware` - HTTP middleware components
    - `/ws` - WebSocket handlers and routing
      - `/handlers` - WebSocket message handlers
      - `/message` - WebSocket message utilities
      - `/middleware` - WebSocket middleware components
    - `router.go` - Main router configuration
    - `static.go` - Static file serving configuration
  - `/jwt` - JWT handling utilities
  - `/ctxdata` - Context data utility functions
- `/logger` - Logging utilities
- `/migrations` - Database migrations
- `/pkg` - Public library code usable by external applications
</file>

</files>
